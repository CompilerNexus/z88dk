#!/usr/bin/env perl

#------------------------------------------------------------------------------
# Generate state machine to parse input parser rules
#------------------------------------------------------------------------------

use Modern::Perl;
use YAML::Tiny;

@ARGV==2 or die "Usage: $0 input_parser.yaml output_file.def\n";
my($input_file, $output_file) = @ARGV;

my $yaml = YAML::Tiny->read($input_file);
my %parser = %{$yaml->[0]};

my $tree = { state=>0, next=>{}, current=>"top" };
my @states = ($tree);
my @actions = ('');		# actions start at 1
my %actions;
my %keywords;

# read keywords from source
%keywords = read_keywords("../../src/cpp/keyword.def");
my $nr_keywords = scalar(keys %keywords);

# read tokens from source
my %tokens = read_tokens("../../src/cpp/lex.h");
my $nr_tokens = scalar(keys %tokens);

# convert parser data into trie tree
for my $asm (sort keys %parser) {
	my @asm = split(' ', $asm);
	my $current = $asm =~ s/\b\w+:://gr;

	# create new action
	my $code = $parser{$asm};
	my $action_nr;
	if (defined $actions{$code}) {
		$action_nr = $actions{$code};
		$actions[$action_nr]{current} .= " | ".$current;
	}
	else {
		$action_nr = scalar(@actions);
		push @actions, {code=>$code, current=>$current};
		$actions{$code} = $action_nr;
	}

	# create tree branch
	my $t = $tree;
	my @current;
	for my $i (0..$#asm) {
		my $token = $asm[$i];
		push @current, $token =~ s/^\w+:://r;
		if (!$t->{next}{$token}) {
			if ($i == $#asm) {
				$t->{next}{$token} = {action=>$action_nr, next=>{}, current=>"@current"};
			}
			else {
				my $state = scalar(@states);
				$t->{next}{$token} = {state=>$state, next=>{}, current=>"@current"};
				push @states, $t->{next}{$token};
			}
		}
		$t = $t->{next}{$token};
	}
}

my $nr_states = scalar(@states);

# dump state machine
open(my $fh, ">", $output_file) or die "open $output_file: $!";
my $function = ($output_file =~ s/\.\w+$//r);

say $fh <<END;
// generated by $0
#include "args.h"
#include "asm.h"
#include "errors.h"
#include "expr.h"
#include "if.h"
#include "parse.h"
#include "utils.h"
#include <memory>
#include <cinttypes>
using namespace std;
END

# dump state-keyword transition table
print $fh <<END;
static const int16_t state_keyword_tt[$nr_states][$nr_keywords] = {
END
for my $state (@states) {
	dump_state_keyword($fh, $state);
}
say $fh <<END;
};
END

# dump state-token transition table
print $fh <<END;
static const int16_t state_token_tt[$nr_states][$nr_tokens] = {
END
for my $state (@states) {
	dump_state_token($fh, $state);
}
say $fh <<END;
};
END

# dump state-expressions table
print $fh <<END;
static const struct { int16_t expr_type, next; } state_expr[$nr_states] = {
END
for my $state (@states) {
	dump_state_expr($fh, $state);
}
say $fh <<END;
};
END

# dump function
print $fh <<END;
void Parser::$function() {
	int state = 0;
	int next, expr_type;
	shared_ptr<Expr> expr;

	while (true) {
		Assert(state >= 0 && state < $nr_states);

		// check keyword
		int keyword_nr = static_cast<int>(m_lexer.peek().keyword);
		Assert(keyword_nr >= 0 && keyword_nr < $nr_keywords);
		next = state_keyword_tt[state][keyword_nr];
		if (next < 0) {
			m_lexer.next();
			${function}_action(-next);
			return;
		}
		else if (next > 0) {
			m_lexer.next();
			state = next;
			continue;
		}

		// check token
		int token_nr = static_cast<int>(m_lexer.peek().ttype);
		Assert(token_nr >= 0 && token_nr < $nr_tokens);
		next = state_token_tt[state][token_nr];
		if (next < 0) {
			m_lexer.next();
			${function}_action(-next);
			return;
		}
		else if (next > 0) {
			m_lexer.next();
			state = next;
			continue;
		}

		// check expression
		expr_type = state_expr[state].expr_type;
		next = state_expr[state].next;
		switch (expr_type) {
		case 0:		// no expression
			break;
		case 1:		// expression
			expr = make_shared<Expr>(m_lexer); 
			if (expr->parse()) {
				m_exprs.push_back(expr);
				if (next < 0) {
					${function}_action(-next);
					return;
				}
				else if (next > 0) {
					state = next;
					continue;
				}
			}
			break;
		case 2:		// const expression
			expr = make_shared<Expr>(m_lexer); 
			if (expr->parse()) {
				if (expr->eval_silent(0) && expr->is_const()) {
					m_exprs.push_back(expr);
					if (next < 0) {
						${function}_action(-next);
						return;
					}
					else if (next > 0) {
						state = next;
						continue;
					}
				}
				else {
					g_errors.error(ErrCode::ConstExprExpected);
					return;
				}
			}
			break;
		default:
			Assert(0);
			return;	// not reached
		}

		// no valid transition from this state
		g_errors.error(ErrCode::Syntax);
		return;
	}
}

void Parser::${function}_action(int action) {
	switch (action) {
END

# dump actions
for my $action_nr (1..$#actions) {
	my $comment = $actions[$action_nr]{current};
	my $code = $actions[$action_nr]{code};
	$code =~ s/\s+$//s;
	$code =~ s/^/\t\t/gm;
	print $fh <<END;
	case $action_nr:	// $comment
$code
		return;
END
}

say $fh <<END;
	default: 
		Assert(0);
		return; // not reached
	}
}
END

# dump one state-keyword transition row:
# 0 for invalid transition
# >0 to jump to state n
# <0 to jump to action -n
sub dump_state_keyword {
	my($fh, $tree) = @_;
	my @row = (0) x $nr_keywords;

	if ($tree->{next}) {
		for my $token (keys %{$tree->{next}}) {
			if ($token =~ /^Keyword::/) {
				if (exists $tree->{next}{$token}{action}) {
					$row[$keywords{$token}] = - $tree->{next}{$token}{action};
				}
				else {
					$row[$keywords{$token}] = $tree->{next}{$token}{state};
				}
			}
		}
	}

	say $fh "\t{", join(",", @row), "},";
}

# dump one state-token transition row:
sub dump_state_token {
	my($fh, $tree) = @_;
	my @row = (0) x $nr_tokens;

	if ($tree->{next}) {
		for my $token (keys %{$tree->{next}}) {
			if ($token =~ /^TType::/) {
				my $next;
				if (exists $tree->{next}{$token}{action}) {
					$next = - $tree->{next}{$token}{action};
				}
				else {
					$next = $tree->{next}{$token}{state};
				}
				if ($token =~ /^TType::End/) {
					$row[$tokens{'TType::End'}] = $next;
					$row[$tokens{'TType::Newline'}] = $next;
				}
				else {
					$row[$tokens{$token}] = $next;
				}
			}
		}
	}

	say $fh "\t{", join(",", @row), "},";
}

# dump type of expression at each state
sub dump_state_expr {
	my($fh, $tree) = @_;
	my $type = 0;
	my $next = 0;

	if ($tree->{next}) {
		if (defined $tree->{next}{expr}) {
			$type = 1;
			if (exists $tree->{next}{expr}{action}) {
				$next = - $tree->{next}{expr}{action};
			}
			else {
				$next = $tree->{next}{expr}{state};
			}
		}
		elsif (defined $tree->{next}{const_expr}) {
			$type = 2;
			if (exists $tree->{next}{const_expr}{action}) {
				$next = - $tree->{next}{const_expr}{action};
			}
			else {
				$next = $tree->{next}{const_expr}{state};
			}
		}
	}

	say $fh "\t{", join(",", $type, $next), "},";
}

# read %keywords
sub read_keywords {
	my($file) = @_;
	my $keyword_id = 0;
	my %keywords;

	open(my $fh, "<", $file) or die "open $file: $!";
	while (<$fh>) {
		if (/^ \s* X\( \s* (\w+) \s* , /x) {
			my $keyword = "Keyword::$1";
			$keywords{$keyword} = $keyword_id++;
		}
	}
	return %keywords;
}

# read %tokens
sub read_tokens {
	my($file) = @_;
	my $token_id = 0;
	my %tokens;

	open(my $fh, "<", $file) or die "open $file: $!";
	local $/;
	my $text = <$fh>;
	$text =~ /\b enum \s+ class \s+ TType \s+ \{ 
		         ([^}]+) \} /x or die "TType not found in $file";
	my $list = $1;
	$list =~ s/\s+//g;
	for my $token (split /,/, $list) {
		$tokens{"TType::$token"} = $token_id++;
	}
	return %tokens;
}