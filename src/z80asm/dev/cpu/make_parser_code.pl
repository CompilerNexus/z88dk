#!/usr/bin/env perl

#------------------------------------------------------------------------------
# Generate state machine to parse input parser rules
#------------------------------------------------------------------------------

use Modern::Perl;
use YAML::Tiny;

@ARGV==2 or die "Usage: $0 input_parser.yaml output_file.def\n";
my($input_file, $output_file) = @ARGV;

my $yaml = YAML::Tiny->read($input_file);
my %parser = %{$yaml->[0]};

my $tree = { state=>0, next=>{}, current=>"top" };
my @states = ($tree);
my @actions;
my %actions;

for my $tokens (sort keys %parser) {
	my @tokens = split(' ', $tokens);
	my $current = $tokens =~ s/\b\w+:://gr;

	# create new action
	my $code = $parser{$tokens};
	my $action_nr;
	if (defined $actions{$code}) {
		$action_nr = $actions{$code};
		$actions[$action_nr]{current} .= " | ".$current;
	}
	else {
		$action_nr = scalar(@actions);
		push @actions, {code=>$code, current=>$current};
		$actions{$code} = $action_nr;
	}

	# create tree branch
	my $t = $tree;
	my @current;
	for my $i (0..$#tokens) {
		my $token = $tokens[$i];
		push @current, $token =~ s/^\w+:://r;
		if (!$t->{next}{$token}) {
			if ($i == $#tokens) {
				$t->{next}{$token} = {action=>$action_nr, next=>{}, current=>"@current"};
			}
			else {
				my $state = scalar(@states);
				$t->{next}{$token} = {state=>$state, next=>{}, current=>"@current"};
				push @states, $t->{next}{$token};
			}
		}
		$t = $t->{next}{$token};
	}
}

# dump state machine
open(my $fh, ">", $output_file) or die "open $output_file: $!";
my $function = ($output_file =~ s/\.\w+$//r);

say $fh <<END;
// generated by $0
#include "asm.h"
#include "errors.h"
#include "if.h"

using namespace std;
void Asm::$function() {
END

for my $state (@states) {
	dump_state($fh, $state);
}

for my $action_nr (0..$#actions) {
	say $fh "// action for: ", $actions[$action_nr]{current};
	say $fh "action_$action_nr:";
	say $fh $actions[$action_nr]{code} =~ s/\s+$//sr;
	say $fh "return;\n";
}

say $fh "}";

# dump one state
sub dump_state {
	my($fh, $tree) = @_;

	if ($tree->{state} > 0) {
		say $fh "// state: ", $tree->{current};
		say $fh "state_", $tree->{state},":";
	}

	if ($tree->{next}) {
		# check keywords
		my $have_keywords;
		for my $token (keys %{$tree->{next}}) {
			if ($token =~ /^Keyword::/) {
				$have_keywords = 1;
				last;
			}
		}
		if ($have_keywords) {
			say $fh "\t// check keywords";
			say $fh "\tswitch (m_lexer.peek().keyword) {";
			for my $token (sort keys %{$tree->{next}}) {
				if ($token =~ /^Keyword::/) {
					my $target = (exists $tree->{next}{$token}{action}) ? 
									"action_".$tree->{next}{$token}{action} :
									"state_".$tree->{next}{$token}{state};
					say $fh "\tcase $token: m_lexer.next(); goto $target;";
				}
			}
			say $fh "\tdefault:;";
			say $fh "\t}\n";
		}

		# check tokens
		my $have_tokens;
		for my $token (keys %{$tree->{next}}) {
			if ($token =~ /^TType::/) {
				$have_tokens = 1;
				last;
			}
		}
		if ($have_tokens) {
			say $fh "\t// check tokens";
			say $fh "\tswitch (m_lexer.peek().ttype) {";
			for my $token (sort keys %{$tree->{next}}) {
				if ($token =~ /^TType::/) {
					my $target = (exists $tree->{next}{$token}{action}) ? 
									"action_".$tree->{next}{$token}{action} :
									"state_".$tree->{next}{$token}{state};
					if ($token =~ /^TType::End/) {
						say $fh "\tcase TType::End: goto $target;";
						say $fh "\tcase TType::Backslash: m_lexer.next(); goto $target;";
					}
					else {
						say $fh "\tcase $token: m_lexer.next(); goto $target;";
					}
				}
			}
			say $fh "\tdefault:;";
			say $fh "\t}\n";
		}

		# check expressions
		if (defined $tree->{next}{expr}) {
			my $target = (exists $tree->{next}{expr}{action}) ? 
							"action_".$tree->{next}{expr}{action} :
							"state_".$tree->{next}{expr}{state};
			say $fh "\t// check expression";
			say $fh "\t/*if (check_expr())*/ goto $target;";
		}
		if (defined $tree->{next}{const_expr}) {
			my $target = (exists $tree->{next}{const_expr}{action}) ? 
							"action_".$tree->{next}{const_expr}{action} :
							"state_".$tree->{next}{const_expr}{state};
			say $fh "\t// check expression";
			say $fh "\t/*if (check_const_expr())*/ goto $target;";
		}
	}

	say $fh "\tg_errors.error(ErrCode::Syntax);";
	say $fh "\treturn;";
	say $fh "";
}
