#!/usr/bin/env perl

#------------------------------------------------------------------------------
# Generate state machine to parse input parser rules
#------------------------------------------------------------------------------

use Modern::Perl;
use YAML::Tiny;
use Data::Dumper;
$Data::Dumper::Indent = 1;

@ARGV==2 or die "Usage: $0 input_parser.yaml output_file.cpp\n";
my($input_file, $output_file) = @ARGV;

my $output_aux_file_header = $output_file =~ s/\.\w+$/_action.h/r;
my $output_aux_file_source = $output_file =~ s/\.\w+$/_action.cpp/r;
my $tables_file = $output_file =~ s/\.\w+$/_tables.h/r;


my $yaml = YAML::Tiny->read($input_file);
my %parser = %{$yaml->[0]};

my $tree = { state=>0, next=>{}, current=>"top" };
my @states = ($tree);
my @actions = ('');		# actions start at 1
my @state_comment = ('');
my %actions;

# read keywords from source
my %keywords = read_keywords("../../src/cpp/keyword.def");
my $nr_keywords = scalar(keys %keywords);

# read tokens from source
my %tokens = read_tokens("../../src/cpp/scan.def");
my $nr_tokens = scalar(keys %tokens);

# convert parser data into trie tree
for my $asm (sort keys %parser) {
	my @asm = split(' ', $asm);
	my $current = $asm =~ s/\b\w+:://gr;

	# create new action
	my $code = $parser{$asm};
	my $action_nr;
	if (defined $actions{$code}) {
		$action_nr = $actions{$code};
		$actions[$action_nr]{current} .= " | ".$current;
	}
	else {
		$action_nr = scalar(@actions);
		push @actions, {code=>$code, current=>$current};
		$actions{$code} = $action_nr;
	}

	# create tree branch
	my $t = $tree;
	my @current;
	for my $i (0..$#asm) {
		my $token = $asm[$i];
		push @current, $token =~ s/^\w+:://r;
		if (!$t->{next}{$token}) {
			my $state = scalar(@states);

			$t->{next}{$token}{next} ||= {};
			$t->{next}{$token}{current} = "@current";
			if ($i == $#asm) {
				$t->{next}{$token}{action} = $action_nr;
				$state_comment[$state] = "@current --> action $action_nr";
			}
			else {
				$t->{next}{$token}{state} = $state;
				$state_comment[$state] = "@current";
			}

			push @states, $t->{next}{$token};
		}		
		$t = $t->{next}{$token};
	}
}

my $nr_states = scalar(@states);
my $nr_actions = scalar(@actions);

# dump state machine tables file
open(my $fh, ">", $tables_file) or die "open $tables_file: $!";
say $fh <<END;
// generated by $0
#pragma once
END

# dump states
say $fh "/*";
for my $state (1..$#state_comment) {
	say $fh "    state $state: $state_comment[$state]";
}
say $fh "*/";
say $fh "";

if ($ENV{DEBUG}) {
	say $fh "/*";
	say $fh Data::Dumper::Dumper($tree);
	say $fh "*/";
	say $fh "";
}

# dump state-keyword transition table
print $fh <<END;
static const int state_keyword_tt[$nr_states][$nr_keywords] = {
END
for my $state (@states) {
	my @row = (0) x $nr_keywords;
	if ($state->{next}) {
		for my $token (keys %{$state->{next}}) {
			if ($token =~ /^Keyword::/) {
				defined $keywords{$token} or die "Keyword $token not found\n";
				my $id = $keywords{$token};
				$row[$id] = $state->{next}{$token}{state} // 0;
			}
		}
	}
	say $fh output_colapsed_row(@row);
}
say $fh <<END;
};
END

# dump state-keyword actions
print $fh <<END;
static const int state_keyword_action[$nr_states][$nr_keywords] = {
END
for my $state (@states) {
	my @row = (0) x $nr_keywords;
	if ($state->{next}) {
		for my $token (keys %{$state->{next}}) {
			if ($token =~ /^Keyword::/) {
				defined $keywords{$token} or die "Keyword $token not found\n";
				my $id = $keywords{$token};
				$row[$id] = $state->{next}{$token}{action} // 0;
			}
		}
	}
	say $fh output_colapsed_row(@row);
}
say $fh <<END;
};
END

# dump state-token transition table
print $fh <<END;
static const int state_token_tt[$nr_states][$nr_tokens] = {
END
for my $state (@states) {
	my @row = (0) x $nr_tokens;
	if ($state->{next}) {
		for my $token (keys %{$state->{next}}) {
			if ($token =~ /^TType::/) {
				my $next = $state->{next}{$token}{state} // 0;
				defined $tokens{$token} or die "Token $token not found\n";
				my $id = $tokens{$token};
				if ($token =~ /^TType::End/) {
					$row[$tokens{'TType::End'}] = $next;
					$row[$tokens{'TType::Newline'}] = $next;
				}
				else {
					$row[$id] = $next;
				}
			}
		}
	}
	say $fh output_colapsed_row(@row);
}
say $fh <<END;
};
END

# dump state-token actions
print $fh <<END;
static const int state_token_action[$nr_states][$nr_tokens] = {
END
for my $state (@states) {
	my @row = (0) x $nr_tokens;
	if ($state->{next}) {
		for my $token (keys %{$state->{next}}) {
			if ($token =~ /^TType::/) {
				my $action = $state->{next}{$token}{action} // 0;
				defined $tokens{$token} or die "Token $token not found\n";
				my $id = $tokens{$token};
				if ($token =~ /^TType::End/) {
					$row[$tokens{'TType::End'}] = $action;
					$row[$tokens{'TType::Newline'}] = $action;
				}
				else {
					$row[$id] = $action;
				}
			}
		}
	}
	say $fh output_colapsed_row(@row);
}
say $fh <<END;
};
END

# dump state-expressions table
print $fh <<END;
static const struct { int expr_type; int next; } state_expr_tt[$nr_states] = {
END
for my $state (@states) {
	my @row = (0,0);
	if ($state->{next}) {
		if (defined $state->{next}{expr}) {
			$state->{next}{expr}{action} and die;
			@row = (1, $state->{next}{expr}{state} // 0);
		}
		elsif (defined $state->{next}{const_expr}) {
			$state->{next}{const_expr}{action} and die;
			@row = (2, $state->{next}{const_expr}{state} // 0);
		}
	}
	say $fh output_row(@row);
}
say $fh <<END;
};
END

# dump state machine source files
open(my $outfh, ">", $output_file) or die "open $output_file: $!";
my $function = ($output_file =~ s/\.\w+$//r);

open(my $hfh, ">", $output_aux_file_header) or die "open $output_aux_file_header: $!";
open(my $cppfh, ">", $output_aux_file_source) or die "open $output_aux_file_source: $!";

my $aux_func_name = $output_file =~ s/\..*/_action_/r;

say $outfh <<END;
// generated by $0
#include "$tables_file"
#include "args.h"
#include "asm.h"
#include "parse.h"
#include "xassert.h"

struct parse_state {
	int state{0};
	int next{0};
	unsigned pos{0};
	vector<int> expr_pos;
	vector<int> expr_type;
	
	parse_state(int _state, int _next, unsigned _pos) 
		: state(_state), next(_next), pos(_pos) {}
};

END

# dump function
print $outfh <<END;
void Parser::$function() {
	deque<parse_state> states{{parse_state{0, 0, m_line.pos()}}};
	deque<parse_state> new_states;

	int num_not_ended = 0;
	do {		
		new_states.clear();
		
		while (!states.empty()) {
			parse_state st = states.front();
			states.pop_front();
			xassert(st.state > -$nr_actions && st.state < $nr_states);
			
			if (st.state < 0) {
				new_states.push_back(st);
			}
			else {
				m_line.set_pos(st.pos);
				const Token& token = m_line.peek();
				if (token.type() != TType::End)
					m_line.next();
				st.pos = m_line.pos();
				
				// try keyword
				int keyword_nr = static_cast<int>(token.keyword());
				xassert(keyword_nr >= 0 && keyword_nr < $nr_keywords);
				st.next = -state_keyword_action[st.state][keyword_nr];
				if (st.next != 0) 
					new_states.push_back(st);
				st.next = state_keyword_tt[st.state][keyword_nr];
				if (st.next != 0) 
					new_states.push_back(st);

				// try token
				int token_nr = static_cast<int>(token.type());
				xassert(token_nr >= 0 && token_nr < $nr_tokens);
				st.next = -state_token_action[st.state][token_nr];
				if (st.next != 0) 
					new_states.push_back(st);
				st.next = state_token_tt[st.state][token_nr];
				if (st.next != 0) 
					new_states.push_back(st);

				// try expression
				int expr_type = state_expr_tt[st.state].expr_type;
				if (expr_type != 0) {
					auto expr = make_shared<Expr>(); 
					m_line.next(-1);		// go back to start of expr
					unsigned pos = m_line.pos();
					if (expr->can_parse(m_line)) {
						st.next = state_expr_tt[st.state].next;
						if (st.next != 0) {
							// save to evaluate later
							st.expr_pos.push_back(pos);		
							st.expr_type.push_back(expr_type);
							
							st.pos = m_line.pos();
							new_states.push_back(st);
						}
					}
					else {
						m_line.next(1);
					}
				}
			}
		}
			
		// check if we finished
		states.clear();
		num_not_ended = 0;
		for (auto& st : new_states) {
			st.state = st.next;
			if (st.state >= 0)
				num_not_ended++;
			states.push_back(st);
		}
	} while (num_not_ended > 0);
	
	if (states.empty()) {
		// no valid transition from this state
		error_syntax();
	}
	else {
		// get define longest statement
		parse_state longest = states.front();
		for (auto& st : states) {
			if (longest.pos > st.pos)
				longest = st;
		}

		// parse and collect all expressions
		m_exprs.clear();
		m_const_exprs.clear();
		for (size_t i = 0; i < longest.expr_pos.size(); i++) {
			m_line.set_pos(longest.expr_pos[i]);
			auto expr = make_shared<Expr>(); 
			xassert(expr->parse(m_line));
			m_exprs.push_back(expr);
			if (longest.expr_type[i] == 2) {
				ExprResult r = expr->eval_noisy();
				if (!r.is_const()) {
					m_line.set_pos(longest.expr_pos[i]);
					g_errors.error(ErrCode::ConstExprExpected, m_line.peek_text());
					return;
				}
				else {
					m_const_exprs.push_back(r.value());
				}
			}
		}

		// jump to longest
		m_line.set_pos(longest.pos);

		// execute action
		${function}_action(-longest.state);
	}
}

END

# dump parser functions
print $outfh <<END;
void Parser::${function}_action(int action) {
	switch (action) {
END

say $hfh <<END;
// generated by $0
#pragma once
END

say $cppfh <<END;
// generated by $0
#include "args.h"
#include "asm.h"
#include "icode.h"
#include "parse.h"
#include "xassert.h"
END

# dump actions
for my $action_nr (1..$#actions) {
	my $comment = $actions[$action_nr]{current};
	my $code = $actions[$action_nr]{code};
	$code =~ s/\s+$//s;
	$code =~ s/^/\t/gm;
	
	print $hfh <<END;
void ${function}_action_${action_nr}();		// $comment
END

	say $cppfh <<END;
// $comment
void Parser::${function}_action_${action_nr}() {
$code
}
END

	print $outfh <<END;
	case $action_nr: ${function}_action_${action_nr}(); return;
END

}

say $outfh <<END;
	default: 
		xassert(0);
		return; // not reached
	}
}
END

#------------------------------------------------------------------------------

sub output_row {
	my(@row) = @_;
	return "    {".join(",", @row)."},";
}

sub output_colapsed_row {
	my(@row) = @_;
	return output_row(remove_end_zeros(@row));
}

sub remove_end_zeros {
	my(@row) = @_;
	while (@row > 1 && $row[-1] == 0) {
		pop @row;
	}
	return @row;
}

# read %keywords
sub read_keywords {
	my($file) = @_;
	my $keyword_id = 0;
	my %keywords;

	open(my $fh, "<", $file) or die "open $file: $!";
	while (<$fh>) {
		if (/^ \s* X\( \s* (\w+) \s* , /x) {
			my $keyword = "Keyword::$1";
			$keywords{$keyword} = $keyword_id++;
		}
	}
	return %keywords;
}

# read %tokens
sub read_tokens {
	my($file) = @_;
	my $token_id = 0;
	my %tokens;

	open(my $fh, "<", $file) or die "open $file: $!";
	while (<$fh>) {
		if (/^ \s* X\( \s* (\w+) \s* , /x) {
			my $token = "TType::$1";
			$tokens{$token} = $token_id++;
		}
	}
	return %tokens;
}
