//-----------------------------------------------------------------------------
// z80asm
// parser
// Copyright (C) Paulo Custodio, 2011-2022
// License: The Artistic License 2.0, http://www.perlfoundation.org/artistic_license_2_0
//-----------------------------------------------------------------------------

#pragma once

#include "expr.h"
#include "scan.h"
#include "symtab.h"
#include "utils.h"
#include <deque>
using namespace std;

class Asm;
class Expr;

class Parser {
public:
	void clear();
	void parse();		// parse lines from g_preproc

private:
    // generated by make_parser_code.pl
#include "parse_main.h"
#include "parse_main_action.h"

    enum class State { Main };

	ScannedLine m_line;						// line being parsed
	State	m_state{ State::Main };			// parser state
    deque<shared_ptr<Expr>> m_exprs;		// parsed expressions
    deque<int> m_const_exprs;               // evaluated constant expressions
    unsigned m_start_stmt{ 0 };             // position of start of line
    int m_start_state{ START_STATE_MAIN };  // start state on each new interaction

    int start_stmt_index() const { return m_start_stmt - m_line.pos(); }

    void error(ErrCode code);
    void error(ErrCode code, const string& arg);
    void parse_line(int start_state = START_STATE_MAIN);
    void parse_line_main(int start_state);
    void check_eol();
    bool parse_label();
    void parse_int8_data();
    void parse_int16_data();
    void parse_int16be_data();
    void parse_int24_data();
    void parse_int32_data();
    void do_defs_n();
    void do_defs_n_n();
    void do_defs_n_str(const string& filler);
    void do_equ(const string& name, shared_ptr<Expr> expr);

	bool expr_in_parens();

    void add_label(const string& name);
    void add_opcode(unsigned bytes);
    void add_opcode_n(unsigned bytes);
    void add_opcode_s(unsigned bytes);
    void add_opcode_h(unsigned bytes);
    void add_opcode_n_0(unsigned bytes);
    void add_opcode_s_0(unsigned bytes);
    void add_opcode_nn(unsigned bytes, int target_offset = 0);
    void add_opcode_nnn(unsigned bytes, int target_offset = 0);
    void add_opcode_nnnn(unsigned bytes, int target_offset = 0);
    void add_opcode_NN(unsigned bytes);
    void add_opcode_idx(unsigned bytes);
    void add_opcode_idx_idx1(unsigned bytes0, unsigned bytes1);
    void add_opcode_idx_n(unsigned bytes);
    void add_opcode_n_n(unsigned bytes);
    void add_opcode_defb();

	void add_emul_call_flag(unsigned bytes_jump, unsigned bytes_call);
	void add_call_function(const string& function_name);
	void add_jump_relative(unsigned bytes);
	void add_jump_relative16(unsigned bytes);
	void add_z80n_mmu_n();
	void add_z80n_mmu_a();
	void add_restart();

    void warn_if_expr_in_parens();
    void error_expr_not_in_parens();
};
