// generated by make_parser_code.pl
#include "assm.h"
#include "errors.h"
#include "expr.h"
#include "if.h"
#include "symtab.h"
using namespace std;

bool Assm::asm_parse_main() {

	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::ACI: m_lexer.next(); goto state_1;
	case Keyword::ADC: m_lexer.next(); goto state_3;
	case Keyword::ADD: m_lexer.next(); goto state_97;
	case Keyword::ADI: m_lexer.next(); goto state_216;
	case Keyword::ALTD: m_lexer.next(); goto state_224;
	case Keyword::ANA: m_lexer.next(); goto state_2305;
	case Keyword::AND: m_lexer.next(); goto state_2314;
	case Keyword::ANI: m_lexer.next(); goto state_2407;
	case Keyword::ARHL: m_lexer.next(); goto state_2409;
	case Keyword::BIT: m_lexer.next(); goto state_2410;
	case Keyword::BOOL: m_lexer.next(); goto state_2431;
	case Keyword::BRLC: m_lexer.next(); goto state_2436;
	case Keyword::BSLA: m_lexer.next(); goto state_2440;
	case Keyword::BSRA: m_lexer.next(); goto state_2444;
	case Keyword::BSRF: m_lexer.next(); goto state_2448;
	case Keyword::BSRL: m_lexer.next(); goto state_2452;
	case Keyword::CALL: m_lexer.next(); goto state_2456;
	case Keyword::CC: m_lexer.next(); goto state_2494;
	case Keyword::CCF: m_lexer.next(); goto state_2496;
	case Keyword::CCF1: m_lexer.next(); goto state_2497;
	case Keyword::CLO: m_lexer.next(); goto state_2498;
	case Keyword::CLZ: m_lexer.next(); goto state_2500;
	case Keyword::CM: m_lexer.next(); goto state_2502;
	case Keyword::CMA: m_lexer.next(); goto state_2504;
	case Keyword::CMC: m_lexer.next(); goto state_2505;
	case Keyword::CMP: m_lexer.next(); goto state_2506;
	case Keyword::CNC: m_lexer.next(); goto state_2563;
	case Keyword::CNV: m_lexer.next(); goto state_2565;
	case Keyword::CNZ: m_lexer.next(); goto state_2567;
	case Keyword::CP: m_lexer.next(); goto state_2569;
	case Keyword::CPD: m_lexer.next(); goto state_2625;
	case Keyword::CPDR: m_lexer.next(); goto state_2626;
	case Keyword::CPE: m_lexer.next(); goto state_2627;
	case Keyword::CPI: m_lexer.next(); goto state_2629;
	case Keyword::CPIR: m_lexer.next(); goto state_2631;
	case Keyword::CPL: m_lexer.next(); goto state_2632;
	case Keyword::CPO: m_lexer.next(); goto state_2635;
	case Keyword::CV: m_lexer.next(); goto state_2637;
	case Keyword::CZ: m_lexer.next(); goto state_2639;
	case Keyword::C_C: m_lexer.next(); goto state_2641;
	case Keyword::C_LO: m_lexer.next(); goto state_2643;
	case Keyword::C_LZ: m_lexer.next(); goto state_2645;
	case Keyword::C_M: m_lexer.next(); goto state_2647;
	case Keyword::C_NC: m_lexer.next(); goto state_2649;
	case Keyword::C_NV: m_lexer.next(); goto state_2651;
	case Keyword::C_NZ: m_lexer.next(); goto state_2653;
	case Keyword::C_P: m_lexer.next(); goto state_2655;
	case Keyword::C_PE: m_lexer.next(); goto state_2657;
	case Keyword::C_PO: m_lexer.next(); goto state_2659;
	case Keyword::C_V: m_lexer.next(); goto state_2661;
	case Keyword::C_Z: m_lexer.next(); goto state_2663;
	case Keyword::DAA: m_lexer.next(); goto state_2665;
	case Keyword::DAD: m_lexer.next(); goto state_2666;
	case Keyword::DCR: m_lexer.next(); goto state_2674;
	case Keyword::DCX: m_lexer.next(); goto state_2683;
	case Keyword::DEC: m_lexer.next(); goto state_2691;
	case Keyword::DI: m_lexer.next(); goto state_2734;
	case Keyword::DJNZ: m_lexer.next(); goto state_2735;
	case Keyword::DSUB: m_lexer.next(); goto state_2743;
	case Keyword::EI: m_lexer.next(); goto state_2744;
	case Keyword::EX: m_lexer.next(); goto state_2745;
	case Keyword::EXTERN: m_lexer.next(); goto action_958;
	case Keyword::EXX: m_lexer.next(); goto state_2766;
	case Keyword::GLOBAL: m_lexer.next(); goto action_958;
	case Keyword::HALT: m_lexer.next(); goto state_2767;
	case Keyword::HLT: m_lexer.next(); goto state_2768;
	case Keyword::IDET: m_lexer.next(); goto state_2769;
	case Keyword::IM: m_lexer.next(); goto state_2770;
	case Keyword::IN: m_lexer.next(); goto state_2772;
	case Keyword::IN0: m_lexer.next(); goto state_2818;
	case Keyword::INC: m_lexer.next(); goto state_2844;
	case Keyword::IND: m_lexer.next(); goto state_2887;
	case Keyword::INDR: m_lexer.next(); goto state_2888;
	case Keyword::INI: m_lexer.next(); goto state_2889;
	case Keyword::INIR: m_lexer.next(); goto state_2890;
	case Keyword::INR: m_lexer.next(); goto state_2891;
	case Keyword::INX: m_lexer.next(); goto state_2900;
	case Keyword::IOE: m_lexer.next(); goto state_2908;
	case Keyword::IOI: m_lexer.next(); goto state_4703;
	case Keyword::IPRES: m_lexer.next(); goto state_6498;
	case Keyword::IPSET: m_lexer.next(); goto state_6499;
	case Keyword::JC: m_lexer.next(); goto state_6501;
	case Keyword::JK: m_lexer.next(); goto state_6503;
	case Keyword::JLO: m_lexer.next(); goto state_6505;
	case Keyword::JLZ: m_lexer.next(); goto state_6507;
	case Keyword::JM: m_lexer.next(); goto state_6509;
	case Keyword::JMP: m_lexer.next(); goto state_6511;
	case Keyword::JNC: m_lexer.next(); goto state_6513;
	case Keyword::JNK: m_lexer.next(); goto state_6515;
	case Keyword::JNV: m_lexer.next(); goto state_6517;
	case Keyword::JNX5: m_lexer.next(); goto state_6519;
	case Keyword::JNZ: m_lexer.next(); goto state_6521;
	case Keyword::JP: m_lexer.next(); goto state_6523;
	case Keyword::JPE: m_lexer.next(); goto state_6586;
	case Keyword::JPO: m_lexer.next(); goto state_6588;
	case Keyword::JR: m_lexer.next(); goto state_6590;
	case Keyword::JV: m_lexer.next(); goto state_6604;
	case Keyword::JX5: m_lexer.next(); goto state_6606;
	case Keyword::JZ: m_lexer.next(); goto state_6608;
	case Keyword::J_C: m_lexer.next(); goto state_6610;
	case Keyword::J_LO: m_lexer.next(); goto state_6612;
	case Keyword::J_LZ: m_lexer.next(); goto state_6614;
	case Keyword::J_M: m_lexer.next(); goto state_6616;
	case Keyword::J_NC: m_lexer.next(); goto state_6618;
	case Keyword::J_NV: m_lexer.next(); goto state_6620;
	case Keyword::J_NZ: m_lexer.next(); goto state_6622;
	case Keyword::J_P: m_lexer.next(); goto state_6624;
	case Keyword::J_PE: m_lexer.next(); goto state_6626;
	case Keyword::J_PO: m_lexer.next(); goto state_6628;
	case Keyword::J_V: m_lexer.next(); goto state_6630;
	case Keyword::J_Z: m_lexer.next(); goto state_6632;
	case Keyword::LD: m_lexer.next(); goto state_6634;
	case Keyword::LDA: m_lexer.next(); goto state_7477;
	case Keyword::LDAX: m_lexer.next(); goto state_7479;
	case Keyword::LDD: m_lexer.next(); goto state_7484;
	case Keyword::LDDR: m_lexer.next(); goto state_7563;
	case Keyword::LDDRX: m_lexer.next(); goto state_7564;
	case Keyword::LDDSR: m_lexer.next(); goto state_7565;
	case Keyword::LDDX: m_lexer.next(); goto state_7566;
	case Keyword::LDH: m_lexer.next(); goto state_7567;
	case Keyword::LDHI: m_lexer.next(); goto state_7582;
	case Keyword::LDHL: m_lexer.next(); goto state_7584;
	case Keyword::LDI: m_lexer.next(); goto state_7588;
	case Keyword::LDIR: m_lexer.next(); goto state_7669;
	case Keyword::LDIRX: m_lexer.next(); goto state_7670;
	case Keyword::LDISR: m_lexer.next(); goto state_7671;
	case Keyword::LDIX: m_lexer.next(); goto state_7672;
	case Keyword::LDP: m_lexer.next(); goto state_7673;
	case Keyword::LDPIRX: m_lexer.next(); goto state_7708;
	case Keyword::LDRX: m_lexer.next(); goto state_7709;
	case Keyword::LDSI: m_lexer.next(); goto state_7710;
	case Keyword::LDWS: m_lexer.next(); goto state_7712;
	case Keyword::LHLD: m_lexer.next(); goto state_7713;
	case Keyword::LHLDE: m_lexer.next(); goto state_7715;
	case Keyword::LHLX: m_lexer.next(); goto state_7716;
	case Keyword::LIRX: m_lexer.next(); goto state_7717;
	case Keyword::LPRX: m_lexer.next(); goto state_7718;
	case Keyword::LSDDR: m_lexer.next(); goto state_7719;
	case Keyword::LSDR: m_lexer.next(); goto state_7720;
	case Keyword::LSIDR: m_lexer.next(); goto state_7721;
	case Keyword::LSIR: m_lexer.next(); goto state_7722;
	case Keyword::LXI: m_lexer.next(); goto state_7723;
	case Keyword::MIRR: m_lexer.next(); goto state_7745;
	case Keyword::MIRROR: m_lexer.next(); goto state_7747;
	case Keyword::MLT: m_lexer.next(); goto state_7749;
	case Keyword::MMU: m_lexer.next(); goto state_7754;
	case Keyword::MMU0: m_lexer.next(); goto state_7759;
	case Keyword::MMU1: m_lexer.next(); goto state_7762;
	case Keyword::MMU2: m_lexer.next(); goto state_7765;
	case Keyword::MMU3: m_lexer.next(); goto state_7768;
	case Keyword::MMU4: m_lexer.next(); goto state_7771;
	case Keyword::MMU5: m_lexer.next(); goto state_7774;
	case Keyword::MMU6: m_lexer.next(); goto state_7777;
	case Keyword::MMU7: m_lexer.next(); goto state_7780;
	case Keyword::MOV: m_lexer.next(); goto state_7783;
	case Keyword::MUL: m_lexer.next(); goto state_7863;
	case Keyword::MVI: m_lexer.next(); goto state_7868;
	case Keyword::NEG: m_lexer.next(); goto state_7893;
	case Keyword::NEXTREG: m_lexer.next(); goto state_7896;
	case Keyword::NOP: m_lexer.next(); goto state_7901;
	case Keyword::NREG: m_lexer.next(); goto state_7902;
	case Keyword::OR: m_lexer.next(); goto state_7907;
	case Keyword::ORA: m_lexer.next(); goto state_8000;
	case Keyword::ORG: m_lexer.next(); goto state_8009;
	case Keyword::ORI: m_lexer.next(); goto state_8011;
	case Keyword::OTDM: m_lexer.next(); goto state_8013;
	case Keyword::OTDMR: m_lexer.next(); goto state_8014;
	case Keyword::OTDR: m_lexer.next(); goto state_8015;
	case Keyword::OTIB: m_lexer.next(); goto state_8016;
	case Keyword::OTIM: m_lexer.next(); goto state_8017;
	case Keyword::OTIMR: m_lexer.next(); goto state_8018;
	case Keyword::OTIR: m_lexer.next(); goto state_8019;
	case Keyword::OUT: m_lexer.next(); goto state_8020;
	case Keyword::OUT0: m_lexer.next(); goto state_8037;
	case Keyword::OUTD: m_lexer.next(); goto state_8047;
	case Keyword::OUTI: m_lexer.next(); goto state_8048;
	case Keyword::OUTINB: m_lexer.next(); goto state_8049;
	case Keyword::OVRST8: m_lexer.next(); goto state_8050;
	case Keyword::PCHL: m_lexer.next(); goto state_8051;
	case Keyword::PIXELAD: m_lexer.next(); goto state_8052;
	case Keyword::PIXELDN: m_lexer.next(); goto state_8053;
	case Keyword::POP: m_lexer.next(); goto state_8054;
	case Keyword::PUBLIC: m_lexer.next(); goto action_958;
	case Keyword::PUSH: m_lexer.next(); goto state_8071;
	case Keyword::PXAD: m_lexer.next(); goto state_8085;
	case Keyword::PXDN: m_lexer.next(); goto state_8086;
	case Keyword::RAL: m_lexer.next(); goto state_8087;
	case Keyword::RAR: m_lexer.next(); goto state_8088;
	case Keyword::RC: m_lexer.next(); goto state_8089;
	case Keyword::RDEL: m_lexer.next(); goto state_8090;
	case Keyword::RDMODE: m_lexer.next(); goto state_8091;
	case Keyword::RES: m_lexer.next(); goto state_8092;
	case Keyword::RET: m_lexer.next(); goto state_8152;
	case Keyword::RETI: m_lexer.next(); goto state_8165;
	case Keyword::RETN: m_lexer.next(); goto state_8166;
	case Keyword::RIM: m_lexer.next(); goto state_8167;
	case Keyword::RL: m_lexer.next(); goto state_8168;
	case Keyword::RLA: m_lexer.next(); goto state_8230;
	case Keyword::RLA1: m_lexer.next(); goto state_8231;
	case Keyword::RLC: m_lexer.next(); goto state_8232;
	case Keyword::RLCA: m_lexer.next(); goto state_8290;
	case Keyword::RLCA1: m_lexer.next(); goto state_8291;
	case Keyword::RLD: m_lexer.next(); goto state_8292;
	case Keyword::RLDE: m_lexer.next(); goto state_8293;
	case Keyword::RLO: m_lexer.next(); goto state_8294;
	case Keyword::RLZ: m_lexer.next(); goto state_8295;
	case Keyword::RM: m_lexer.next(); goto state_8296;
	case Keyword::RNC: m_lexer.next(); goto state_8297;
	case Keyword::RNV: m_lexer.next(); goto state_8298;
	case Keyword::RNZ: m_lexer.next(); goto state_8299;
	case Keyword::RP: m_lexer.next(); goto state_8300;
	case Keyword::RPE: m_lexer.next(); goto state_8301;
	case Keyword::RPO: m_lexer.next(); goto state_8302;
	case Keyword::RR: m_lexer.next(); goto state_8303;
	case Keyword::RRA: m_lexer.next(); goto state_8368;
	case Keyword::RRA1: m_lexer.next(); goto state_8369;
	case Keyword::RRC: m_lexer.next(); goto state_8370;
	case Keyword::RRCA: m_lexer.next(); goto state_8428;
	case Keyword::RRCA1: m_lexer.next(); goto state_8429;
	case Keyword::RRD: m_lexer.next(); goto state_8430;
	case Keyword::RRHL: m_lexer.next(); goto state_8431;
	case Keyword::RST: m_lexer.next(); goto state_8432;
	case Keyword::RSTV: m_lexer.next(); goto state_8434;
	case Keyword::RV: m_lexer.next(); goto state_8435;
	case Keyword::RZ: m_lexer.next(); goto state_8436;
	case Keyword::R_C: m_lexer.next(); goto state_8437;
	case Keyword::R_LO: m_lexer.next(); goto state_8438;
	case Keyword::R_LZ: m_lexer.next(); goto state_8439;
	case Keyword::R_M: m_lexer.next(); goto state_8440;
	case Keyword::R_NC: m_lexer.next(); goto state_8441;
	case Keyword::R_NV: m_lexer.next(); goto state_8442;
	case Keyword::R_NZ: m_lexer.next(); goto state_8443;
	case Keyword::R_P: m_lexer.next(); goto state_8444;
	case Keyword::R_PE: m_lexer.next(); goto state_8445;
	case Keyword::R_PO: m_lexer.next(); goto state_8446;
	case Keyword::R_V: m_lexer.next(); goto state_8447;
	case Keyword::R_Z: m_lexer.next(); goto state_8448;
	case Keyword::SBB: m_lexer.next(); goto state_8449;
	case Keyword::SBC: m_lexer.next(); goto state_8458;
	case Keyword::SBI: m_lexer.next(); goto state_8551;
	case Keyword::SCF: m_lexer.next(); goto state_8553;
	case Keyword::SCF1: m_lexer.next(); goto state_8554;
	case Keyword::SECTION: m_lexer.next(); goto action_958;
	case Keyword::SET: m_lexer.next(); goto state_8555;
	case Keyword::SETAE: m_lexer.next(); goto state_8615;
	case Keyword::SETUSR: m_lexer.next(); goto state_8616;
	case Keyword::SHLD: m_lexer.next(); goto state_8617;
	case Keyword::SHLDE: m_lexer.next(); goto state_8619;
	case Keyword::SHLX: m_lexer.next(); goto state_8620;
	case Keyword::SIM: m_lexer.next(); goto state_8621;
	case Keyword::SLA: m_lexer.next(); goto state_8622;
	case Keyword::SLI: m_lexer.next(); goto state_8680;
	case Keyword::SLL: m_lexer.next(); goto state_8731;
	case Keyword::SLP: m_lexer.next(); goto state_8782;
	case Keyword::SLS: m_lexer.next(); goto state_8783;
	case Keyword::SPHL: m_lexer.next(); goto state_8834;
	case Keyword::SRA: m_lexer.next(); goto state_8835;
	case Keyword::SRL: m_lexer.next(); goto state_8896;
	case Keyword::STA: m_lexer.next(); goto state_8954;
	case Keyword::STAE: m_lexer.next(); goto state_8956;
	case Keyword::STAX: m_lexer.next(); goto state_8957;
	case Keyword::STC: m_lexer.next(); goto state_8962;
	case Keyword::STOP: m_lexer.next(); goto state_8963;
	case Keyword::SUB: m_lexer.next(); goto state_8964;
	case Keyword::SUI: m_lexer.next(); goto state_9052;
	case Keyword::SURES: m_lexer.next(); goto state_9054;
	case Keyword::SWAP: m_lexer.next(); goto state_9055;
	case Keyword::SWAPNIB: m_lexer.next(); goto state_9066;
	case Keyword::SYSCALL: m_lexer.next(); goto state_9067;
	case Keyword::TEST: m_lexer.next(); goto state_9068;
	case Keyword::TST: m_lexer.next(); goto state_9092;
	case Keyword::TSTIO: m_lexer.next(); goto state_9116;
	case Keyword::UMA: m_lexer.next(); goto state_9118;
	case Keyword::UMS: m_lexer.next(); goto state_9119;
	case Keyword::XCHG: m_lexer.next(); goto state_9120;
	case Keyword::XOR: m_lexer.next(); goto state_9121;
	case Keyword::XRA: m_lexer.next(); goto state_9202;
	case Keyword::XRI: m_lexer.next(); goto state_9211;
	case Keyword::XTHL: m_lexer.next(); goto state_9213;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Label: m_lexer.next(); goto state_9214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ACI
state_1:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2; }
	/*if (check_expr())*/ goto state_2;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ACI expr
state_2:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_0;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_0;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC
state_3:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4;
	case Keyword::A1: m_lexer.next(); goto state_33;
	case Keyword::B: m_lexer.next(); goto state_58;
	case Keyword::C: m_lexer.next(); goto state_59;
	case Keyword::D: m_lexer.next(); goto state_60;
	case Keyword::E: m_lexer.next(); goto state_61;
	case Keyword::H: m_lexer.next(); goto state_62;
	case Keyword::HL: m_lexer.next(); goto state_63;
	case Keyword::HL1: m_lexer.next(); goto state_69;
	case Keyword::IXH: m_lexer.next(); goto state_75;
	case Keyword::IXL: m_lexer.next(); goto state_76;
	case Keyword::IYH: m_lexer.next(); goto state_77;
	case Keyword::IYL: m_lexer.next(); goto state_78;
	case Keyword::L: m_lexer.next(); goto state_79;
	case Keyword::M: m_lexer.next(); goto state_80;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_81;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_96; }
	/*if (check_expr())*/ goto state_96;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A
state_4:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5;
	case TType::End: goto action_1;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma
state_5:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6;
	case Keyword::B: m_lexer.next(); goto state_7;
	case Keyword::C: m_lexer.next(); goto state_8;
	case Keyword::D: m_lexer.next(); goto state_9;
	case Keyword::E: m_lexer.next(); goto state_10;
	case Keyword::H: m_lexer.next(); goto state_11;
	case Keyword::IXH: m_lexer.next(); goto state_12;
	case Keyword::IXL: m_lexer.next(); goto state_13;
	case Keyword::IYH: m_lexer.next(); goto state_14;
	case Keyword::IYL: m_lexer.next(); goto state_15;
	case Keyword::L: m_lexer.next(); goto state_16;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_17;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_32; }
	/*if (check_expr())*/ goto state_32;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma A
state_6:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma B
state_7:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma C
state_8:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_3;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_3;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma D
state_9:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_4;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_4;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma E
state_10:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_5;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_5;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma H
state_11:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_6;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_6;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma IXH
state_12:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_7;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_7;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma IXL
state_13:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_8;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_8;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma IYH
state_14:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_9;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_9;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma IYL
state_15:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_10;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_10;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma L
state_16:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_11;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_11;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen
state_17:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_18;
	case Keyword::IX: m_lexer.next(); goto state_24;
	case Keyword::IY: m_lexer.next(); goto state_28;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen HL
state_18:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_19;
	case TType::Plus: m_lexer.next(); goto state_21;
	case TType::RParen: m_lexer.next(); goto state_23;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen HL Minus
state_19:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_20;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen HL Minus RParen
state_20:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_12;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_12;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen HL Plus
state_21:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_22;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen HL Plus RParen
state_22:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_13;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_13;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen HL RParen
state_23:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_14;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_14;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen IX
state_24:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_25;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_26; }
	/*if (check_expr())*/ goto state_26;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen IX RParen
state_25:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_15;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_15;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen IX expr
state_26:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_27;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen IX expr RParen
state_27:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_16;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_16;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen IY
state_28:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_29;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_30; }
	/*if (check_expr())*/ goto state_30;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen IY RParen
state_29:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_17;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_17;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen IY expr
state_30:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_31;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma LParen IY expr RParen
state_31:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_18;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_18;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A Comma expr
state_32:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_0;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_0;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1
state_33:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_34;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma
state_34:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_35;
	case Keyword::B: m_lexer.next(); goto state_36;
	case Keyword::C: m_lexer.next(); goto state_37;
	case Keyword::D: m_lexer.next(); goto state_38;
	case Keyword::E: m_lexer.next(); goto state_39;
	case Keyword::H: m_lexer.next(); goto state_40;
	case Keyword::L: m_lexer.next(); goto state_41;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_42;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_57; }
	/*if (check_expr())*/ goto state_57;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma A
state_35:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_19;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_19;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma B
state_36:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_20;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_20;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma C
state_37:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_21;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_21;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma D
state_38:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_22;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_22;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma E
state_39:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_23;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_23;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma H
state_40:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_24;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_24;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma L
state_41:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_25;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_25;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen
state_42:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_43;
	case Keyword::IX: m_lexer.next(); goto state_49;
	case Keyword::IY: m_lexer.next(); goto state_53;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen HL
state_43:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_44;
	case TType::Plus: m_lexer.next(); goto state_46;
	case TType::RParen: m_lexer.next(); goto state_48;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen HL Minus
state_44:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_45;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen HL Minus RParen
state_45:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_26;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_26;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen HL Plus
state_46:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_47;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen HL Plus RParen
state_47:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_27;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_27;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen HL RParen
state_48:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_28;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_28;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen IX
state_49:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_50;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_51; }
	/*if (check_expr())*/ goto state_51;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen IX RParen
state_50:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_29;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_29;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen IX expr
state_51:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_52;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen IX expr RParen
state_52:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_30;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_30;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen IY
state_53:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_54;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_55; }
	/*if (check_expr())*/ goto state_55;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen IY RParen
state_54:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_31;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_31;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen IY expr
state_55:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_56;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma LParen IY expr RParen
state_56:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_32;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_32;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC A1 Comma expr
state_57:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_33;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_33;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC B
state_58:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC C
state_59:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_3;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_3;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC D
state_60:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_4;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_4;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC E
state_61:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_5;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_5;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC H
state_62:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_6;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_6;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL
state_63:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_64;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL Comma
state_64:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_65;
	case Keyword::DE: m_lexer.next(); goto state_66;
	case Keyword::HL: m_lexer.next(); goto state_67;
	case Keyword::SP: m_lexer.next(); goto state_68;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL Comma BC
state_65:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_34;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_34;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL Comma DE
state_66:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_35;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_35;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL Comma HL
state_67:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_36;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_36;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL Comma SP
state_68:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_37;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_37;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL1
state_69:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_70;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL1 Comma
state_70:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_71;
	case Keyword::DE: m_lexer.next(); goto state_72;
	case Keyword::HL: m_lexer.next(); goto state_73;
	case Keyword::SP: m_lexer.next(); goto state_74;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL1 Comma BC
state_71:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_38;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_38;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL1 Comma DE
state_72:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_39;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_39;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL1 Comma HL
state_73:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_40;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_40;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC HL1 Comma SP
state_74:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_41;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_41;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC IXH
state_75:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_7;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_7;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC IXL
state_76:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_8;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_8;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC IYH
state_77:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_9;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_9;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC IYL
state_78:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_10;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_10;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC L
state_79:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_11;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_11;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC M
state_80:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_14;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_14;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen
state_81:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_82;
	case Keyword::IX: m_lexer.next(); goto state_88;
	case Keyword::IY: m_lexer.next(); goto state_92;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen HL
state_82:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_83;
	case TType::Plus: m_lexer.next(); goto state_85;
	case TType::RParen: m_lexer.next(); goto state_87;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen HL Minus
state_83:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_84;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen HL Minus RParen
state_84:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_12;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_12;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen HL Plus
state_85:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_86;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen HL Plus RParen
state_86:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_13;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_13;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen HL RParen
state_87:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_14;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_14;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen IX
state_88:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_89;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_90; }
	/*if (check_expr())*/ goto state_90;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen IX RParen
state_89:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_15;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_15;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen IX expr
state_90:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_91;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen IX expr RParen
state_91:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_16;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_16;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen IY
state_92:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_93;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_94; }
	/*if (check_expr())*/ goto state_94;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen IY RParen
state_93:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_17;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_17;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen IY expr
state_94:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_95;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC LParen IY expr RParen
state_95:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_18;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_18;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADC expr
state_96:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_0;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_0;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD
state_97:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_98;
	case Keyword::A1: m_lexer.next(); goto state_127;
	case Keyword::B: m_lexer.next(); goto state_152;
	case Keyword::BC: m_lexer.next(); goto state_153;
	case Keyword::C: m_lexer.next(); goto state_157;
	case Keyword::D: m_lexer.next(); goto state_158;
	case Keyword::DE: m_lexer.next(); goto state_159;
	case Keyword::E: m_lexer.next(); goto state_163;
	case Keyword::H: m_lexer.next(); goto state_164;
	case Keyword::HL: m_lexer.next(); goto state_165;
	case Keyword::HL1: m_lexer.next(); goto state_173;
	case Keyword::IX: m_lexer.next(); goto state_179;
	case Keyword::IXH: m_lexer.next(); goto state_185;
	case Keyword::IXL: m_lexer.next(); goto state_186;
	case Keyword::IY: m_lexer.next(); goto state_187;
	case Keyword::IYH: m_lexer.next(); goto state_193;
	case Keyword::IYL: m_lexer.next(); goto state_194;
	case Keyword::L: m_lexer.next(); goto state_195;
	case Keyword::M: m_lexer.next(); goto state_196;
	case Keyword::SP: m_lexer.next(); goto state_197;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_200;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_215; }
	/*if (check_expr())*/ goto state_215;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A
state_98:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_99;
	case TType::End: goto action_42;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_42;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma
state_99:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_100;
	case Keyword::B: m_lexer.next(); goto state_101;
	case Keyword::C: m_lexer.next(); goto state_102;
	case Keyword::D: m_lexer.next(); goto state_103;
	case Keyword::E: m_lexer.next(); goto state_104;
	case Keyword::H: m_lexer.next(); goto state_105;
	case Keyword::IXH: m_lexer.next(); goto state_106;
	case Keyword::IXL: m_lexer.next(); goto state_107;
	case Keyword::IYH: m_lexer.next(); goto state_108;
	case Keyword::IYL: m_lexer.next(); goto state_109;
	case Keyword::L: m_lexer.next(); goto state_110;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_111;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_126; }
	/*if (check_expr())*/ goto state_126;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma A
state_100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_42;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_42;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma B
state_101:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_43;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_43;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma C
state_102:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_44;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_44;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma D
state_103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_45;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_45;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma E
state_104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_46;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_46;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma H
state_105:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_47;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_47;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma IXH
state_106:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_48;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_48;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma IXL
state_107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_49;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_49;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma IYH
state_108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_50;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_50;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma IYL
state_109:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_51;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_51;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma L
state_110:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_52;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_52;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen
state_111:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_112;
	case Keyword::IX: m_lexer.next(); goto state_118;
	case Keyword::IY: m_lexer.next(); goto state_122;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen HL
state_112:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_113;
	case TType::Plus: m_lexer.next(); goto state_115;
	case TType::RParen: m_lexer.next(); goto state_117;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen HL Minus
state_113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen HL Minus RParen
state_114:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_53;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_53;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen HL Plus
state_115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_116;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen HL Plus RParen
state_116:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_54;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_54;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen HL RParen
state_117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_55;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_55;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen IX
state_118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_119;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_120; }
	/*if (check_expr())*/ goto state_120;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen IX RParen
state_119:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_56;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_56;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen IX expr
state_120:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_121;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen IX expr RParen
state_121:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_57;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_57;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen IY
state_122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_123;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_124; }
	/*if (check_expr())*/ goto state_124;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen IY RParen
state_123:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_58;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_58;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen IY expr
state_124:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_125;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma LParen IY expr RParen
state_125:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_59;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_59;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A Comma expr
state_126:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_60;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_60;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1
state_127:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma
state_128:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_129;
	case Keyword::B: m_lexer.next(); goto state_130;
	case Keyword::C: m_lexer.next(); goto state_131;
	case Keyword::D: m_lexer.next(); goto state_132;
	case Keyword::E: m_lexer.next(); goto state_133;
	case Keyword::H: m_lexer.next(); goto state_134;
	case Keyword::L: m_lexer.next(); goto state_135;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_136;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_151; }
	/*if (check_expr())*/ goto state_151;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma A
state_129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_61;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_61;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma B
state_130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_62;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_62;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma C
state_131:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_63;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_63;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma D
state_132:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_64;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_64;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma E
state_133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_65;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_65;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma H
state_134:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_66;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_66;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma L
state_135:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_67;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_67;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen
state_136:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_137;
	case Keyword::IX: m_lexer.next(); goto state_143;
	case Keyword::IY: m_lexer.next(); goto state_147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen HL
state_137:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_138;
	case TType::Plus: m_lexer.next(); goto state_140;
	case TType::RParen: m_lexer.next(); goto state_142;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen HL Minus
state_138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen HL Minus RParen
state_139:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_68;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_68;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen HL Plus
state_140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen HL Plus RParen
state_141:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_69;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_69;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen HL RParen
state_142:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_70;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_70;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen IX
state_143:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_144;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_145; }
	/*if (check_expr())*/ goto state_145;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen IX RParen
state_144:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_71;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_71;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen IX expr
state_145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen IX expr RParen
state_146:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_72;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_72;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen IY
state_147:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_148;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_149; }
	/*if (check_expr())*/ goto state_149;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen IY RParen
state_148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_73;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_73;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen IY expr
state_149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_150;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma LParen IY expr RParen
state_150:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_74;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_74;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD A1 Comma expr
state_151:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_75;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_75;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD B
state_152:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_43;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_43;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD BC
state_153:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_154;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD BC Comma
state_154:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_155;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_156; }
	/*if (check_expr())*/ goto state_156;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD BC Comma A
state_155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_76;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_76;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD BC Comma expr
state_156:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_77;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_77;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD C
state_157:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_44;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_44;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD D
state_158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_45;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_45;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD DE
state_159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_160;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD DE Comma
state_160:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_161;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_162; }
	/*if (check_expr())*/ goto state_162;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD DE Comma A
state_161:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_78;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_78;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD DE Comma expr
state_162:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_79;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_79;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD E
state_163:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_46;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_46;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD H
state_164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_47;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_47;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL
state_165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL Comma
state_166:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_167;
	case Keyword::BC: m_lexer.next(); goto state_168;
	case Keyword::DE: m_lexer.next(); goto state_169;
	case Keyword::HL: m_lexer.next(); goto state_170;
	case Keyword::SP: m_lexer.next(); goto state_171;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_172; }
	/*if (check_expr())*/ goto state_172;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL Comma A
state_167:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_80;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_80;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL Comma BC
state_168:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_81;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_81;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL Comma DE
state_169:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_82;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_82;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL Comma HL
state_170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_83;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_83;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL Comma SP
state_171:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_84;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_84;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL Comma expr
state_172:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_85;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_85;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL1
state_173:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_174;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL1 Comma
state_174:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_175;
	case Keyword::DE: m_lexer.next(); goto state_176;
	case Keyword::HL: m_lexer.next(); goto state_177;
	case Keyword::SP: m_lexer.next(); goto state_178;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL1 Comma BC
state_175:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_86;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_86;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL1 Comma DE
state_176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_87;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_87;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL1 Comma HL
state_177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_88;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_88;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD HL1 Comma SP
state_178:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_89;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_89;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IX
state_179:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_180;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IX Comma
state_180:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_181;
	case Keyword::DE: m_lexer.next(); goto state_182;
	case Keyword::IX: m_lexer.next(); goto state_183;
	case Keyword::SP: m_lexer.next(); goto state_184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IX Comma BC
state_181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_90;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_90;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IX Comma DE
state_182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_91;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_91;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IX Comma IX
state_183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_92;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_92;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IX Comma SP
state_184:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_93;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_93;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IXH
state_185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_48;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_48;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IXL
state_186:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_49;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_49;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IY
state_187:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IY Comma
state_188:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_189;
	case Keyword::DE: m_lexer.next(); goto state_190;
	case Keyword::IY: m_lexer.next(); goto state_191;
	case Keyword::SP: m_lexer.next(); goto state_192;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IY Comma BC
state_189:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_94;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_94;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IY Comma DE
state_190:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_95;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_95;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IY Comma IY
state_191:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_96;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_96;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IY Comma SP
state_192:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_97;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_97;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IYH
state_193:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_50;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_50;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD IYL
state_194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_51;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_51;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD L
state_195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_52;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_52;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD M
state_196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_55;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_55;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD SP
state_197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_198;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD SP Comma
state_198:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_199; }
	/*if (check_expr())*/ goto state_199;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD SP Comma expr
state_199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_98;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_98;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen
state_200:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_201;
	case Keyword::IX: m_lexer.next(); goto state_207;
	case Keyword::IY: m_lexer.next(); goto state_211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen HL
state_201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_202;
	case TType::Plus: m_lexer.next(); goto state_204;
	case TType::RParen: m_lexer.next(); goto state_206;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen HL Minus
state_202:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen HL Minus RParen
state_203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_53;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_53;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen HL Plus
state_204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen HL Plus RParen
state_205:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_54;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_54;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen HL RParen
state_206:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_55;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_55;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen IX
state_207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_208;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_209; }
	/*if (check_expr())*/ goto state_209;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen IX RParen
state_208:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_56;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_56;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen IX expr
state_209:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen IX expr RParen
state_210:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_57;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_57;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen IY
state_211:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_212;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_213; }
	/*if (check_expr())*/ goto state_213;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen IY RParen
state_212:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_58;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_58;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen IY expr
state_213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD LParen IY expr RParen
state_214:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_59;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_59;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADD expr
state_215:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_60;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_60;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADI
state_216:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_217;
	case Keyword::SP: m_lexer.next(); goto state_220;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_223; }
	/*if (check_expr())*/ goto state_223;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADI HL
state_217:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_218;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADI HL Comma
state_218:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_219; }
	/*if (check_expr())*/ goto state_219;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADI HL Comma expr
state_219:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_99;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_99;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADI SP
state_220:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_221;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADI SP Comma
state_221:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_222; }
	/*if (check_expr())*/ goto state_222;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADI SP Comma expr
state_222:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_100;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ADI expr
state_223:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_60;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_60;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD
state_224:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::ADC: m_lexer.next(); goto state_225;
	case Keyword::ADD: m_lexer.next(); goto state_279;
	case Keyword::AND: m_lexer.next(); goto state_333;
	case Keyword::BIT: m_lexer.next(); goto state_384;
	case Keyword::BOOL: m_lexer.next(); goto state_405;
	case Keyword::CCF: m_lexer.next(); goto state_407;
	case Keyword::CP: m_lexer.next(); goto state_408;
	case Keyword::CPL: m_lexer.next(); goto state_456;
	case Keyword::DEC: m_lexer.next(); goto state_458;
	case Keyword::DJNZ: m_lexer.next(); goto state_484;
	case Keyword::EX: m_lexer.next(); goto state_489;
	case Keyword::INC: m_lexer.next(); goto state_501;
	case Keyword::IOE: m_lexer.next(); goto state_527;
	case Keyword::IOI: m_lexer.next(); goto state_1105;
	case Keyword::LD: m_lexer.next(); goto state_1683;
	case Keyword::NEG: m_lexer.next(); goto state_1936;
	case Keyword::OR: m_lexer.next(); goto state_1938;
	case Keyword::POP: m_lexer.next(); goto state_1989;
	case Keyword::RES: m_lexer.next(); goto state_1994;
	case Keyword::RL: m_lexer.next(); goto state_2004;
	case Keyword::RLA: m_lexer.next(); goto state_2024;
	case Keyword::RLC: m_lexer.next(); goto state_2025;
	case Keyword::RLCA: m_lexer.next(); goto state_2044;
	case Keyword::RR: m_lexer.next(); goto state_2045;
	case Keyword::RRA: m_lexer.next(); goto state_2066;
	case Keyword::RRC: m_lexer.next(); goto state_2067;
	case Keyword::RRCA: m_lexer.next(); goto state_2086;
	case Keyword::SBC: m_lexer.next(); goto state_2087;
	case Keyword::SCF: m_lexer.next(); goto state_2141;
	case Keyword::SET: m_lexer.next(); goto state_2142;
	case Keyword::SLA: m_lexer.next(); goto state_2152;
	case Keyword::SRA: m_lexer.next(); goto state_2171;
	case Keyword::SRL: m_lexer.next(); goto state_2190;
	case Keyword::SUB: m_lexer.next(); goto state_2209;
	case Keyword::XOR: m_lexer.next(); goto state_2257;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC
state_225:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_226;
	case Keyword::B: m_lexer.next(); goto state_251;
	case Keyword::C: m_lexer.next(); goto state_252;
	case Keyword::D: m_lexer.next(); goto state_253;
	case Keyword::E: m_lexer.next(); goto state_254;
	case Keyword::H: m_lexer.next(); goto state_255;
	case Keyword::HL: m_lexer.next(); goto state_256;
	case Keyword::L: m_lexer.next(); goto state_262;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_263;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_278; }
	/*if (check_expr())*/ goto state_278;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A
state_226:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_227;
	case TType::End: goto action_19;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_19;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma
state_227:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_228;
	case Keyword::B: m_lexer.next(); goto state_229;
	case Keyword::C: m_lexer.next(); goto state_230;
	case Keyword::D: m_lexer.next(); goto state_231;
	case Keyword::E: m_lexer.next(); goto state_232;
	case Keyword::H: m_lexer.next(); goto state_233;
	case Keyword::L: m_lexer.next(); goto state_234;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_235;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_250; }
	/*if (check_expr())*/ goto state_250;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma A
state_228:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_19;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_19;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma B
state_229:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_20;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_20;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma C
state_230:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_21;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_21;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma D
state_231:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_22;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_22;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma E
state_232:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_23;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_23;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma H
state_233:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_24;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_24;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma L
state_234:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_25;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_25;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen
state_235:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_236;
	case Keyword::IX: m_lexer.next(); goto state_242;
	case Keyword::IY: m_lexer.next(); goto state_246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen HL
state_236:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_237;
	case TType::Plus: m_lexer.next(); goto state_239;
	case TType::RParen: m_lexer.next(); goto state_241;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen HL Minus
state_237:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_238;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen HL Minus RParen
state_238:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_26;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_26;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen HL Plus
state_239:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_240;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen HL Plus RParen
state_240:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_27;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_27;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen HL RParen
state_241:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_28;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_28;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen IX
state_242:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_243;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_244; }
	/*if (check_expr())*/ goto state_244;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen IX RParen
state_243:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_29;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_29;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen IX expr
state_244:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_245;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen IX expr RParen
state_245:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_30;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_30;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen IY
state_246:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_247;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_248; }
	/*if (check_expr())*/ goto state_248;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen IY RParen
state_247:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_31;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_31;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen IY expr
state_248:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_249;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma LParen IY expr RParen
state_249:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_32;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_32;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC A Comma expr
state_250:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_33;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_33;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC B
state_251:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_20;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_20;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC C
state_252:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_21;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_21;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC D
state_253:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_22;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_22;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC E
state_254:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_23;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_23;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC H
state_255:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_24;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_24;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC HL
state_256:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_257;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC HL Comma
state_257:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_258;
	case Keyword::DE: m_lexer.next(); goto state_259;
	case Keyword::HL: m_lexer.next(); goto state_260;
	case Keyword::SP: m_lexer.next(); goto state_261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC HL Comma BC
state_258:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_38;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_38;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC HL Comma DE
state_259:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_39;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_39;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC HL Comma HL
state_260:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_40;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_40;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC HL Comma SP
state_261:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_41;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_41;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC L
state_262:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_25;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_25;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen
state_263:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_264;
	case Keyword::IX: m_lexer.next(); goto state_270;
	case Keyword::IY: m_lexer.next(); goto state_274;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen HL
state_264:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_265;
	case TType::Plus: m_lexer.next(); goto state_267;
	case TType::RParen: m_lexer.next(); goto state_269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen HL Minus
state_265:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_266;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen HL Minus RParen
state_266:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_26;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_26;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen HL Plus
state_267:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_268;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen HL Plus RParen
state_268:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_27;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_27;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen HL RParen
state_269:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_28;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_28;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen IX
state_270:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_271;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_272; }
	/*if (check_expr())*/ goto state_272;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen IX RParen
state_271:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_29;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_29;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen IX expr
state_272:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_273;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen IX expr RParen
state_273:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_30;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_30;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen IY
state_274:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_275;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_276; }
	/*if (check_expr())*/ goto state_276;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen IY RParen
state_275:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_31;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_31;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen IY expr
state_276:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_277;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC LParen IY expr RParen
state_277:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_32;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_32;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADC expr
state_278:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_33;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_33;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD
state_279:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_280;
	case Keyword::B: m_lexer.next(); goto state_305;
	case Keyword::C: m_lexer.next(); goto state_306;
	case Keyword::D: m_lexer.next(); goto state_307;
	case Keyword::E: m_lexer.next(); goto state_308;
	case Keyword::H: m_lexer.next(); goto state_309;
	case Keyword::HL: m_lexer.next(); goto state_310;
	case Keyword::L: m_lexer.next(); goto state_316;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_317;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_332; }
	/*if (check_expr())*/ goto state_332;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A
state_280:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_281;
	case TType::End: goto action_61;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_61;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma
state_281:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_282;
	case Keyword::B: m_lexer.next(); goto state_283;
	case Keyword::C: m_lexer.next(); goto state_284;
	case Keyword::D: m_lexer.next(); goto state_285;
	case Keyword::E: m_lexer.next(); goto state_286;
	case Keyword::H: m_lexer.next(); goto state_287;
	case Keyword::L: m_lexer.next(); goto state_288;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_289;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_304; }
	/*if (check_expr())*/ goto state_304;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma A
state_282:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_61;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_61;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma B
state_283:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_62;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_62;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma C
state_284:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_63;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_63;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma D
state_285:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_64;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_64;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma E
state_286:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_65;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_65;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma H
state_287:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_66;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_66;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma L
state_288:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_67;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_67;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen
state_289:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_290;
	case Keyword::IX: m_lexer.next(); goto state_296;
	case Keyword::IY: m_lexer.next(); goto state_300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen HL
state_290:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_291;
	case TType::Plus: m_lexer.next(); goto state_293;
	case TType::RParen: m_lexer.next(); goto state_295;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen HL Minus
state_291:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_292;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen HL Minus RParen
state_292:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_68;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_68;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen HL Plus
state_293:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_294;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen HL Plus RParen
state_294:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_69;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_69;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen HL RParen
state_295:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_70;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_70;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen IX
state_296:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_297;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_298; }
	/*if (check_expr())*/ goto state_298;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen IX RParen
state_297:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_71;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_71;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen IX expr
state_298:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen IX expr RParen
state_299:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_72;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_72;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen IY
state_300:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_301;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_302; }
	/*if (check_expr())*/ goto state_302;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen IY RParen
state_301:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_73;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_73;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen IY expr
state_302:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma LParen IY expr RParen
state_303:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_74;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_74;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD A Comma expr
state_304:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_75;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_75;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD B
state_305:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_62;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_62;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD C
state_306:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_63;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_63;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD D
state_307:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_64;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_64;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD E
state_308:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_65;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_65;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD H
state_309:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_66;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_66;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD HL
state_310:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD HL Comma
state_311:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_312;
	case Keyword::DE: m_lexer.next(); goto state_313;
	case Keyword::HL: m_lexer.next(); goto state_314;
	case Keyword::SP: m_lexer.next(); goto state_315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD HL Comma BC
state_312:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_86;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_86;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD HL Comma DE
state_313:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_87;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_87;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD HL Comma HL
state_314:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_88;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_88;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD HL Comma SP
state_315:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_89;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_89;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD L
state_316:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_67;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_67;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen
state_317:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_318;
	case Keyword::IX: m_lexer.next(); goto state_324;
	case Keyword::IY: m_lexer.next(); goto state_328;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen HL
state_318:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_319;
	case TType::Plus: m_lexer.next(); goto state_321;
	case TType::RParen: m_lexer.next(); goto state_323;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen HL Minus
state_319:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_320;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen HL Minus RParen
state_320:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_68;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_68;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen HL Plus
state_321:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_322;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen HL Plus RParen
state_322:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_69;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_69;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen HL RParen
state_323:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_70;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_70;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen IX
state_324:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_325;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_326; }
	/*if (check_expr())*/ goto state_326;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen IX RParen
state_325:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_71;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_71;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen IX expr
state_326:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_327;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen IX expr RParen
state_327:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_72;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_72;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen IY
state_328:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_329;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_330; }
	/*if (check_expr())*/ goto state_330;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen IY RParen
state_329:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_73;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_73;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen IY expr
state_330:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_331;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD LParen IY expr RParen
state_331:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_74;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_74;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD ADD expr
state_332:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_75;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_75;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND
state_333:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_334;
	case Keyword::B: m_lexer.next(); goto state_359;
	case Keyword::C: m_lexer.next(); goto state_360;
	case Keyword::D: m_lexer.next(); goto state_361;
	case Keyword::E: m_lexer.next(); goto state_362;
	case Keyword::H: m_lexer.next(); goto state_363;
	case Keyword::HL: m_lexer.next(); goto state_364;
	case Keyword::L: m_lexer.next(); goto state_367;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_368;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_383; }
	/*if (check_expr())*/ goto state_383;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A
state_334:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_335;
	case TType::End: goto action_101;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_101;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma
state_335:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_336;
	case Keyword::B: m_lexer.next(); goto state_337;
	case Keyword::C: m_lexer.next(); goto state_338;
	case Keyword::D: m_lexer.next(); goto state_339;
	case Keyword::E: m_lexer.next(); goto state_340;
	case Keyword::H: m_lexer.next(); goto state_341;
	case Keyword::L: m_lexer.next(); goto state_342;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_343;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_358; }
	/*if (check_expr())*/ goto state_358;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma A
state_336:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_101;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_101;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma B
state_337:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_102;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_102;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma C
state_338:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_103;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_103;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma D
state_339:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_104;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma E
state_340:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_105;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_105;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma H
state_341:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_106;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_106;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma L
state_342:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_107;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen
state_343:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_344;
	case Keyword::IX: m_lexer.next(); goto state_350;
	case Keyword::IY: m_lexer.next(); goto state_354;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen HL
state_344:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_345;
	case TType::Plus: m_lexer.next(); goto state_347;
	case TType::RParen: m_lexer.next(); goto state_349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen HL Minus
state_345:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_346;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen HL Minus RParen
state_346:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_108;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen HL Plus
state_347:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen HL Plus RParen
state_348:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_109;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen HL RParen
state_349:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_110;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_110;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen IX
state_350:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_351;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_352; }
	/*if (check_expr())*/ goto state_352;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen IX RParen
state_351:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_111;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen IX expr
state_352:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_353;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen IX expr RParen
state_353:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_112;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_112;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen IY
state_354:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_355;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_356; }
	/*if (check_expr())*/ goto state_356;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen IY RParen
state_355:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_113;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_113;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen IY expr
state_356:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma LParen IY expr RParen
state_357:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_114;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND A Comma expr
state_358:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_115;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND B
state_359:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_102;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_102;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND C
state_360:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_103;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_103;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND D
state_361:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_104;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND E
state_362:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_105;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_105;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND H
state_363:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_106;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_106;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND HL
state_364:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_365;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND HL Comma
state_365:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_366;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND HL Comma DE
state_366:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_116;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_116;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND L
state_367:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_107;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen
state_368:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_369;
	case Keyword::IX: m_lexer.next(); goto state_375;
	case Keyword::IY: m_lexer.next(); goto state_379;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen HL
state_369:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_370;
	case TType::Plus: m_lexer.next(); goto state_372;
	case TType::RParen: m_lexer.next(); goto state_374;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen HL Minus
state_370:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_371;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen HL Minus RParen
state_371:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_108;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen HL Plus
state_372:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_373;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen HL Plus RParen
state_373:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_109;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen HL RParen
state_374:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_110;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_110;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen IX
state_375:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_376;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_377; }
	/*if (check_expr())*/ goto state_377;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen IX RParen
state_376:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_111;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen IX expr
state_377:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_378;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen IX expr RParen
state_378:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_112;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_112;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen IY
state_379:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_380;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_381; }
	/*if (check_expr())*/ goto state_381;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen IY RParen
state_380:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_113;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_113;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen IY expr
state_381:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_382;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND LParen IY expr RParen
state_382:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_114;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD AND expr
state_383:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_115;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT
state_384:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_385; }
	/*if (check_const_expr())*/ goto state_385;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr
state_385:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_386;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma
state_386:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_387;
	case Keyword::B: m_lexer.next(); goto state_388;
	case Keyword::C: m_lexer.next(); goto state_389;
	case Keyword::D: m_lexer.next(); goto state_390;
	case Keyword::E: m_lexer.next(); goto state_391;
	case Keyword::H: m_lexer.next(); goto state_392;
	case Keyword::L: m_lexer.next(); goto state_393;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_394;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma A
state_387:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_117;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_117;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma B
state_388:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_118;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_118;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma C
state_389:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_119;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_119;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma D
state_390:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_120;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_120;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma E
state_391:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_121;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_121;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma H
state_392:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_122;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_122;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma L
state_393:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_123;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_123;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen
state_394:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_395;
	case Keyword::IX: m_lexer.next(); goto state_397;
	case Keyword::IY: m_lexer.next(); goto state_401;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen HL
state_395:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_396;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen HL RParen
state_396:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_124;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_124;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen IX
state_397:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_398;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_399; }
	/*if (check_expr())*/ goto state_399;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen IX RParen
state_398:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_125;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_125;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen IX expr
state_399:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen IX expr RParen
state_400:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_126;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_126;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen IY
state_401:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_402;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_403; }
	/*if (check_expr())*/ goto state_403;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen IY RParen
state_402:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_127;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_127;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen IY expr
state_403:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_404;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BIT const_expr Comma LParen IY expr RParen
state_404:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_128;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BOOL
state_405:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_406;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD BOOL HL
state_406:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_129;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CCF
state_407:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_130;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_130;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP
state_408:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_409;
	case Keyword::B: m_lexer.next(); goto state_434;
	case Keyword::C: m_lexer.next(); goto state_435;
	case Keyword::D: m_lexer.next(); goto state_436;
	case Keyword::E: m_lexer.next(); goto state_437;
	case Keyword::H: m_lexer.next(); goto state_438;
	case Keyword::L: m_lexer.next(); goto state_439;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_440;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_455; }
	/*if (check_expr())*/ goto state_455;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A
state_409:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_410;
	case TType::End: goto action_131;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma
state_410:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_411;
	case Keyword::B: m_lexer.next(); goto state_412;
	case Keyword::C: m_lexer.next(); goto state_413;
	case Keyword::D: m_lexer.next(); goto state_414;
	case Keyword::E: m_lexer.next(); goto state_415;
	case Keyword::H: m_lexer.next(); goto state_416;
	case Keyword::L: m_lexer.next(); goto state_417;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_418;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_433; }
	/*if (check_expr())*/ goto state_433;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma A
state_411:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_131;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma B
state_412:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_132;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_132;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma C
state_413:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_133;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_133;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma D
state_414:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_134;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_134;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma E
state_415:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_135;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma H
state_416:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_136;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_136;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma L
state_417:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_137;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_137;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen
state_418:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_419;
	case Keyword::IX: m_lexer.next(); goto state_425;
	case Keyword::IY: m_lexer.next(); goto state_429;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen HL
state_419:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_420;
	case TType::Plus: m_lexer.next(); goto state_422;
	case TType::RParen: m_lexer.next(); goto state_424;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen HL Minus
state_420:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen HL Minus RParen
state_421:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_138;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen HL Plus
state_422:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_423;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen HL Plus RParen
state_423:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_139;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen HL RParen
state_424:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_140;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen IX
state_425:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_426;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_427; }
	/*if (check_expr())*/ goto state_427;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen IX RParen
state_426:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_141;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen IX expr
state_427:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_428;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen IX expr RParen
state_428:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_142;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_142;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen IY
state_429:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_430;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_431; }
	/*if (check_expr())*/ goto state_431;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen IY RParen
state_430:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_143;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_143;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen IY expr
state_431:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_432;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma LParen IY expr RParen
state_432:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_144;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_144;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP A Comma expr
state_433:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_145;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_145;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP B
state_434:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_132;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_132;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP C
state_435:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_133;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_133;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP D
state_436:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_134;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_134;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP E
state_437:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_135;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP H
state_438:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_136;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_136;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP L
state_439:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_137;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_137;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen
state_440:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_441;
	case Keyword::IX: m_lexer.next(); goto state_447;
	case Keyword::IY: m_lexer.next(); goto state_451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen HL
state_441:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_442;
	case TType::Plus: m_lexer.next(); goto state_444;
	case TType::RParen: m_lexer.next(); goto state_446;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen HL Minus
state_442:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_443;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen HL Minus RParen
state_443:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_138;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen HL Plus
state_444:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_445;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen HL Plus RParen
state_445:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_139;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen HL RParen
state_446:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_140;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen IX
state_447:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_448;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_449; }
	/*if (check_expr())*/ goto state_449;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen IX RParen
state_448:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_141;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen IX expr
state_449:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_450;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen IX expr RParen
state_450:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_142;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_142;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen IY
state_451:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_452;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_453; }
	/*if (check_expr())*/ goto state_453;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen IY RParen
state_452:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_143;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_143;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen IY expr
state_453:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP LParen IY expr RParen
state_454:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_144;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_144;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CP expr
state_455:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_145;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_145;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CPL
state_456:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_457;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_146;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD CPL A
state_457:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_146;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC
state_458:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_459;
	case Keyword::B: m_lexer.next(); goto state_460;
	case Keyword::BC: m_lexer.next(); goto state_461;
	case Keyword::C: m_lexer.next(); goto state_462;
	case Keyword::D: m_lexer.next(); goto state_463;
	case Keyword::DE: m_lexer.next(); goto state_464;
	case Keyword::E: m_lexer.next(); goto state_465;
	case Keyword::H: m_lexer.next(); goto state_466;
	case Keyword::HL: m_lexer.next(); goto state_467;
	case Keyword::L: m_lexer.next(); goto state_468;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC A
state_459:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_147;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC B
state_460:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_148;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_148;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC BC
state_461:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_149;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_149;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC C
state_462:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_150;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_150;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC D
state_463:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_151;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC DE
state_464:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_152;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC E
state_465:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_153;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_153;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC H
state_466:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_154;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_154;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC HL
state_467:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_155;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_155;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC L
state_468:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_156;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_156;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen
state_469:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_470;
	case Keyword::IX: m_lexer.next(); goto state_476;
	case Keyword::IY: m_lexer.next(); goto state_480;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen HL
state_470:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_471;
	case TType::Plus: m_lexer.next(); goto state_473;
	case TType::RParen: m_lexer.next(); goto state_475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen HL Minus
state_471:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_472;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen HL Minus RParen
state_472:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_157;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_157;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen HL Plus
state_473:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_474;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen HL Plus RParen
state_474:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_158;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_158;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen HL RParen
state_475:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_159;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_159;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen IX
state_476:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_477;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_478; }
	/*if (check_expr())*/ goto state_478;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen IX RParen
state_477:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_160;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_160;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen IX expr
state_478:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_479;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen IX expr RParen
state_479:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_161;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_161;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen IY
state_480:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_481;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_482; }
	/*if (check_expr())*/ goto state_482;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen IY RParen
state_481:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_162;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen IY expr
state_482:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_483;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DEC LParen IY expr RParen
state_483:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_163;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DJNZ
state_484:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_485;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_488; }
	/*if (check_expr())*/ goto state_488;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DJNZ B
state_485:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DJNZ B Comma
state_486:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_487; }
	/*if (check_expr())*/ goto state_487;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DJNZ B Comma expr
state_487:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_164;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_164;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD DJNZ expr
state_488:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_164;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_164;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX
state_489:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_490;
	case Keyword::DE1: m_lexer.next(); goto state_493;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_496;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX DE
state_490:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_491;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX DE Comma
state_491:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_492;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX DE Comma HL
state_492:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_165;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX DE1
state_493:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_494;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX DE1 Comma
state_494:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_495;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX DE1 Comma HL
state_495:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_166;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX LParen
state_496:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::SP: m_lexer.next(); goto state_497;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX LParen SP
state_497:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_498;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX LParen SP RParen
state_498:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_499;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX LParen SP RParen Comma
state_499:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD EX LParen SP RParen Comma HL
state_500:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_167;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC
state_501:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_502;
	case Keyword::B: m_lexer.next(); goto state_503;
	case Keyword::BC: m_lexer.next(); goto state_504;
	case Keyword::C: m_lexer.next(); goto state_505;
	case Keyword::D: m_lexer.next(); goto state_506;
	case Keyword::DE: m_lexer.next(); goto state_507;
	case Keyword::E: m_lexer.next(); goto state_508;
	case Keyword::H: m_lexer.next(); goto state_509;
	case Keyword::HL: m_lexer.next(); goto state_510;
	case Keyword::L: m_lexer.next(); goto state_511;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_512;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC A
state_502:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_168;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC B
state_503:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_169;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_169;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC BC
state_504:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_170;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_170;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC C
state_505:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_171;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_171;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC D
state_506:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_172;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_172;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC DE
state_507:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_173;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_173;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC E
state_508:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_174;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_174;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC H
state_509:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_175;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_175;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC HL
state_510:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_176;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_176;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC L
state_511:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_177;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_177;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen
state_512:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_513;
	case Keyword::IX: m_lexer.next(); goto state_519;
	case Keyword::IY: m_lexer.next(); goto state_523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen HL
state_513:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_514;
	case TType::Plus: m_lexer.next(); goto state_516;
	case TType::RParen: m_lexer.next(); goto state_518;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen HL Minus
state_514:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_515;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen HL Minus RParen
state_515:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_178;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_178;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen HL Plus
state_516:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_517;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen HL Plus RParen
state_517:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_179;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_179;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen HL RParen
state_518:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_180;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_180;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen IX
state_519:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_520;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_521; }
	/*if (check_expr())*/ goto state_521;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen IX RParen
state_520:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_181;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_181;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen IX expr
state_521:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_522;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen IX expr RParen
state_522:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_182;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_182;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen IY
state_523:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_524;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_525; }
	/*if (check_expr())*/ goto state_525;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen IY RParen
state_524:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_183;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_183;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen IY expr
state_525:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_526;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD INC LParen IY expr RParen
state_526:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_184;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE
state_527:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::ADC: m_lexer.next(); goto state_528;
	case Keyword::ADD: m_lexer.next(); goto state_561;
	case Keyword::AND: m_lexer.next(); goto state_594;
	case Keyword::BIT: m_lexer.next(); goto state_627;
	case Keyword::CP: m_lexer.next(); goto state_641;
	case Keyword::DEC: m_lexer.next(); goto state_674;
	case Keyword::INC: m_lexer.next(); goto state_690;
	case Keyword::LD: m_lexer.next(); goto state_706;
	case Keyword::OR: m_lexer.next(); goto state_889;
	case Keyword::RL: m_lexer.next(); goto state_922;
	case Keyword::RLC: m_lexer.next(); goto state_934;
	case Keyword::RR: m_lexer.next(); goto state_946;
	case Keyword::RRC: m_lexer.next(); goto state_958;
	case Keyword::SBC: m_lexer.next(); goto state_970;
	case Keyword::SLA: m_lexer.next(); goto state_1003;
	case Keyword::SRA: m_lexer.next(); goto state_1015;
	case Keyword::SRL: m_lexer.next(); goto state_1027;
	case Keyword::SUB: m_lexer.next(); goto state_1039;
	case Keyword::XOR: m_lexer.next(); goto state_1072;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC
state_528:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_529;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_546;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A
state_529:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_530;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma
state_530:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen
state_531:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_532;
	case Keyword::IX: m_lexer.next(); goto state_538;
	case Keyword::IY: m_lexer.next(); goto state_542;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen HL
state_532:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_533;
	case TType::Plus: m_lexer.next(); goto state_535;
	case TType::RParen: m_lexer.next(); goto state_537;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen HL Minus
state_533:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen HL Minus RParen
state_534:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_185;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen HL Plus
state_535:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_536;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen HL Plus RParen
state_536:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_186;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_186;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen HL RParen
state_537:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_187;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen IX
state_538:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_539;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_540; }
	/*if (check_expr())*/ goto state_540;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen IX RParen
state_539:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_188;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen IX expr
state_540:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen IX expr RParen
state_541:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_189;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen IY
state_542:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_543;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_544; }
	/*if (check_expr())*/ goto state_544;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen IY RParen
state_543:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_190;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen IY expr
state_544:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_545;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC A Comma LParen IY expr RParen
state_545:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_191;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_191;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen
state_546:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_547;
	case Keyword::IX: m_lexer.next(); goto state_553;
	case Keyword::IY: m_lexer.next(); goto state_557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen HL
state_547:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_548;
	case TType::Plus: m_lexer.next(); goto state_550;
	case TType::RParen: m_lexer.next(); goto state_552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen HL Minus
state_548:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen HL Minus RParen
state_549:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_185;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen HL Plus
state_550:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_551;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen HL Plus RParen
state_551:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_186;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_186;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen HL RParen
state_552:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_187;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen IX
state_553:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_554;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_555; }
	/*if (check_expr())*/ goto state_555;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen IX RParen
state_554:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_188;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen IX expr
state_555:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen IX expr RParen
state_556:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_189;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen IY
state_557:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_558;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_559; }
	/*if (check_expr())*/ goto state_559;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen IY RParen
state_558:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_190;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen IY expr
state_559:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_560;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADC LParen IY expr RParen
state_560:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_191;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_191;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD
state_561:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_562;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_579;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A
state_562:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma
state_563:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_564;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen
state_564:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_565;
	case Keyword::IX: m_lexer.next(); goto state_571;
	case Keyword::IY: m_lexer.next(); goto state_575;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen HL
state_565:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_566;
	case TType::Plus: m_lexer.next(); goto state_568;
	case TType::RParen: m_lexer.next(); goto state_570;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen HL Minus
state_566:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen HL Minus RParen
state_567:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_192;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_192;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen HL Plus
state_568:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_569;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen HL Plus RParen
state_569:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_193;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_193;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen HL RParen
state_570:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_194;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen IX
state_571:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_572;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_573; }
	/*if (check_expr())*/ goto state_573;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen IX RParen
state_572:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_195;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen IX expr
state_573:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen IX expr RParen
state_574:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_196;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen IY
state_575:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_576;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_577; }
	/*if (check_expr())*/ goto state_577;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen IY RParen
state_576:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_197;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen IY expr
state_577:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD A Comma LParen IY expr RParen
state_578:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_198;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_198;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen
state_579:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_580;
	case Keyword::IX: m_lexer.next(); goto state_586;
	case Keyword::IY: m_lexer.next(); goto state_590;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen HL
state_580:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_581;
	case TType::Plus: m_lexer.next(); goto state_583;
	case TType::RParen: m_lexer.next(); goto state_585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen HL Minus
state_581:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen HL Minus RParen
state_582:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_192;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_192;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen HL Plus
state_583:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen HL Plus RParen
state_584:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_193;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_193;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen HL RParen
state_585:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_194;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen IX
state_586:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_587;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_588; }
	/*if (check_expr())*/ goto state_588;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen IX RParen
state_587:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_195;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen IX expr
state_588:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen IX expr RParen
state_589:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_196;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen IY
state_590:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_591;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_592; }
	/*if (check_expr())*/ goto state_592;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen IY RParen
state_591:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_197;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen IY expr
state_592:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_593;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE ADD LParen IY expr RParen
state_593:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_198;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_198;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND
state_594:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_595;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A
state_595:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_596;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma
state_596:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_597;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen
state_597:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_598;
	case Keyword::IX: m_lexer.next(); goto state_604;
	case Keyword::IY: m_lexer.next(); goto state_608;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen HL
state_598:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_599;
	case TType::Plus: m_lexer.next(); goto state_601;
	case TType::RParen: m_lexer.next(); goto state_603;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen HL Minus
state_599:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen HL Minus RParen
state_600:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_199;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_199;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen HL Plus
state_601:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_602;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen HL Plus RParen
state_602:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_200;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen HL RParen
state_603:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_201;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_201;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen IX
state_604:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_605;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_606; }
	/*if (check_expr())*/ goto state_606;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen IX RParen
state_605:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_202;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_202;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen IX expr
state_606:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_607;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen IX expr RParen
state_607:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_203;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen IY
state_608:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_609;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_610; }
	/*if (check_expr())*/ goto state_610;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen IY RParen
state_609:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_204;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_204;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen IY expr
state_610:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND A Comma LParen IY expr RParen
state_611:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_205;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen
state_612:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_613;
	case Keyword::IX: m_lexer.next(); goto state_619;
	case Keyword::IY: m_lexer.next(); goto state_623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen HL
state_613:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_614;
	case TType::Plus: m_lexer.next(); goto state_616;
	case TType::RParen: m_lexer.next(); goto state_618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen HL Minus
state_614:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_615;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen HL Minus RParen
state_615:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_199;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_199;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen HL Plus
state_616:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen HL Plus RParen
state_617:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_200;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen HL RParen
state_618:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_201;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_201;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen IX
state_619:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_620;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_621; }
	/*if (check_expr())*/ goto state_621;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen IX RParen
state_620:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_202;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_202;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen IX expr
state_621:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_622;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen IX expr RParen
state_622:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_203;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen IY
state_623:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_624;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_625; }
	/*if (check_expr())*/ goto state_625;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen IY RParen
state_624:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_204;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_204;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen IY expr
state_625:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_626;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE AND LParen IY expr RParen
state_626:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_205;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT
state_627:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_628; }
	/*if (check_const_expr())*/ goto state_628;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr
state_628:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_629;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma
state_629:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_630;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen
state_630:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_631;
	case Keyword::IX: m_lexer.next(); goto state_633;
	case Keyword::IY: m_lexer.next(); goto state_637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen HL
state_631:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen HL RParen
state_632:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_206;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_206;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen IX
state_633:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_634;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_635; }
	/*if (check_expr())*/ goto state_635;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen IX RParen
state_634:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_207;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_207;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen IX expr
state_635:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen IX expr RParen
state_636:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_208;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_208;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen IY
state_637:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_638;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_639; }
	/*if (check_expr())*/ goto state_639;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen IY RParen
state_638:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_209;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_209;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen IY expr
state_639:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE BIT const_expr Comma LParen IY expr RParen
state_640:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_210;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP
state_641:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_642;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A
state_642:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_643;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma
state_643:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen
state_644:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_645;
	case Keyword::IX: m_lexer.next(); goto state_651;
	case Keyword::IY: m_lexer.next(); goto state_655;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen HL
state_645:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_646;
	case TType::Plus: m_lexer.next(); goto state_648;
	case TType::RParen: m_lexer.next(); goto state_650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen HL Minus
state_646:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen HL Minus RParen
state_647:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_211;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen HL Plus
state_648:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen HL Plus RParen
state_649:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_212;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen HL RParen
state_650:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_213;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen IX
state_651:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_652;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_653; }
	/*if (check_expr())*/ goto state_653;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen IX RParen
state_652:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_214;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen IX expr
state_653:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_654;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen IX expr RParen
state_654:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_215;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen IY
state_655:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_656;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_657; }
	/*if (check_expr())*/ goto state_657;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen IY RParen
state_656:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_216;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_216;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen IY expr
state_657:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP A Comma LParen IY expr RParen
state_658:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_217;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_217;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen
state_659:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_660;
	case Keyword::IX: m_lexer.next(); goto state_666;
	case Keyword::IY: m_lexer.next(); goto state_670;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen HL
state_660:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_661;
	case TType::Plus: m_lexer.next(); goto state_663;
	case TType::RParen: m_lexer.next(); goto state_665;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen HL Minus
state_661:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen HL Minus RParen
state_662:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_211;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen HL Plus
state_663:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen HL Plus RParen
state_664:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_212;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen HL RParen
state_665:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_213;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen IX
state_666:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_667;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_668; }
	/*if (check_expr())*/ goto state_668;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen IX RParen
state_667:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_214;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen IX expr
state_668:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_669;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen IX expr RParen
state_669:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_215;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen IY
state_670:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_671;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_672; }
	/*if (check_expr())*/ goto state_672;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen IY RParen
state_671:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_216;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_216;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen IY expr
state_672:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE CP LParen IY expr RParen
state_673:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_217;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_217;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC
state_674:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_675;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen
state_675:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_676;
	case Keyword::IX: m_lexer.next(); goto state_682;
	case Keyword::IY: m_lexer.next(); goto state_686;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen HL
state_676:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_677;
	case TType::Plus: m_lexer.next(); goto state_679;
	case TType::RParen: m_lexer.next(); goto state_681;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen HL Minus
state_677:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen HL Minus RParen
state_678:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_218;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_218;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen HL Plus
state_679:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_680;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen HL Plus RParen
state_680:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_219;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_219;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen HL RParen
state_681:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_220;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_220;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen IX
state_682:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_683;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_684; }
	/*if (check_expr())*/ goto state_684;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen IX RParen
state_683:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_221;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_221;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen IX expr
state_684:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen IX expr RParen
state_685:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_222;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_222;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen IY
state_686:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_687;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_688; }
	/*if (check_expr())*/ goto state_688;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen IY RParen
state_687:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_223;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_223;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen IY expr
state_688:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_689;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE DEC LParen IY expr RParen
state_689:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_224;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_224;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC
state_690:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_691;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen
state_691:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_692;
	case Keyword::IX: m_lexer.next(); goto state_698;
	case Keyword::IY: m_lexer.next(); goto state_702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen HL
state_692:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_693;
	case TType::Plus: m_lexer.next(); goto state_695;
	case TType::RParen: m_lexer.next(); goto state_697;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen HL Minus
state_693:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen HL Minus RParen
state_694:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_225;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_225;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen HL Plus
state_695:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_696;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen HL Plus RParen
state_696:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_226;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_226;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen HL RParen
state_697:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_227;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_227;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen IX
state_698:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_699;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_700; }
	/*if (check_expr())*/ goto state_700;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen IX RParen
state_699:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_228;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_228;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen IX expr
state_700:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen IX expr RParen
state_701:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_229;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_229;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen IY
state_702:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_703;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_704; }
	/*if (check_expr())*/ goto state_704;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen IY RParen
state_703:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_230;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_230;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen IY expr
state_704:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_705;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE INC LParen IY expr RParen
state_705:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_231;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_231;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD
state_706:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_707;
	case Keyword::B: m_lexer.next(); goto state_741;
	case Keyword::BC: m_lexer.next(); goto state_762;
	case Keyword::C: m_lexer.next(); goto state_765;
	case Keyword::D: m_lexer.next(); goto state_786;
	case Keyword::DE: m_lexer.next(); goto state_807;
	case Keyword::E: m_lexer.next(); goto state_810;
	case Keyword::H: m_lexer.next(); goto state_831;
	case Keyword::HL: m_lexer.next(); goto state_852;
	case Keyword::L: m_lexer.next(); goto state_868;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A
state_707:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma
state_708:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_709;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_740; }
	/*if (check_expr())*/ goto state_740;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen
state_709:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_710;
	case Keyword::DE: m_lexer.next(); goto state_716;
	case Keyword::HL: m_lexer.next(); goto state_722;
	case Keyword::HLD: m_lexer.next(); goto state_728;
	case Keyword::HLI: m_lexer.next(); goto state_730;
	case Keyword::IX: m_lexer.next(); goto state_732;
	case Keyword::IY: m_lexer.next(); goto state_736;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen BC
state_710:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_711;
	case TType::Plus: m_lexer.next(); goto state_713;
	case TType::RParen: m_lexer.next(); goto state_715;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen BC Minus
state_711:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_712;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen BC Minus RParen
state_712:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_232;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_232;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen BC Plus
state_713:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_714;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen BC Plus RParen
state_714:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_233;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_233;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen BC RParen
state_715:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_234;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_234;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen DE
state_716:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_717;
	case TType::Plus: m_lexer.next(); goto state_719;
	case TType::RParen: m_lexer.next(); goto state_721;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen DE Minus
state_717:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_718;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen DE Minus RParen
state_718:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_235;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_235;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen DE Plus
state_719:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_720;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen DE Plus RParen
state_720:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_236;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_236;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen DE RParen
state_721:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_237;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_237;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HL
state_722:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_723;
	case TType::Plus: m_lexer.next(); goto state_725;
	case TType::RParen: m_lexer.next(); goto state_727;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HL Minus
state_723:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HL Minus RParen
state_724:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_238;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_238;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HL Plus
state_725:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_726;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HL Plus RParen
state_726:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_239;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_239;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HL RParen
state_727:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_240;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_240;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HLD
state_728:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HLD RParen
state_729:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_238;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_238;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HLI
state_730:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_731;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen HLI RParen
state_731:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_239;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_239;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen IX
state_732:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_733;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_734; }
	/*if (check_expr())*/ goto state_734;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen IX RParen
state_733:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_241;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_241;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen IX expr
state_734:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_735;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen IX expr RParen
state_735:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_242;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_242;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen IY
state_736:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_737;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_738; }
	/*if (check_expr())*/ goto state_738;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen IY RParen
state_737:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_243;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_243;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen IY expr
state_738:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma LParen IY expr RParen
state_739:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_244;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_244;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD A Comma expr
state_740:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_245;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_245;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B
state_741:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_742;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma
state_742:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_743;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen
state_743:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_744;
	case Keyword::HLD: m_lexer.next(); goto state_750;
	case Keyword::HLI: m_lexer.next(); goto state_752;
	case Keyword::IX: m_lexer.next(); goto state_754;
	case Keyword::IY: m_lexer.next(); goto state_758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HL
state_744:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_745;
	case TType::Plus: m_lexer.next(); goto state_747;
	case TType::RParen: m_lexer.next(); goto state_749;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HL Minus
state_745:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_746;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HL Minus RParen
state_746:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_246;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HL Plus
state_747:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_748;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HL Plus RParen
state_748:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_247;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_247;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HL RParen
state_749:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_248;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_248;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HLD
state_750:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HLD RParen
state_751:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_246;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HLI
state_752:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen HLI RParen
state_753:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_247;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_247;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen IX
state_754:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_755;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_756; }
	/*if (check_expr())*/ goto state_756;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen IX RParen
state_755:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_249;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_249;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen IX expr
state_756:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen IX expr RParen
state_757:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_250;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_250;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen IY
state_758:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_759;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_760; }
	/*if (check_expr())*/ goto state_760;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen IY RParen
state_759:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_251;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_251;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen IY expr
state_760:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD B Comma LParen IY expr RParen
state_761:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_252;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_252;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD BC
state_762:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD BC Comma
state_763:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_764; }
	/*if (check_expr())*/ goto state_764;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD BC Comma expr
state_764:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_253;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_253;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C
state_765:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_766;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma
state_766:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen
state_767:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_768;
	case Keyword::HLD: m_lexer.next(); goto state_774;
	case Keyword::HLI: m_lexer.next(); goto state_776;
	case Keyword::IX: m_lexer.next(); goto state_778;
	case Keyword::IY: m_lexer.next(); goto state_782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HL
state_768:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_769;
	case TType::Plus: m_lexer.next(); goto state_771;
	case TType::RParen: m_lexer.next(); goto state_773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HL Minus
state_769:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_770;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HL Minus RParen
state_770:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_254;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_254;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HL Plus
state_771:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_772;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HL Plus RParen
state_772:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_255;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_255;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HL RParen
state_773:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_256;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_256;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HLD
state_774:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_775;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HLD RParen
state_775:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_254;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_254;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HLI
state_776:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen HLI RParen
state_777:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_255;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_255;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen IX
state_778:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_779;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_780; }
	/*if (check_expr())*/ goto state_780;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen IX RParen
state_779:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_257;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_257;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen IX expr
state_780:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen IX expr RParen
state_781:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_258;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_258;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen IY
state_782:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_783;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_784; }
	/*if (check_expr())*/ goto state_784;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen IY RParen
state_783:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_259;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_259;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen IY expr
state_784:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD C Comma LParen IY expr RParen
state_785:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_260;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_260;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D
state_786:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_787;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma
state_787:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_788;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen
state_788:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_789;
	case Keyword::HLD: m_lexer.next(); goto state_795;
	case Keyword::HLI: m_lexer.next(); goto state_797;
	case Keyword::IX: m_lexer.next(); goto state_799;
	case Keyword::IY: m_lexer.next(); goto state_803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HL
state_789:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_790;
	case TType::Plus: m_lexer.next(); goto state_792;
	case TType::RParen: m_lexer.next(); goto state_794;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HL Minus
state_790:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HL Minus RParen
state_791:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_261;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HL Plus
state_792:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_793;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HL Plus RParen
state_793:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_262;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_262;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HL RParen
state_794:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_263;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_263;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HLD
state_795:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_796;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HLD RParen
state_796:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_261;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HLI
state_797:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_798;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen HLI RParen
state_798:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_262;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_262;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen IX
state_799:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_800;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_801; }
	/*if (check_expr())*/ goto state_801;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen IX RParen
state_800:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_264;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_264;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen IX expr
state_801:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_802;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen IX expr RParen
state_802:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_265;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_265;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen IY
state_803:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_804;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_805; }
	/*if (check_expr())*/ goto state_805;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen IY RParen
state_804:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_266;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_266;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen IY expr
state_805:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_806;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD D Comma LParen IY expr RParen
state_806:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_267;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_267;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD DE
state_807:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_808;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD DE Comma
state_808:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_809; }
	/*if (check_expr())*/ goto state_809;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD DE Comma expr
state_809:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_268;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_268;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E
state_810:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_811;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma
state_811:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_812;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen
state_812:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_813;
	case Keyword::HLD: m_lexer.next(); goto state_819;
	case Keyword::HLI: m_lexer.next(); goto state_821;
	case Keyword::IX: m_lexer.next(); goto state_823;
	case Keyword::IY: m_lexer.next(); goto state_827;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HL
state_813:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_814;
	case TType::Plus: m_lexer.next(); goto state_816;
	case TType::RParen: m_lexer.next(); goto state_818;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HL Minus
state_814:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HL Minus RParen
state_815:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_269;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HL Plus
state_816:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_817;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HL Plus RParen
state_817:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_270;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HL RParen
state_818:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_271;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_271;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HLD
state_819:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_820;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HLD RParen
state_820:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_269;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HLI
state_821:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_822;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen HLI RParen
state_822:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_270;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen IX
state_823:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_824;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_825; }
	/*if (check_expr())*/ goto state_825;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen IX RParen
state_824:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_272;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_272;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen IX expr
state_825:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen IX expr RParen
state_826:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_273;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_273;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen IY
state_827:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_828;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_829; }
	/*if (check_expr())*/ goto state_829;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen IY RParen
state_828:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_274;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_274;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen IY expr
state_829:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_830;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD E Comma LParen IY expr RParen
state_830:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_275;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H
state_831:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_832;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma
state_832:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen
state_833:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_834;
	case Keyword::HLD: m_lexer.next(); goto state_840;
	case Keyword::HLI: m_lexer.next(); goto state_842;
	case Keyword::IX: m_lexer.next(); goto state_844;
	case Keyword::IY: m_lexer.next(); goto state_848;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HL
state_834:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_835;
	case TType::Plus: m_lexer.next(); goto state_837;
	case TType::RParen: m_lexer.next(); goto state_839;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HL Minus
state_835:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_836;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HL Minus RParen
state_836:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_276;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_276;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HL Plus
state_837:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HL Plus RParen
state_838:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_277;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_277;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HL RParen
state_839:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_278;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_278;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HLD
state_840:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HLD RParen
state_841:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_276;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_276;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HLI
state_842:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_843;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen HLI RParen
state_843:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_277;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_277;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen IX
state_844:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_845;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_846; }
	/*if (check_expr())*/ goto state_846;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen IX RParen
state_845:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_279;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_279;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen IX expr
state_846:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_847;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen IX expr RParen
state_847:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_280;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_280;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen IY
state_848:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_849;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_850; }
	/*if (check_expr())*/ goto state_850;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen IY RParen
state_849:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_281;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen IY expr
state_850:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_851;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD H Comma LParen IY expr RParen
state_851:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_282;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_282;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL
state_852:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_853;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma
state_853:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_854;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_867; }
	/*if (check_expr())*/ goto state_867;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen
state_854:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_855;
	case Keyword::IX: m_lexer.next(); goto state_859;
	case Keyword::IY: m_lexer.next(); goto state_863;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen HL
state_855:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_856;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_857; }
	/*if (check_expr())*/ goto state_857;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen HL RParen
state_856:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_283;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_283;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen HL expr
state_857:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_858;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen HL expr RParen
state_858:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_284;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_284;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen IX
state_859:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_860;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_861; }
	/*if (check_expr())*/ goto state_861;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen IX RParen
state_860:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_285;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_285;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen IX expr
state_861:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen IX expr RParen
state_862:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_286;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_286;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen IY
state_863:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_864;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_865; }
	/*if (check_expr())*/ goto state_865;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen IY RParen
state_864:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_287;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_287;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen IY expr
state_865:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma LParen IY expr RParen
state_866:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_288;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_288;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD HL Comma expr
state_867:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_289;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_289;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L
state_868:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_869;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma
state_869:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_870;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen
state_870:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_871;
	case Keyword::HLD: m_lexer.next(); goto state_877;
	case Keyword::HLI: m_lexer.next(); goto state_879;
	case Keyword::IX: m_lexer.next(); goto state_881;
	case Keyword::IY: m_lexer.next(); goto state_885;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HL
state_871:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_872;
	case TType::Plus: m_lexer.next(); goto state_874;
	case TType::RParen: m_lexer.next(); goto state_876;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HL Minus
state_872:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_873;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HL Minus RParen
state_873:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_290;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_290;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HL Plus
state_874:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_875;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HL Plus RParen
state_875:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_291;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_291;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HL RParen
state_876:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_292;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_292;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HLD
state_877:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_878;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HLD RParen
state_878:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_290;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_290;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HLI
state_879:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_880;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen HLI RParen
state_880:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_291;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_291;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen IX
state_881:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_882;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_883; }
	/*if (check_expr())*/ goto state_883;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen IX RParen
state_882:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_293;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_293;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen IX expr
state_883:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_884;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen IX expr RParen
state_884:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_294;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_294;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen IY
state_885:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_886;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_887; }
	/*if (check_expr())*/ goto state_887;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen IY RParen
state_886:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_295;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_295;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen IY expr
state_887:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE LD L Comma LParen IY expr RParen
state_888:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_296;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_296;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR
state_889:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_890;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A
state_890:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_891;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma
state_891:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen
state_892:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_893;
	case Keyword::IX: m_lexer.next(); goto state_899;
	case Keyword::IY: m_lexer.next(); goto state_903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen HL
state_893:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_894;
	case TType::Plus: m_lexer.next(); goto state_896;
	case TType::RParen: m_lexer.next(); goto state_898;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen HL Minus
state_894:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen HL Minus RParen
state_895:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_297;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_297;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen HL Plus
state_896:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_897;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen HL Plus RParen
state_897:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_298;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_298;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen HL RParen
state_898:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_299;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen IX
state_899:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_900;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_901; }
	/*if (check_expr())*/ goto state_901;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen IX RParen
state_900:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_300;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen IX expr
state_901:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen IX expr RParen
state_902:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_301;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_301;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen IY
state_903:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_904;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_905; }
	/*if (check_expr())*/ goto state_905;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen IY RParen
state_904:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_302;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_302;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen IY expr
state_905:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR A Comma LParen IY expr RParen
state_906:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_303;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen
state_907:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_908;
	case Keyword::IX: m_lexer.next(); goto state_914;
	case Keyword::IY: m_lexer.next(); goto state_918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen HL
state_908:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_909;
	case TType::Plus: m_lexer.next(); goto state_911;
	case TType::RParen: m_lexer.next(); goto state_913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen HL Minus
state_909:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen HL Minus RParen
state_910:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_297;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_297;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen HL Plus
state_911:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen HL Plus RParen
state_912:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_298;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_298;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen HL RParen
state_913:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_299;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen IX
state_914:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_915;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_916; }
	/*if (check_expr())*/ goto state_916;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen IX RParen
state_915:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_300;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen IX expr
state_916:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen IX expr RParen
state_917:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_301;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_301;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen IY
state_918:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_919;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_920; }
	/*if (check_expr())*/ goto state_920;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen IY RParen
state_919:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_302;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_302;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen IY expr
state_920:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_921;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE OR LParen IY expr RParen
state_921:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_303;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL
state_922:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen
state_923:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_924;
	case Keyword::IX: m_lexer.next(); goto state_926;
	case Keyword::IY: m_lexer.next(); goto state_930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen HL
state_924:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen HL RParen
state_925:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_304;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_304;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen IX
state_926:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_927;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_928; }
	/*if (check_expr())*/ goto state_928;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen IX RParen
state_927:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_305;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_305;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen IX expr
state_928:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_929;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen IX expr RParen
state_929:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_306;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_306;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen IY
state_930:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_931;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_932; }
	/*if (check_expr())*/ goto state_932;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen IY RParen
state_931:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_307;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen IY expr
state_932:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RL LParen IY expr RParen
state_933:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_308;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_308;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC
state_934:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen
state_935:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_936;
	case Keyword::IX: m_lexer.next(); goto state_938;
	case Keyword::IY: m_lexer.next(); goto state_942;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen HL
state_936:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_937;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen HL RParen
state_937:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_309;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_309;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen IX
state_938:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_939;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_940; }
	/*if (check_expr())*/ goto state_940;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen IX RParen
state_939:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_310;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_310;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen IX expr
state_940:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_941;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen IX expr RParen
state_941:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_311;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen IY
state_942:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_943;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_944; }
	/*if (check_expr())*/ goto state_944;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen IY RParen
state_943:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_312;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_312;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen IY expr
state_944:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_945;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RLC LParen IY expr RParen
state_945:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_313;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_313;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR
state_946:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_947;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen
state_947:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_948;
	case Keyword::IX: m_lexer.next(); goto state_950;
	case Keyword::IY: m_lexer.next(); goto state_954;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen HL
state_948:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_949;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen HL RParen
state_949:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_314;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_314;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen IX
state_950:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_951;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_952; }
	/*if (check_expr())*/ goto state_952;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen IX RParen
state_951:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_315;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen IX expr
state_952:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_953;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen IX expr RParen
state_953:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_316;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_316;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen IY
state_954:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_955;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_956; }
	/*if (check_expr())*/ goto state_956;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen IY RParen
state_955:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_317;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_317;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen IY expr
state_956:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_957;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RR LParen IY expr RParen
state_957:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_318;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_318;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC
state_958:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_959;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen
state_959:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_960;
	case Keyword::IX: m_lexer.next(); goto state_962;
	case Keyword::IY: m_lexer.next(); goto state_966;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen HL
state_960:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_961;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen HL RParen
state_961:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_319;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_319;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen IX
state_962:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_963;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_964; }
	/*if (check_expr())*/ goto state_964;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen IX RParen
state_963:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_320;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_320;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen IX expr
state_964:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_965;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen IX expr RParen
state_965:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_321;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_321;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen IY
state_966:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_967;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_968; }
	/*if (check_expr())*/ goto state_968;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen IY RParen
state_967:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_322;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_322;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen IY expr
state_968:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_969;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE RRC LParen IY expr RParen
state_969:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_323;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_323;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC
state_970:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_971;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_988;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A
state_971:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_972;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma
state_972:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_973;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen
state_973:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_974;
	case Keyword::IX: m_lexer.next(); goto state_980;
	case Keyword::IY: m_lexer.next(); goto state_984;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen HL
state_974:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_975;
	case TType::Plus: m_lexer.next(); goto state_977;
	case TType::RParen: m_lexer.next(); goto state_979;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen HL Minus
state_975:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_976;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen HL Minus RParen
state_976:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_324;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_324;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen HL Plus
state_977:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen HL Plus RParen
state_978:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_325;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_325;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen HL RParen
state_979:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_326;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_326;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen IX
state_980:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_981;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_982; }
	/*if (check_expr())*/ goto state_982;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen IX RParen
state_981:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_327;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_327;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen IX expr
state_982:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_983;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen IX expr RParen
state_983:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_328;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_328;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen IY
state_984:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_985;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_986; }
	/*if (check_expr())*/ goto state_986;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen IY RParen
state_985:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_329;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_329;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen IY expr
state_986:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_987;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC A Comma LParen IY expr RParen
state_987:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_330;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_330;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen
state_988:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_989;
	case Keyword::IX: m_lexer.next(); goto state_995;
	case Keyword::IY: m_lexer.next(); goto state_999;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen HL
state_989:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_990;
	case TType::Plus: m_lexer.next(); goto state_992;
	case TType::RParen: m_lexer.next(); goto state_994;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen HL Minus
state_990:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_991;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen HL Minus RParen
state_991:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_324;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_324;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen HL Plus
state_992:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_993;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen HL Plus RParen
state_993:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_325;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_325;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen HL RParen
state_994:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_326;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_326;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen IX
state_995:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_996;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_997; }
	/*if (check_expr())*/ goto state_997;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen IX RParen
state_996:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_327;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_327;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen IX expr
state_997:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_998;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen IX expr RParen
state_998:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_328;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_328;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen IY
state_999:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1000;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1001; }
	/*if (check_expr())*/ goto state_1001;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen IY RParen
state_1000:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_329;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_329;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen IY expr
state_1001:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1002;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SBC LParen IY expr RParen
state_1002:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_330;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_330;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA
state_1003:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1004;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen
state_1004:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1005;
	case Keyword::IX: m_lexer.next(); goto state_1007;
	case Keyword::IY: m_lexer.next(); goto state_1011;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen HL
state_1005:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1006;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen HL RParen
state_1006:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_331;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_331;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen IX
state_1007:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1008;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1009; }
	/*if (check_expr())*/ goto state_1009;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen IX RParen
state_1008:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_332;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_332;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen IX expr
state_1009:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1010;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen IX expr RParen
state_1010:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_333;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_333;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen IY
state_1011:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1012;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1013; }
	/*if (check_expr())*/ goto state_1013;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen IY RParen
state_1012:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_334;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_334;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen IY expr
state_1013:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1014;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SLA LParen IY expr RParen
state_1014:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_335;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_335;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA
state_1015:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1016;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen
state_1016:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1017;
	case Keyword::IX: m_lexer.next(); goto state_1019;
	case Keyword::IY: m_lexer.next(); goto state_1023;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen HL
state_1017:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1018;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen HL RParen
state_1018:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_336;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_336;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen IX
state_1019:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1020;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1021; }
	/*if (check_expr())*/ goto state_1021;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen IX RParen
state_1020:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_337;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_337;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen IX expr
state_1021:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1022;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen IX expr RParen
state_1022:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_338;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_338;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen IY
state_1023:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1024;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1025; }
	/*if (check_expr())*/ goto state_1025;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen IY RParen
state_1024:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_339;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_339;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen IY expr
state_1025:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1026;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRA LParen IY expr RParen
state_1026:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_340;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_340;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL
state_1027:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1028;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen
state_1028:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1029;
	case Keyword::IX: m_lexer.next(); goto state_1031;
	case Keyword::IY: m_lexer.next(); goto state_1035;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen HL
state_1029:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1030;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen HL RParen
state_1030:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_341;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_341;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen IX
state_1031:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1032;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1033; }
	/*if (check_expr())*/ goto state_1033;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen IX RParen
state_1032:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_342;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_342;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen IX expr
state_1033:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1034;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen IX expr RParen
state_1034:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_343;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_343;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen IY
state_1035:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1036;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1037; }
	/*if (check_expr())*/ goto state_1037;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen IY RParen
state_1036:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_344;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_344;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen IY expr
state_1037:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1038;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SRL LParen IY expr RParen
state_1038:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_345;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_345;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB
state_1039:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1040;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1057;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A
state_1040:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1041;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma
state_1041:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1042;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen
state_1042:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1043;
	case Keyword::IX: m_lexer.next(); goto state_1049;
	case Keyword::IY: m_lexer.next(); goto state_1053;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen HL
state_1043:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1044;
	case TType::Plus: m_lexer.next(); goto state_1046;
	case TType::RParen: m_lexer.next(); goto state_1048;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen HL Minus
state_1044:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1045;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen HL Minus RParen
state_1045:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_346;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_346;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen HL Plus
state_1046:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1047;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen HL Plus RParen
state_1047:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_347;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_347;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen HL RParen
state_1048:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_348;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen IX
state_1049:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1050;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1051; }
	/*if (check_expr())*/ goto state_1051;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen IX RParen
state_1050:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_349;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen IX expr
state_1051:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1052;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen IX expr RParen
state_1052:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_350;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_350;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen IY
state_1053:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1054;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1055; }
	/*if (check_expr())*/ goto state_1055;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen IY RParen
state_1054:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_351;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen IY expr
state_1055:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1056;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB A Comma LParen IY expr RParen
state_1056:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_352;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_352;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen
state_1057:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1058;
	case Keyword::IX: m_lexer.next(); goto state_1064;
	case Keyword::IY: m_lexer.next(); goto state_1068;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen HL
state_1058:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1059;
	case TType::Plus: m_lexer.next(); goto state_1061;
	case TType::RParen: m_lexer.next(); goto state_1063;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen HL Minus
state_1059:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1060;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen HL Minus RParen
state_1060:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_346;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_346;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen HL Plus
state_1061:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1062;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen HL Plus RParen
state_1062:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_347;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_347;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen HL RParen
state_1063:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_348;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen IX
state_1064:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1065;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1066; }
	/*if (check_expr())*/ goto state_1066;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen IX RParen
state_1065:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_349;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen IX expr
state_1066:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1067;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen IX expr RParen
state_1067:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_350;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_350;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen IY
state_1068:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1069;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1070; }
	/*if (check_expr())*/ goto state_1070;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen IY RParen
state_1069:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_351;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen IY expr
state_1070:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1071;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE SUB LParen IY expr RParen
state_1071:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_352;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_352;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR
state_1072:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1073;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1090;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A
state_1073:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1074;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma
state_1074:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen
state_1075:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1076;
	case Keyword::IX: m_lexer.next(); goto state_1082;
	case Keyword::IY: m_lexer.next(); goto state_1086;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen HL
state_1076:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1077;
	case TType::Plus: m_lexer.next(); goto state_1079;
	case TType::RParen: m_lexer.next(); goto state_1081;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen HL Minus
state_1077:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1078;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen HL Minus RParen
state_1078:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_353;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_353;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen HL Plus
state_1079:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1080;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen HL Plus RParen
state_1080:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_354;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_354;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen HL RParen
state_1081:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_355;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_355;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen IX
state_1082:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1083;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1084; }
	/*if (check_expr())*/ goto state_1084;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen IX RParen
state_1083:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_356;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_356;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen IX expr
state_1084:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen IX expr RParen
state_1085:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_357;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen IY
state_1086:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1087;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1088; }
	/*if (check_expr())*/ goto state_1088;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen IY RParen
state_1087:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_358;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen IY expr
state_1088:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1089;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR A Comma LParen IY expr RParen
state_1089:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_359;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen
state_1090:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1091;
	case Keyword::IX: m_lexer.next(); goto state_1097;
	case Keyword::IY: m_lexer.next(); goto state_1101;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen HL
state_1091:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1092;
	case TType::Plus: m_lexer.next(); goto state_1094;
	case TType::RParen: m_lexer.next(); goto state_1096;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen HL Minus
state_1092:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1093;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen HL Minus RParen
state_1093:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_353;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_353;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen HL Plus
state_1094:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1095;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen HL Plus RParen
state_1095:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_354;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_354;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen HL RParen
state_1096:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_355;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_355;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen IX
state_1097:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1098;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1099; }
	/*if (check_expr())*/ goto state_1099;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen IX RParen
state_1098:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_356;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_356;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen IX expr
state_1099:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen IX expr RParen
state_1100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_357;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen IY
state_1101:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1102;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1103; }
	/*if (check_expr())*/ goto state_1103;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen IY RParen
state_1102:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_358;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen IY expr
state_1103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOE XOR LParen IY expr RParen
state_1104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_359;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI
state_1105:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::ADC: m_lexer.next(); goto state_1106;
	case Keyword::ADD: m_lexer.next(); goto state_1139;
	case Keyword::AND: m_lexer.next(); goto state_1172;
	case Keyword::BIT: m_lexer.next(); goto state_1205;
	case Keyword::CP: m_lexer.next(); goto state_1219;
	case Keyword::DEC: m_lexer.next(); goto state_1252;
	case Keyword::INC: m_lexer.next(); goto state_1268;
	case Keyword::LD: m_lexer.next(); goto state_1284;
	case Keyword::OR: m_lexer.next(); goto state_1467;
	case Keyword::RL: m_lexer.next(); goto state_1500;
	case Keyword::RLC: m_lexer.next(); goto state_1512;
	case Keyword::RR: m_lexer.next(); goto state_1524;
	case Keyword::RRC: m_lexer.next(); goto state_1536;
	case Keyword::SBC: m_lexer.next(); goto state_1548;
	case Keyword::SLA: m_lexer.next(); goto state_1581;
	case Keyword::SRA: m_lexer.next(); goto state_1593;
	case Keyword::SRL: m_lexer.next(); goto state_1605;
	case Keyword::SUB: m_lexer.next(); goto state_1617;
	case Keyword::XOR: m_lexer.next(); goto state_1650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC
state_1106:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1107;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1124;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A
state_1107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma
state_1108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen
state_1109:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1110;
	case Keyword::IX: m_lexer.next(); goto state_1116;
	case Keyword::IY: m_lexer.next(); goto state_1120;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen HL
state_1110:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1111;
	case TType::Plus: m_lexer.next(); goto state_1113;
	case TType::RParen: m_lexer.next(); goto state_1115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen HL Minus
state_1111:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1112;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen HL Minus RParen
state_1112:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_360;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_360;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen HL Plus
state_1113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen HL Plus RParen
state_1114:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_361;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_361;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen HL RParen
state_1115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_362;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_362;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen IX
state_1116:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1117;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1118; }
	/*if (check_expr())*/ goto state_1118;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen IX RParen
state_1117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_363;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen IX expr
state_1118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1119;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen IX expr RParen
state_1119:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_364;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_364;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen IY
state_1120:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1121;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1122; }
	/*if (check_expr())*/ goto state_1122;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen IY RParen
state_1121:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_365;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_365;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen IY expr
state_1122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1123;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC A Comma LParen IY expr RParen
state_1123:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_366;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_366;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen
state_1124:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1125;
	case Keyword::IX: m_lexer.next(); goto state_1131;
	case Keyword::IY: m_lexer.next(); goto state_1135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen HL
state_1125:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1126;
	case TType::Plus: m_lexer.next(); goto state_1128;
	case TType::RParen: m_lexer.next(); goto state_1130;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen HL Minus
state_1126:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1127;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen HL Minus RParen
state_1127:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_360;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_360;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen HL Plus
state_1128:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen HL Plus RParen
state_1129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_361;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_361;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen HL RParen
state_1130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_362;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_362;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen IX
state_1131:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1132;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1133; }
	/*if (check_expr())*/ goto state_1133;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen IX RParen
state_1132:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_363;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen IX expr
state_1133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1134;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen IX expr RParen
state_1134:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_364;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_364;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen IY
state_1135:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1136;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1137; }
	/*if (check_expr())*/ goto state_1137;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen IY RParen
state_1136:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_365;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_365;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen IY expr
state_1137:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADC LParen IY expr RParen
state_1138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_366;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_366;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD
state_1139:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1140;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1157;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A
state_1140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma
state_1141:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1142;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen
state_1142:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1143;
	case Keyword::IX: m_lexer.next(); goto state_1149;
	case Keyword::IY: m_lexer.next(); goto state_1153;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen HL
state_1143:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1144;
	case TType::Plus: m_lexer.next(); goto state_1146;
	case TType::RParen: m_lexer.next(); goto state_1148;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen HL Minus
state_1144:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1145;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen HL Minus RParen
state_1145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_367;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_367;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen HL Plus
state_1146:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen HL Plus RParen
state_1147:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_368;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_368;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen HL RParen
state_1148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_369;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_369;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen IX
state_1149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1150;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1151; }
	/*if (check_expr())*/ goto state_1151;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen IX RParen
state_1150:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_370;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_370;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen IX expr
state_1151:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen IX expr RParen
state_1152:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_371;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_371;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen IY
state_1153:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1154;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1155; }
	/*if (check_expr())*/ goto state_1155;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen IY RParen
state_1154:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_372;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_372;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen IY expr
state_1155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1156;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD A Comma LParen IY expr RParen
state_1156:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_373;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_373;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen
state_1157:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1158;
	case Keyword::IX: m_lexer.next(); goto state_1164;
	case Keyword::IY: m_lexer.next(); goto state_1168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen HL
state_1158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1159;
	case TType::Plus: m_lexer.next(); goto state_1161;
	case TType::RParen: m_lexer.next(); goto state_1163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen HL Minus
state_1159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1160;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen HL Minus RParen
state_1160:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_367;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_367;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen HL Plus
state_1161:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen HL Plus RParen
state_1162:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_368;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_368;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen HL RParen
state_1163:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_369;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_369;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen IX
state_1164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1165;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1166; }
	/*if (check_expr())*/ goto state_1166;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen IX RParen
state_1165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_370;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_370;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen IX expr
state_1166:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen IX expr RParen
state_1167:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_371;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_371;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen IY
state_1168:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1169;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1170; }
	/*if (check_expr())*/ goto state_1170;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen IY RParen
state_1169:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_372;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_372;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen IY expr
state_1170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1171;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI ADD LParen IY expr RParen
state_1171:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_373;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_373;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND
state_1172:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1173;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A
state_1173:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1174;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma
state_1174:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1175;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen
state_1175:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1176;
	case Keyword::IX: m_lexer.next(); goto state_1182;
	case Keyword::IY: m_lexer.next(); goto state_1186;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen HL
state_1176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1177;
	case TType::Plus: m_lexer.next(); goto state_1179;
	case TType::RParen: m_lexer.next(); goto state_1181;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen HL Minus
state_1177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1178;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen HL Minus RParen
state_1178:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_374;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_374;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen HL Plus
state_1179:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1180;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen HL Plus RParen
state_1180:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_375;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_375;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen HL RParen
state_1181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_376;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_376;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen IX
state_1182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1183;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1184; }
	/*if (check_expr())*/ goto state_1184;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen IX RParen
state_1183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_377;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_377;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen IX expr
state_1184:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen IX expr RParen
state_1185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_378;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_378;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen IY
state_1186:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1187;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1188; }
	/*if (check_expr())*/ goto state_1188;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen IY RParen
state_1187:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_379;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_379;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen IY expr
state_1188:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND A Comma LParen IY expr RParen
state_1189:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_380;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_380;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen
state_1190:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1191;
	case Keyword::IX: m_lexer.next(); goto state_1197;
	case Keyword::IY: m_lexer.next(); goto state_1201;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen HL
state_1191:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1192;
	case TType::Plus: m_lexer.next(); goto state_1194;
	case TType::RParen: m_lexer.next(); goto state_1196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen HL Minus
state_1192:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1193;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen HL Minus RParen
state_1193:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_374;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_374;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen HL Plus
state_1194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen HL Plus RParen
state_1195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_375;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_375;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen HL RParen
state_1196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_376;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_376;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen IX
state_1197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1198;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1199; }
	/*if (check_expr())*/ goto state_1199;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen IX RParen
state_1198:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_377;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_377;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen IX expr
state_1199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen IX expr RParen
state_1200:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_378;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_378;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen IY
state_1201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1202;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1203; }
	/*if (check_expr())*/ goto state_1203;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen IY RParen
state_1202:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_379;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_379;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen IY expr
state_1203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1204;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI AND LParen IY expr RParen
state_1204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_380;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_380;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT
state_1205:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1206; }
	/*if (check_const_expr())*/ goto state_1206;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr
state_1206:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1207;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma
state_1207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1208;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen
state_1208:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1209;
	case Keyword::IX: m_lexer.next(); goto state_1211;
	case Keyword::IY: m_lexer.next(); goto state_1215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen HL
state_1209:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen HL RParen
state_1210:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_381;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_381;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen IX
state_1211:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1212;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1213; }
	/*if (check_expr())*/ goto state_1213;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen IX RParen
state_1212:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_382;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_382;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen IX expr
state_1213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen IX expr RParen
state_1214:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_383;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_383;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen IY
state_1215:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1216;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1217; }
	/*if (check_expr())*/ goto state_1217;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen IY RParen
state_1216:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_384;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_384;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen IY expr
state_1217:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1218;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI BIT const_expr Comma LParen IY expr RParen
state_1218:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_385;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_385;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP
state_1219:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1220;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1237;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A
state_1220:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1221;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma
state_1221:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1222;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen
state_1222:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1223;
	case Keyword::IX: m_lexer.next(); goto state_1229;
	case Keyword::IY: m_lexer.next(); goto state_1233;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen HL
state_1223:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1224;
	case TType::Plus: m_lexer.next(); goto state_1226;
	case TType::RParen: m_lexer.next(); goto state_1228;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen HL Minus
state_1224:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1225;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen HL Minus RParen
state_1225:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_386;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_386;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen HL Plus
state_1226:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1227;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen HL Plus RParen
state_1227:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_387;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_387;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen HL RParen
state_1228:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_388;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_388;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen IX
state_1229:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1230;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1231; }
	/*if (check_expr())*/ goto state_1231;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen IX RParen
state_1230:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_389;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_389;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen IX expr
state_1231:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1232;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen IX expr RParen
state_1232:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_390;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_390;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen IY
state_1233:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1234;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1235; }
	/*if (check_expr())*/ goto state_1235;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen IY RParen
state_1234:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_391;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_391;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen IY expr
state_1235:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1236;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP A Comma LParen IY expr RParen
state_1236:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_392;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_392;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen
state_1237:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1238;
	case Keyword::IX: m_lexer.next(); goto state_1244;
	case Keyword::IY: m_lexer.next(); goto state_1248;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen HL
state_1238:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1239;
	case TType::Plus: m_lexer.next(); goto state_1241;
	case TType::RParen: m_lexer.next(); goto state_1243;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen HL Minus
state_1239:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1240;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen HL Minus RParen
state_1240:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_386;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_386;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen HL Plus
state_1241:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1242;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen HL Plus RParen
state_1242:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_387;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_387;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen HL RParen
state_1243:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_388;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_388;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen IX
state_1244:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1245;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1246; }
	/*if (check_expr())*/ goto state_1246;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen IX RParen
state_1245:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_389;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_389;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen IX expr
state_1246:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1247;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen IX expr RParen
state_1247:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_390;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_390;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen IY
state_1248:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1249;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1250; }
	/*if (check_expr())*/ goto state_1250;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen IY RParen
state_1249:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_391;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_391;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen IY expr
state_1250:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1251;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI CP LParen IY expr RParen
state_1251:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_392;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_392;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC
state_1252:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1253;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen
state_1253:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1254;
	case Keyword::IX: m_lexer.next(); goto state_1260;
	case Keyword::IY: m_lexer.next(); goto state_1264;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen HL
state_1254:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1255;
	case TType::Plus: m_lexer.next(); goto state_1257;
	case TType::RParen: m_lexer.next(); goto state_1259;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen HL Minus
state_1255:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1256;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen HL Minus RParen
state_1256:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_393;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_393;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen HL Plus
state_1257:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1258;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen HL Plus RParen
state_1258:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_394;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_394;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen HL RParen
state_1259:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_395;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_395;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen IX
state_1260:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1261;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1262; }
	/*if (check_expr())*/ goto state_1262;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen IX RParen
state_1261:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_396;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_396;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen IX expr
state_1262:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1263;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen IX expr RParen
state_1263:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_397;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_397;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen IY
state_1264:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1265;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1266; }
	/*if (check_expr())*/ goto state_1266;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen IY RParen
state_1265:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_398;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_398;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen IY expr
state_1266:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1267;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI DEC LParen IY expr RParen
state_1267:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_399;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_399;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC
state_1268:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen
state_1269:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1270;
	case Keyword::IX: m_lexer.next(); goto state_1276;
	case Keyword::IY: m_lexer.next(); goto state_1280;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen HL
state_1270:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1271;
	case TType::Plus: m_lexer.next(); goto state_1273;
	case TType::RParen: m_lexer.next(); goto state_1275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen HL Minus
state_1271:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1272;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen HL Minus RParen
state_1272:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_400;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen HL Plus
state_1273:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1274;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen HL Plus RParen
state_1274:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_401;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_401;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen HL RParen
state_1275:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_402;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_402;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen IX
state_1276:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1277;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1278; }
	/*if (check_expr())*/ goto state_1278;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen IX RParen
state_1277:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_403;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_403;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen IX expr
state_1278:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1279;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen IX expr RParen
state_1279:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_404;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_404;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen IY
state_1280:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1281;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1282; }
	/*if (check_expr())*/ goto state_1282;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen IY RParen
state_1281:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_405;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_405;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen IY expr
state_1282:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1283;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI INC LParen IY expr RParen
state_1283:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_406;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_406;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD
state_1284:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1285;
	case Keyword::B: m_lexer.next(); goto state_1319;
	case Keyword::BC: m_lexer.next(); goto state_1340;
	case Keyword::C: m_lexer.next(); goto state_1343;
	case Keyword::D: m_lexer.next(); goto state_1364;
	case Keyword::DE: m_lexer.next(); goto state_1385;
	case Keyword::E: m_lexer.next(); goto state_1388;
	case Keyword::H: m_lexer.next(); goto state_1409;
	case Keyword::HL: m_lexer.next(); goto state_1430;
	case Keyword::L: m_lexer.next(); goto state_1446;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A
state_1285:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1286;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma
state_1286:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1287;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1318; }
	/*if (check_expr())*/ goto state_1318;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen
state_1287:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_1288;
	case Keyword::DE: m_lexer.next(); goto state_1294;
	case Keyword::HL: m_lexer.next(); goto state_1300;
	case Keyword::HLD: m_lexer.next(); goto state_1306;
	case Keyword::HLI: m_lexer.next(); goto state_1308;
	case Keyword::IX: m_lexer.next(); goto state_1310;
	case Keyword::IY: m_lexer.next(); goto state_1314;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen BC
state_1288:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1289;
	case TType::Plus: m_lexer.next(); goto state_1291;
	case TType::RParen: m_lexer.next(); goto state_1293;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen BC Minus
state_1289:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1290;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen BC Minus RParen
state_1290:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_407;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_407;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen BC Plus
state_1291:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1292;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen BC Plus RParen
state_1292:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_408;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_408;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen BC RParen
state_1293:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_409;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_409;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen DE
state_1294:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1295;
	case TType::Plus: m_lexer.next(); goto state_1297;
	case TType::RParen: m_lexer.next(); goto state_1299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen DE Minus
state_1295:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1296;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen DE Minus RParen
state_1296:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_410;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_410;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen DE Plus
state_1297:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1298;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen DE Plus RParen
state_1298:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_411;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_411;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen DE RParen
state_1299:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_412;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_412;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HL
state_1300:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1301;
	case TType::Plus: m_lexer.next(); goto state_1303;
	case TType::RParen: m_lexer.next(); goto state_1305;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HL Minus
state_1301:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1302;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HL Minus RParen
state_1302:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_413;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_413;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HL Plus
state_1303:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1304;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HL Plus RParen
state_1304:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_414;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_414;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HL RParen
state_1305:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_415;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_415;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HLD
state_1306:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HLD RParen
state_1307:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_413;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_413;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HLI
state_1308:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1309;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen HLI RParen
state_1309:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_414;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_414;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen IX
state_1310:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1311;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1312; }
	/*if (check_expr())*/ goto state_1312;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen IX RParen
state_1311:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_416;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_416;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen IX expr
state_1312:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1313;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen IX expr RParen
state_1313:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_417;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen IY
state_1314:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1315;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1316; }
	/*if (check_expr())*/ goto state_1316;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen IY RParen
state_1315:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_418;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_418;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen IY expr
state_1316:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1317;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma LParen IY expr RParen
state_1317:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_419;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_419;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD A Comma expr
state_1318:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_420;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_420;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B
state_1319:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1320;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma
state_1320:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1321;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen
state_1321:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1322;
	case Keyword::HLD: m_lexer.next(); goto state_1328;
	case Keyword::HLI: m_lexer.next(); goto state_1330;
	case Keyword::IX: m_lexer.next(); goto state_1332;
	case Keyword::IY: m_lexer.next(); goto state_1336;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HL
state_1322:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1323;
	case TType::Plus: m_lexer.next(); goto state_1325;
	case TType::RParen: m_lexer.next(); goto state_1327;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HL Minus
state_1323:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1324;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HL Minus RParen
state_1324:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_421;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HL Plus
state_1325:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1326;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HL Plus RParen
state_1326:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_422;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_422;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HL RParen
state_1327:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_423;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_423;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HLD
state_1328:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1329;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HLD RParen
state_1329:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_421;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HLI
state_1330:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1331;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen HLI RParen
state_1331:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_422;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_422;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen IX
state_1332:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1333;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1334; }
	/*if (check_expr())*/ goto state_1334;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen IX RParen
state_1333:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_424;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_424;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen IX expr
state_1334:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1335;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen IX expr RParen
state_1335:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_425;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_425;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen IY
state_1336:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1337;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1338; }
	/*if (check_expr())*/ goto state_1338;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen IY RParen
state_1337:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_426;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_426;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen IY expr
state_1338:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1339;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD B Comma LParen IY expr RParen
state_1339:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_427;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_427;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD BC
state_1340:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1341;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD BC Comma
state_1341:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1342; }
	/*if (check_expr())*/ goto state_1342;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD BC Comma expr
state_1342:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_428;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_428;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C
state_1343:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1344;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma
state_1344:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1345;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen
state_1345:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1346;
	case Keyword::HLD: m_lexer.next(); goto state_1352;
	case Keyword::HLI: m_lexer.next(); goto state_1354;
	case Keyword::IX: m_lexer.next(); goto state_1356;
	case Keyword::IY: m_lexer.next(); goto state_1360;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HL
state_1346:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1347;
	case TType::Plus: m_lexer.next(); goto state_1349;
	case TType::RParen: m_lexer.next(); goto state_1351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HL Minus
state_1347:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HL Minus RParen
state_1348:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_429;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_429;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HL Plus
state_1349:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1350;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HL Plus RParen
state_1350:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_430;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_430;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HL RParen
state_1351:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_431;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_431;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HLD
state_1352:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1353;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HLD RParen
state_1353:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_429;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_429;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HLI
state_1354:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1355;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen HLI RParen
state_1355:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_430;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_430;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen IX
state_1356:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1357;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1358; }
	/*if (check_expr())*/ goto state_1358;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen IX RParen
state_1357:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_432;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_432;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen IX expr
state_1358:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen IX expr RParen
state_1359:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_433;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_433;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen IY
state_1360:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1361;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1362; }
	/*if (check_expr())*/ goto state_1362;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen IY RParen
state_1361:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_434;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_434;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen IY expr
state_1362:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD C Comma LParen IY expr RParen
state_1363:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_435;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_435;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D
state_1364:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1365;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma
state_1365:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1366;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen
state_1366:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1367;
	case Keyword::HLD: m_lexer.next(); goto state_1373;
	case Keyword::HLI: m_lexer.next(); goto state_1375;
	case Keyword::IX: m_lexer.next(); goto state_1377;
	case Keyword::IY: m_lexer.next(); goto state_1381;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HL
state_1367:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1368;
	case TType::Plus: m_lexer.next(); goto state_1370;
	case TType::RParen: m_lexer.next(); goto state_1372;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HL Minus
state_1368:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1369;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HL Minus RParen
state_1369:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_436;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_436;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HL Plus
state_1370:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1371;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HL Plus RParen
state_1371:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_437;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_437;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HL RParen
state_1372:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_438;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_438;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HLD
state_1373:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1374;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HLD RParen
state_1374:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_436;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_436;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HLI
state_1375:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1376;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen HLI RParen
state_1376:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_437;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_437;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen IX
state_1377:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1378;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1379; }
	/*if (check_expr())*/ goto state_1379;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen IX RParen
state_1378:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_439;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_439;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen IX expr
state_1379:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1380;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen IX expr RParen
state_1380:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_440;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_440;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen IY
state_1381:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1382;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1383; }
	/*if (check_expr())*/ goto state_1383;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen IY RParen
state_1382:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_441;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_441;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen IY expr
state_1383:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1384;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD D Comma LParen IY expr RParen
state_1384:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_442;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_442;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD DE
state_1385:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1386;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD DE Comma
state_1386:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1387; }
	/*if (check_expr())*/ goto state_1387;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD DE Comma expr
state_1387:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_443;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_443;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E
state_1388:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1389;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma
state_1389:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1390;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen
state_1390:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1391;
	case Keyword::HLD: m_lexer.next(); goto state_1397;
	case Keyword::HLI: m_lexer.next(); goto state_1399;
	case Keyword::IX: m_lexer.next(); goto state_1401;
	case Keyword::IY: m_lexer.next(); goto state_1405;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HL
state_1391:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1392;
	case TType::Plus: m_lexer.next(); goto state_1394;
	case TType::RParen: m_lexer.next(); goto state_1396;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HL Minus
state_1392:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1393;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HL Minus RParen
state_1393:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_444;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_444;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HL Plus
state_1394:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1395;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HL Plus RParen
state_1395:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_445;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_445;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HL RParen
state_1396:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_446;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_446;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HLD
state_1397:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1398;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HLD RParen
state_1398:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_444;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_444;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HLI
state_1399:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen HLI RParen
state_1400:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_445;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_445;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen IX
state_1401:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1402;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1403; }
	/*if (check_expr())*/ goto state_1403;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen IX RParen
state_1402:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_447;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_447;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen IX expr
state_1403:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1404;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen IX expr RParen
state_1404:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_448;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_448;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen IY
state_1405:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1406;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1407; }
	/*if (check_expr())*/ goto state_1407;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen IY RParen
state_1406:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_449;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_449;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen IY expr
state_1407:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1408;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD E Comma LParen IY expr RParen
state_1408:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_450;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_450;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H
state_1409:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1410;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma
state_1410:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1411;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen
state_1411:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1412;
	case Keyword::HLD: m_lexer.next(); goto state_1418;
	case Keyword::HLI: m_lexer.next(); goto state_1420;
	case Keyword::IX: m_lexer.next(); goto state_1422;
	case Keyword::IY: m_lexer.next(); goto state_1426;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HL
state_1412:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1413;
	case TType::Plus: m_lexer.next(); goto state_1415;
	case TType::RParen: m_lexer.next(); goto state_1417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HL Minus
state_1413:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1414;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HL Minus RParen
state_1414:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_451;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HL Plus
state_1415:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1416;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HL Plus RParen
state_1416:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_452;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_452;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HL RParen
state_1417:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_453;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_453;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HLD
state_1418:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1419;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HLD RParen
state_1419:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_451;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HLI
state_1420:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen HLI RParen
state_1421:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_452;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_452;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen IX
state_1422:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1423;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1424; }
	/*if (check_expr())*/ goto state_1424;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen IX RParen
state_1423:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_454;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen IX expr
state_1424:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1425;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen IX expr RParen
state_1425:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_455;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_455;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen IY
state_1426:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1427;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1428; }
	/*if (check_expr())*/ goto state_1428;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen IY RParen
state_1427:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_456;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_456;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen IY expr
state_1428:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1429;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD H Comma LParen IY expr RParen
state_1429:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_457;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_457;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL
state_1430:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1431;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma
state_1431:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1432;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1445; }
	/*if (check_expr())*/ goto state_1445;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen
state_1432:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1433;
	case Keyword::IX: m_lexer.next(); goto state_1437;
	case Keyword::IY: m_lexer.next(); goto state_1441;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen HL
state_1433:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1434;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1435; }
	/*if (check_expr())*/ goto state_1435;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen HL RParen
state_1434:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_458;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_458;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen HL expr
state_1435:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1436;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen HL expr RParen
state_1436:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_459;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_459;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen IX
state_1437:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1438;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1439; }
	/*if (check_expr())*/ goto state_1439;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen IX RParen
state_1438:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_460;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_460;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen IX expr
state_1439:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1440;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen IX expr RParen
state_1440:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_461;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen IY
state_1441:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1442;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1443; }
	/*if (check_expr())*/ goto state_1443;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen IY RParen
state_1442:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_462;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_462;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen IY expr
state_1443:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1444;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma LParen IY expr RParen
state_1444:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_463;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD HL Comma expr
state_1445:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_464;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L
state_1446:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1447;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma
state_1447:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1448;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen
state_1448:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1449;
	case Keyword::HLD: m_lexer.next(); goto state_1455;
	case Keyword::HLI: m_lexer.next(); goto state_1457;
	case Keyword::IX: m_lexer.next(); goto state_1459;
	case Keyword::IY: m_lexer.next(); goto state_1463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HL
state_1449:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1450;
	case TType::Plus: m_lexer.next(); goto state_1452;
	case TType::RParen: m_lexer.next(); goto state_1454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HL Minus
state_1450:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HL Minus RParen
state_1451:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_465;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HL Plus
state_1452:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1453;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HL Plus RParen
state_1453:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HL RParen
state_1454:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_467;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HLD
state_1455:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1456;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HLD RParen
state_1456:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_465;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HLI
state_1457:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1458;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen HLI RParen
state_1458:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen IX
state_1459:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1460;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1461; }
	/*if (check_expr())*/ goto state_1461;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen IX RParen
state_1460:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_468;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_468;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen IX expr
state_1461:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1462;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen IX expr RParen
state_1462:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_469;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen IY
state_1463:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1464;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1465; }
	/*if (check_expr())*/ goto state_1465;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen IY RParen
state_1464:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_470;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen IY expr
state_1465:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI LD L Comma LParen IY expr RParen
state_1466:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_471;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_471;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR
state_1467:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1468;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1485;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A
state_1468:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma
state_1469:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen
state_1470:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1471;
	case Keyword::IX: m_lexer.next(); goto state_1477;
	case Keyword::IY: m_lexer.next(); goto state_1481;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen HL
state_1471:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1472;
	case TType::Plus: m_lexer.next(); goto state_1474;
	case TType::RParen: m_lexer.next(); goto state_1476;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen HL Minus
state_1472:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1473;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen HL Minus RParen
state_1473:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_472;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_472;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen HL Plus
state_1474:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen HL Plus RParen
state_1475:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_473;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_473;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen HL RParen
state_1476:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_474;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_474;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen IX
state_1477:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1478;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1479; }
	/*if (check_expr())*/ goto state_1479;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen IX RParen
state_1478:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_475;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen IX expr
state_1479:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1480;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen IX expr RParen
state_1480:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_476;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_476;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen IY
state_1481:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1482;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1483; }
	/*if (check_expr())*/ goto state_1483;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen IY RParen
state_1482:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_477;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_477;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen IY expr
state_1483:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1484;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR A Comma LParen IY expr RParen
state_1484:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_478;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen
state_1485:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1486;
	case Keyword::IX: m_lexer.next(); goto state_1492;
	case Keyword::IY: m_lexer.next(); goto state_1496;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen HL
state_1486:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1487;
	case TType::Plus: m_lexer.next(); goto state_1489;
	case TType::RParen: m_lexer.next(); goto state_1491;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen HL Minus
state_1487:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen HL Minus RParen
state_1488:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_472;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_472;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen HL Plus
state_1489:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1490;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen HL Plus RParen
state_1490:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_473;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_473;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen HL RParen
state_1491:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_474;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_474;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen IX
state_1492:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1493;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1494; }
	/*if (check_expr())*/ goto state_1494;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen IX RParen
state_1493:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_475;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen IX expr
state_1494:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1495;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen IX expr RParen
state_1495:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_476;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_476;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen IY
state_1496:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1497;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1498; }
	/*if (check_expr())*/ goto state_1498;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen IY RParen
state_1497:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_477;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_477;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen IY expr
state_1498:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1499;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI OR LParen IY expr RParen
state_1499:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_478;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL
state_1500:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1501;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen
state_1501:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1502;
	case Keyword::IX: m_lexer.next(); goto state_1504;
	case Keyword::IY: m_lexer.next(); goto state_1508;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen HL
state_1502:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1503;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen HL RParen
state_1503:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_479;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_479;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen IX
state_1504:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1505;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1506; }
	/*if (check_expr())*/ goto state_1506;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen IX RParen
state_1505:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_480;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_480;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen IX expr
state_1506:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1507;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen IX expr RParen
state_1507:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_481;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_481;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen IY
state_1508:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1509;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1510; }
	/*if (check_expr())*/ goto state_1510;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen IY RParen
state_1509:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_482;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen IY expr
state_1510:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1511;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RL LParen IY expr RParen
state_1511:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_483;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_483;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC
state_1512:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1513;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen
state_1513:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1514;
	case Keyword::IX: m_lexer.next(); goto state_1516;
	case Keyword::IY: m_lexer.next(); goto state_1520;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen HL
state_1514:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1515;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen HL RParen
state_1515:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_484;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_484;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen IX
state_1516:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1517;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1518; }
	/*if (check_expr())*/ goto state_1518;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen IX RParen
state_1517:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_485;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_485;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen IX expr
state_1518:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1519;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen IX expr RParen
state_1519:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_486;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen IY
state_1520:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1521;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1522; }
	/*if (check_expr())*/ goto state_1522;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen IY RParen
state_1521:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_487;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_487;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen IY expr
state_1522:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RLC LParen IY expr RParen
state_1523:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_488;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR
state_1524:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen
state_1525:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1526;
	case Keyword::IX: m_lexer.next(); goto state_1528;
	case Keyword::IY: m_lexer.next(); goto state_1532;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen HL
state_1526:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1527;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen HL RParen
state_1527:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_489;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_489;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen IX
state_1528:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1529;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1530; }
	/*if (check_expr())*/ goto state_1530;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen IX RParen
state_1529:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_490;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_490;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen IX expr
state_1530:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen IX expr RParen
state_1531:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_491;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_491;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen IY
state_1532:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1533;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1534; }
	/*if (check_expr())*/ goto state_1534;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen IY RParen
state_1533:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_492;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_492;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen IY expr
state_1534:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1535;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RR LParen IY expr RParen
state_1535:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_493;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_493;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC
state_1536:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1537;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen
state_1537:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1538;
	case Keyword::IX: m_lexer.next(); goto state_1540;
	case Keyword::IY: m_lexer.next(); goto state_1544;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen HL
state_1538:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1539;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen HL RParen
state_1539:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_494;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_494;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen IX
state_1540:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1541;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1542; }
	/*if (check_expr())*/ goto state_1542;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen IX RParen
state_1541:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_495;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_495;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen IX expr
state_1542:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen IX expr RParen
state_1543:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_496;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_496;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen IY
state_1544:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1545;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1546; }
	/*if (check_expr())*/ goto state_1546;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen IY RParen
state_1545:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_497;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_497;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen IY expr
state_1546:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1547;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI RRC LParen IY expr RParen
state_1547:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_498;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_498;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC
state_1548:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1549;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1566;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A
state_1549:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1550;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma
state_1550:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1551;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen
state_1551:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1552;
	case Keyword::IX: m_lexer.next(); goto state_1558;
	case Keyword::IY: m_lexer.next(); goto state_1562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen HL
state_1552:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1553;
	case TType::Plus: m_lexer.next(); goto state_1555;
	case TType::RParen: m_lexer.next(); goto state_1557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen HL Minus
state_1553:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1554;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen HL Minus RParen
state_1554:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_499;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_499;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen HL Plus
state_1555:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen HL Plus RParen
state_1556:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_500;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen HL RParen
state_1557:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_501;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_501;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen IX
state_1558:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1559;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1560; }
	/*if (check_expr())*/ goto state_1560;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen IX RParen
state_1559:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_502;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_502;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen IX expr
state_1560:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1561;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen IX expr RParen
state_1561:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_503;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_503;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen IY
state_1562:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1563;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1564; }
	/*if (check_expr())*/ goto state_1564;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen IY RParen
state_1563:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_504;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_504;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen IY expr
state_1564:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1565;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC A Comma LParen IY expr RParen
state_1565:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_505;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_505;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen
state_1566:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1567;
	case Keyword::IX: m_lexer.next(); goto state_1573;
	case Keyword::IY: m_lexer.next(); goto state_1577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen HL
state_1567:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1568;
	case TType::Plus: m_lexer.next(); goto state_1570;
	case TType::RParen: m_lexer.next(); goto state_1572;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen HL Minus
state_1568:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1569;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen HL Minus RParen
state_1569:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_499;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_499;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen HL Plus
state_1570:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1571;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen HL Plus RParen
state_1571:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_500;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen HL RParen
state_1572:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_501;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_501;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen IX
state_1573:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1574;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1575; }
	/*if (check_expr())*/ goto state_1575;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen IX RParen
state_1574:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_502;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_502;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen IX expr
state_1575:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen IX expr RParen
state_1576:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_503;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_503;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen IY
state_1577:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1578;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1579; }
	/*if (check_expr())*/ goto state_1579;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen IY RParen
state_1578:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_504;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_504;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen IY expr
state_1579:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SBC LParen IY expr RParen
state_1580:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_505;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_505;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA
state_1581:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen
state_1582:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1583;
	case Keyword::IX: m_lexer.next(); goto state_1585;
	case Keyword::IY: m_lexer.next(); goto state_1589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen HL
state_1583:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen HL RParen
state_1584:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_506;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_506;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen IX
state_1585:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1586;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1587; }
	/*if (check_expr())*/ goto state_1587;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen IX RParen
state_1586:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_507;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_507;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen IX expr
state_1587:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1588;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen IX expr RParen
state_1588:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_508;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_508;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen IY
state_1589:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1590;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1591; }
	/*if (check_expr())*/ goto state_1591;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen IY RParen
state_1590:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_509;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_509;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen IY expr
state_1591:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1592;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SLA LParen IY expr RParen
state_1592:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_510;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_510;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA
state_1593:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1594;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen
state_1594:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1595;
	case Keyword::IX: m_lexer.next(); goto state_1597;
	case Keyword::IY: m_lexer.next(); goto state_1601;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen HL
state_1595:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1596;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen HL RParen
state_1596:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_511;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_511;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen IX
state_1597:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1598;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1599; }
	/*if (check_expr())*/ goto state_1599;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen IX RParen
state_1598:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_512;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_512;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen IX expr
state_1599:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen IX expr RParen
state_1600:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_513;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_513;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen IY
state_1601:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1602;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1603; }
	/*if (check_expr())*/ goto state_1603;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen IY RParen
state_1602:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_514;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_514;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen IY expr
state_1603:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1604;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRA LParen IY expr RParen
state_1604:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_515;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_515;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL
state_1605:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1606;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen
state_1606:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1607;
	case Keyword::IX: m_lexer.next(); goto state_1609;
	case Keyword::IY: m_lexer.next(); goto state_1613;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen HL
state_1607:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1608;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen HL RParen
state_1608:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_516;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_516;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen IX
state_1609:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1610;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1611; }
	/*if (check_expr())*/ goto state_1611;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen IX RParen
state_1610:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_517;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_517;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen IX expr
state_1611:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen IX expr RParen
state_1612:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_518;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_518;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen IY
state_1613:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1614;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1615; }
	/*if (check_expr())*/ goto state_1615;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen IY RParen
state_1614:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_519;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_519;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen IY expr
state_1615:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1616;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SRL LParen IY expr RParen
state_1616:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_520;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_520;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB
state_1617:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1618;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1635;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A
state_1618:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1619;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma
state_1619:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1620;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen
state_1620:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1621;
	case Keyword::IX: m_lexer.next(); goto state_1627;
	case Keyword::IY: m_lexer.next(); goto state_1631;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen HL
state_1621:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1622;
	case TType::Plus: m_lexer.next(); goto state_1624;
	case TType::RParen: m_lexer.next(); goto state_1626;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen HL Minus
state_1622:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen HL Minus RParen
state_1623:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_521;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_521;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen HL Plus
state_1624:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1625;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen HL Plus RParen
state_1625:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_522;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_522;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen HL RParen
state_1626:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_523;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen IX
state_1627:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1628;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1629; }
	/*if (check_expr())*/ goto state_1629;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen IX RParen
state_1628:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_524;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen IX expr
state_1629:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1630;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen IX expr RParen
state_1630:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_525;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen IY
state_1631:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1632;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1633; }
	/*if (check_expr())*/ goto state_1633;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen IY RParen
state_1632:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_526;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_526;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen IY expr
state_1633:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1634;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB A Comma LParen IY expr RParen
state_1634:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_527;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_527;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen
state_1635:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1636;
	case Keyword::IX: m_lexer.next(); goto state_1642;
	case Keyword::IY: m_lexer.next(); goto state_1646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen HL
state_1636:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1637;
	case TType::Plus: m_lexer.next(); goto state_1639;
	case TType::RParen: m_lexer.next(); goto state_1641;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen HL Minus
state_1637:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1638;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen HL Minus RParen
state_1638:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_521;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_521;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen HL Plus
state_1639:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen HL Plus RParen
state_1640:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_522;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_522;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen HL RParen
state_1641:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_523;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen IX
state_1642:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1643;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1644; }
	/*if (check_expr())*/ goto state_1644;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen IX RParen
state_1643:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_524;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen IX expr
state_1644:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1645;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen IX expr RParen
state_1645:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_525;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen IY
state_1646:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1647;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1648; }
	/*if (check_expr())*/ goto state_1648;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen IY RParen
state_1647:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_526;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_526;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen IY expr
state_1648:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI SUB LParen IY expr RParen
state_1649:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_527;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_527;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR
state_1650:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1651;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1668;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A
state_1651:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1652;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma
state_1652:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1653;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen
state_1653:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1654;
	case Keyword::IX: m_lexer.next(); goto state_1660;
	case Keyword::IY: m_lexer.next(); goto state_1664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen HL
state_1654:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1655;
	case TType::Plus: m_lexer.next(); goto state_1657;
	case TType::RParen: m_lexer.next(); goto state_1659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen HL Minus
state_1655:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen HL Minus RParen
state_1656:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_528;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_528;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen HL Plus
state_1657:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen HL Plus RParen
state_1658:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_529;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_529;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen HL RParen
state_1659:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_530;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_530;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen IX
state_1660:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1661;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1662; }
	/*if (check_expr())*/ goto state_1662;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen IX RParen
state_1661:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_531;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen IX expr
state_1662:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1663;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen IX expr RParen
state_1663:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_532;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_532;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen IY
state_1664:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1665;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1666; }
	/*if (check_expr())*/ goto state_1666;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen IY RParen
state_1665:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_533;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_533;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen IY expr
state_1666:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1667;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR A Comma LParen IY expr RParen
state_1667:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_534;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen
state_1668:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1669;
	case Keyword::IX: m_lexer.next(); goto state_1675;
	case Keyword::IY: m_lexer.next(); goto state_1679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen HL
state_1669:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1670;
	case TType::Plus: m_lexer.next(); goto state_1672;
	case TType::RParen: m_lexer.next(); goto state_1674;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen HL Minus
state_1670:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1671;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen HL Minus RParen
state_1671:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_528;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_528;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen HL Plus
state_1672:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen HL Plus RParen
state_1673:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_529;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_529;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen HL RParen
state_1674:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_530;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_530;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen IX
state_1675:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1676;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1677; }
	/*if (check_expr())*/ goto state_1677;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen IX RParen
state_1676:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_531;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen IX expr
state_1677:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen IX expr RParen
state_1678:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_532;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_532;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen IY
state_1679:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1680;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1681; }
	/*if (check_expr())*/ goto state_1681;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen IY RParen
state_1680:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_533;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_533;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen IY expr
state_1681:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD IOI XOR LParen IY expr RParen
state_1682:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_534;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD
state_1683:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1684;
	case Keyword::B: m_lexer.next(); goto state_1728;
	case Keyword::BC: m_lexer.next(); goto state_1757;
	case Keyword::C: m_lexer.next(); goto state_1762;
	case Keyword::D: m_lexer.next(); goto state_1791;
	case Keyword::DE: m_lexer.next(); goto state_1820;
	case Keyword::E: m_lexer.next(); goto state_1825;
	case Keyword::H: m_lexer.next(); goto state_1854;
	case Keyword::HL: m_lexer.next(); goto state_1883;
	case Keyword::L: m_lexer.next(); goto state_1907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A
state_1684:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma
state_1685:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1686;
	case Keyword::B: m_lexer.next(); goto state_1687;
	case Keyword::C: m_lexer.next(); goto state_1688;
	case Keyword::D: m_lexer.next(); goto state_1689;
	case Keyword::E: m_lexer.next(); goto state_1690;
	case Keyword::EIR: m_lexer.next(); goto state_1691;
	case Keyword::H: m_lexer.next(); goto state_1692;
	case Keyword::IIR: m_lexer.next(); goto state_1693;
	case Keyword::L: m_lexer.next(); goto state_1694;
	case Keyword::XPC: m_lexer.next(); goto state_1695;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1696;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1727; }
	/*if (check_expr())*/ goto state_1727;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma A
state_1686:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_535;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_535;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma B
state_1687:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_536;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_536;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma C
state_1688:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_537;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_537;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma D
state_1689:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_538;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_538;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma E
state_1690:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_539;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_539;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma EIR
state_1691:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_540;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma H
state_1692:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_541;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma IIR
state_1693:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_542;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_542;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma L
state_1694:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_543;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma XPC
state_1695:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_544;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_544;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen
state_1696:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_1697;
	case Keyword::DE: m_lexer.next(); goto state_1703;
	case Keyword::HL: m_lexer.next(); goto state_1709;
	case Keyword::HLD: m_lexer.next(); goto state_1715;
	case Keyword::HLI: m_lexer.next(); goto state_1717;
	case Keyword::IX: m_lexer.next(); goto state_1719;
	case Keyword::IY: m_lexer.next(); goto state_1723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen BC
state_1697:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1698;
	case TType::Plus: m_lexer.next(); goto state_1700;
	case TType::RParen: m_lexer.next(); goto state_1702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen BC Minus
state_1698:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1699;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen BC Minus RParen
state_1699:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_545;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_545;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen BC Plus
state_1700:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen BC Plus RParen
state_1701:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_546;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_546;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen BC RParen
state_1702:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_547;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_547;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen DE
state_1703:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1704;
	case TType::Plus: m_lexer.next(); goto state_1706;
	case TType::RParen: m_lexer.next(); goto state_1708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen DE Minus
state_1704:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1705;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen DE Minus RParen
state_1705:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_548;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_548;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen DE Plus
state_1706:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1707;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen DE Plus RParen
state_1707:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_549;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen DE RParen
state_1708:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_550;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_550;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HL
state_1709:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1710;
	case TType::Plus: m_lexer.next(); goto state_1712;
	case TType::RParen: m_lexer.next(); goto state_1714;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HL Minus
state_1710:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1711;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HL Minus RParen
state_1711:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_551;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_551;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HL Plus
state_1712:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1713;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HL Plus RParen
state_1713:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_552;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HL RParen
state_1714:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_553;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_553;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HLD
state_1715:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1716;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HLD RParen
state_1716:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_551;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_551;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HLI
state_1717:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1718;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen HLI RParen
state_1718:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_552;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen IX
state_1719:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1720;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1721; }
	/*if (check_expr())*/ goto state_1721;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen IX RParen
state_1720:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_554;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_554;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen IX expr
state_1721:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1722;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen IX expr RParen
state_1722:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_555;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_555;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen IY
state_1723:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1724;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1725; }
	/*if (check_expr())*/ goto state_1725;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen IY RParen
state_1724:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_556;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen IY expr
state_1725:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1726;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma LParen IY expr RParen
state_1726:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_557;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD A Comma expr
state_1727:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_558;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_558;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B
state_1728:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma
state_1729:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1730;
	case Keyword::B: m_lexer.next(); goto state_1731;
	case Keyword::C: m_lexer.next(); goto state_1732;
	case Keyword::D: m_lexer.next(); goto state_1733;
	case Keyword::E: m_lexer.next(); goto state_1734;
	case Keyword::H: m_lexer.next(); goto state_1735;
	case Keyword::L: m_lexer.next(); goto state_1736;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1737;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1756; }
	/*if (check_expr())*/ goto state_1756;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma A
state_1730:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_559;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_559;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma B
state_1731:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_560;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_560;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma C
state_1732:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_561;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_561;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma D
state_1733:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_562;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma E
state_1734:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_563;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma H
state_1735:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_564;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_564;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma L
state_1736:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_565;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_565;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen
state_1737:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1738;
	case Keyword::HLD: m_lexer.next(); goto state_1744;
	case Keyword::HLI: m_lexer.next(); goto state_1746;
	case Keyword::IX: m_lexer.next(); goto state_1748;
	case Keyword::IY: m_lexer.next(); goto state_1752;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HL
state_1738:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1739;
	case TType::Plus: m_lexer.next(); goto state_1741;
	case TType::RParen: m_lexer.next(); goto state_1743;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HL Minus
state_1739:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HL Minus RParen
state_1740:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_566;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_566;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HL Plus
state_1741:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1742;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HL Plus RParen
state_1742:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_567;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HL RParen
state_1743:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_568;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_568;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HLD
state_1744:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1745;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HLD RParen
state_1745:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_566;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_566;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HLI
state_1746:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1747;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen HLI RParen
state_1747:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_567;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen IX
state_1748:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1749;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1750; }
	/*if (check_expr())*/ goto state_1750;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen IX RParen
state_1749:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_569;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_569;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen IX expr
state_1750:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen IX expr RParen
state_1751:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_570;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_570;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen IY
state_1752:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1753;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1754; }
	/*if (check_expr())*/ goto state_1754;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen IY RParen
state_1753:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_571;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_571;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen IY expr
state_1754:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma LParen IY expr RParen
state_1755:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_572;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_572;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD B Comma expr
state_1756:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_573;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_573;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD BC
state_1757:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD BC Comma
state_1758:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_1759;
	case Keyword::DE: m_lexer.next(); goto state_1760;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1761; }
	/*if (check_expr())*/ goto state_1761;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD BC Comma BC
state_1759:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_574;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD BC Comma DE
state_1760:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_575;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_575;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD BC Comma expr
state_1761:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_576;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C
state_1762:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma
state_1763:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1764;
	case Keyword::B: m_lexer.next(); goto state_1765;
	case Keyword::C: m_lexer.next(); goto state_1766;
	case Keyword::D: m_lexer.next(); goto state_1767;
	case Keyword::E: m_lexer.next(); goto state_1768;
	case Keyword::H: m_lexer.next(); goto state_1769;
	case Keyword::L: m_lexer.next(); goto state_1770;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1771;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1790; }
	/*if (check_expr())*/ goto state_1790;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma A
state_1764:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_577;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma B
state_1765:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_578;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma C
state_1766:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_579;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_579;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma D
state_1767:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_580;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma E
state_1768:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_581;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_581;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma H
state_1769:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_582;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma L
state_1770:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_583;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_583;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen
state_1771:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1772;
	case Keyword::HLD: m_lexer.next(); goto state_1778;
	case Keyword::HLI: m_lexer.next(); goto state_1780;
	case Keyword::IX: m_lexer.next(); goto state_1782;
	case Keyword::IY: m_lexer.next(); goto state_1786;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HL
state_1772:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1773;
	case TType::Plus: m_lexer.next(); goto state_1775;
	case TType::RParen: m_lexer.next(); goto state_1777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HL Minus
state_1773:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HL Minus RParen
state_1774:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_584;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HL Plus
state_1775:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1776;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HL Plus RParen
state_1776:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_585;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HL RParen
state_1777:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_586;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HLD
state_1778:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HLD RParen
state_1779:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_584;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HLI
state_1780:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen HLI RParen
state_1781:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_585;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen IX
state_1782:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1783;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1784; }
	/*if (check_expr())*/ goto state_1784;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen IX RParen
state_1783:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_587;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_587;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen IX expr
state_1784:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen IX expr RParen
state_1785:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_588;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_588;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen IY
state_1786:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1787;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1788; }
	/*if (check_expr())*/ goto state_1788;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen IY RParen
state_1787:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_589;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen IY expr
state_1788:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma LParen IY expr RParen
state_1789:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_590;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_590;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD C Comma expr
state_1790:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_591;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_591;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D
state_1791:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1792;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma
state_1792:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1793;
	case Keyword::B: m_lexer.next(); goto state_1794;
	case Keyword::C: m_lexer.next(); goto state_1795;
	case Keyword::D: m_lexer.next(); goto state_1796;
	case Keyword::E: m_lexer.next(); goto state_1797;
	case Keyword::H: m_lexer.next(); goto state_1798;
	case Keyword::L: m_lexer.next(); goto state_1799;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1800;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1819; }
	/*if (check_expr())*/ goto state_1819;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma A
state_1793:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_592;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_592;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma B
state_1794:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_593;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_593;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma C
state_1795:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_594;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_594;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma D
state_1796:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_595;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_595;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma E
state_1797:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_596;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_596;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma H
state_1798:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_597;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_597;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma L
state_1799:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_598;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_598;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen
state_1800:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1801;
	case Keyword::HLD: m_lexer.next(); goto state_1807;
	case Keyword::HLI: m_lexer.next(); goto state_1809;
	case Keyword::IX: m_lexer.next(); goto state_1811;
	case Keyword::IY: m_lexer.next(); goto state_1815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HL
state_1801:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1802;
	case TType::Plus: m_lexer.next(); goto state_1804;
	case TType::RParen: m_lexer.next(); goto state_1806;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HL Minus
state_1802:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HL Minus RParen
state_1803:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_599;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_599;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HL Plus
state_1804:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1805;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HL Plus RParen
state_1805:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_600;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HL RParen
state_1806:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_601;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_601;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HLD
state_1807:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1808;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HLD RParen
state_1808:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_599;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_599;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HLI
state_1809:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1810;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen HLI RParen
state_1810:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_600;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen IX
state_1811:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1812;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1813; }
	/*if (check_expr())*/ goto state_1813;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen IX RParen
state_1812:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_602;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_602;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen IX expr
state_1813:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1814;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen IX expr RParen
state_1814:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_603;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_603;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen IY
state_1815:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1816;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1817; }
	/*if (check_expr())*/ goto state_1817;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen IY RParen
state_1816:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_604;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_604;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen IY expr
state_1817:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1818;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma LParen IY expr RParen
state_1818:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_605;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_605;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD D Comma expr
state_1819:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_606;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_606;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD DE
state_1820:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1821;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD DE Comma
state_1821:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_1822;
	case Keyword::DE: m_lexer.next(); goto state_1823;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1824; }
	/*if (check_expr())*/ goto state_1824;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD DE Comma BC
state_1822:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_607;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_607;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD DE Comma DE
state_1823:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_608;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_608;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD DE Comma expr
state_1824:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_609;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_609;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E
state_1825:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma
state_1826:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1827;
	case Keyword::B: m_lexer.next(); goto state_1828;
	case Keyword::C: m_lexer.next(); goto state_1829;
	case Keyword::D: m_lexer.next(); goto state_1830;
	case Keyword::E: m_lexer.next(); goto state_1831;
	case Keyword::H: m_lexer.next(); goto state_1832;
	case Keyword::L: m_lexer.next(); goto state_1833;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1834;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1853; }
	/*if (check_expr())*/ goto state_1853;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma A
state_1827:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_610;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_610;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma B
state_1828:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_611;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma C
state_1829:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_612;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma D
state_1830:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_613;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_613;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma E
state_1831:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_614;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma H
state_1832:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_615;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_615;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma L
state_1833:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_616;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_616;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen
state_1834:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1835;
	case Keyword::HLD: m_lexer.next(); goto state_1841;
	case Keyword::HLI: m_lexer.next(); goto state_1843;
	case Keyword::IX: m_lexer.next(); goto state_1845;
	case Keyword::IY: m_lexer.next(); goto state_1849;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HL
state_1835:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1836;
	case TType::Plus: m_lexer.next(); goto state_1838;
	case TType::RParen: m_lexer.next(); goto state_1840;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HL Minus
state_1836:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1837;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HL Minus RParen
state_1837:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_617;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HL Plus
state_1838:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1839;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HL Plus RParen
state_1839:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_618;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HL RParen
state_1840:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_619;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_619;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HLD
state_1841:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1842;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HLD RParen
state_1842:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_617;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HLI
state_1843:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1844;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen HLI RParen
state_1844:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_618;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen IX
state_1845:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1846;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1847; }
	/*if (check_expr())*/ goto state_1847;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen IX RParen
state_1846:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_620;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_620;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen IX expr
state_1847:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1848;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen IX expr RParen
state_1848:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_621;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_621;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen IY
state_1849:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1850;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1851; }
	/*if (check_expr())*/ goto state_1851;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen IY RParen
state_1850:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_622;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_622;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen IY expr
state_1851:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1852;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma LParen IY expr RParen
state_1852:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_623;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD E Comma expr
state_1853:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_624;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_624;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H
state_1854:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1855;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma
state_1855:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1856;
	case Keyword::B: m_lexer.next(); goto state_1857;
	case Keyword::C: m_lexer.next(); goto state_1858;
	case Keyword::D: m_lexer.next(); goto state_1859;
	case Keyword::E: m_lexer.next(); goto state_1860;
	case Keyword::H: m_lexer.next(); goto state_1861;
	case Keyword::L: m_lexer.next(); goto state_1862;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1863;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1882; }
	/*if (check_expr())*/ goto state_1882;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma A
state_1856:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_625;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_625;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma B
state_1857:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_626;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_626;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma C
state_1858:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_627;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_627;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma D
state_1859:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_628;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_628;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma E
state_1860:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_629;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_629;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma H
state_1861:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_630;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_630;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma L
state_1862:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_631;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_631;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen
state_1863:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1864;
	case Keyword::HLD: m_lexer.next(); goto state_1870;
	case Keyword::HLI: m_lexer.next(); goto state_1872;
	case Keyword::IX: m_lexer.next(); goto state_1874;
	case Keyword::IY: m_lexer.next(); goto state_1878;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HL
state_1864:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1865;
	case TType::Plus: m_lexer.next(); goto state_1867;
	case TType::RParen: m_lexer.next(); goto state_1869;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HL Minus
state_1865:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HL Minus RParen
state_1866:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_632;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HL Plus
state_1867:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1868;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HL Plus RParen
state_1868:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_633;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HL RParen
state_1869:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_634;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_634;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HLD
state_1870:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1871;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HLD RParen
state_1871:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_632;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HLI
state_1872:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1873;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen HLI RParen
state_1873:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_633;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen IX
state_1874:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1875;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1876; }
	/*if (check_expr())*/ goto state_1876;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen IX RParen
state_1875:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_635;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_635;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen IX expr
state_1876:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1877;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen IX expr RParen
state_1877:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_636;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen IY
state_1878:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1879;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1880; }
	/*if (check_expr())*/ goto state_1880;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen IY RParen
state_1879:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_637;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen IY expr
state_1880:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1881;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma LParen IY expr RParen
state_1881:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_638;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_638;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD H Comma expr
state_1882:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_639;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL
state_1883:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1884;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma
state_1884:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_1885;
	case Keyword::DE: m_lexer.next(); goto state_1886;
	case Keyword::IX: m_lexer.next(); goto state_1887;
	case Keyword::IY: m_lexer.next(); goto state_1888;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1889;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1906; }
	/*if (check_expr())*/ goto state_1906;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma BC
state_1885:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_640;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma DE
state_1886:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_641;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_641;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma IX
state_1887:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_642;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_642;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma IY
state_1888:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_643;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_643;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen
state_1889:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1890;
	case Keyword::IX: m_lexer.next(); goto state_1894;
	case Keyword::IY: m_lexer.next(); goto state_1898;
	case Keyword::SP: m_lexer.next(); goto state_1902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen HL
state_1890:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1891;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1892; }
	/*if (check_expr())*/ goto state_1892;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen HL RParen
state_1891:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_644;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen HL expr
state_1892:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1893;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen HL expr RParen
state_1893:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_645;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_645;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen IX
state_1894:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1895;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1896; }
	/*if (check_expr())*/ goto state_1896;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen IX RParen
state_1895:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_646;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen IX expr
state_1896:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1897;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen IX expr RParen
state_1897:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_647;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen IY
state_1898:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1899;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1900; }
	/*if (check_expr())*/ goto state_1900;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen IY RParen
state_1899:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_648;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_648;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen IY expr
state_1900:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen IY expr RParen
state_1901:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_649;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen SP
state_1902:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1903;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1904; }
	/*if (check_expr())*/ goto state_1904;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen SP RParen
state_1903:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_650;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen SP expr
state_1904:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1905;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma LParen SP expr RParen
state_1905:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_651;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_651;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD HL Comma expr
state_1906:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_652;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_652;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L
state_1907:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma
state_1908:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1909;
	case Keyword::B: m_lexer.next(); goto state_1910;
	case Keyword::C: m_lexer.next(); goto state_1911;
	case Keyword::D: m_lexer.next(); goto state_1912;
	case Keyword::E: m_lexer.next(); goto state_1913;
	case Keyword::H: m_lexer.next(); goto state_1914;
	case Keyword::L: m_lexer.next(); goto state_1915;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1916;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1935; }
	/*if (check_expr())*/ goto state_1935;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma A
state_1909:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_653;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_653;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma B
state_1910:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_654;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_654;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma C
state_1911:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_655;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_655;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma D
state_1912:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_656;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma E
state_1913:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_657;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_657;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma H
state_1914:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_658;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma L
state_1915:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_659;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen
state_1916:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1917;
	case Keyword::HLD: m_lexer.next(); goto state_1923;
	case Keyword::HLI: m_lexer.next(); goto state_1925;
	case Keyword::IX: m_lexer.next(); goto state_1927;
	case Keyword::IY: m_lexer.next(); goto state_1931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HL
state_1917:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1918;
	case TType::Plus: m_lexer.next(); goto state_1920;
	case TType::RParen: m_lexer.next(); goto state_1922;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HL Minus
state_1918:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1919;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HL Minus RParen
state_1919:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HL Plus
state_1920:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1921;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HL Plus RParen
state_1921:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HL RParen
state_1922:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_662;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HLD
state_1923:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HLD RParen
state_1924:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HLI
state_1925:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen HLI RParen
state_1926:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen IX
state_1927:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1928;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1929; }
	/*if (check_expr())*/ goto state_1929;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen IX RParen
state_1928:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_663;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_663;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen IX expr
state_1929:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen IX expr RParen
state_1930:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_664;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen IY
state_1931:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1932;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1933; }
	/*if (check_expr())*/ goto state_1933;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen IY RParen
state_1932:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_665;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_665;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen IY expr
state_1933:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma LParen IY expr RParen
state_1934:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_666;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_666;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD LD L Comma expr
state_1935:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_667;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_667;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD NEG
state_1936:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1937;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_668;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_668;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD NEG A
state_1937:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_668;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_668;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR
state_1938:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1939;
	case Keyword::B: m_lexer.next(); goto state_1964;
	case Keyword::C: m_lexer.next(); goto state_1965;
	case Keyword::D: m_lexer.next(); goto state_1966;
	case Keyword::E: m_lexer.next(); goto state_1967;
	case Keyword::H: m_lexer.next(); goto state_1968;
	case Keyword::HL: m_lexer.next(); goto state_1969;
	case Keyword::L: m_lexer.next(); goto state_1972;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1973;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1988; }
	/*if (check_expr())*/ goto state_1988;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A
state_1939:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1940;
	case TType::End: goto action_669;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_669;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma
state_1940:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1941;
	case Keyword::B: m_lexer.next(); goto state_1942;
	case Keyword::C: m_lexer.next(); goto state_1943;
	case Keyword::D: m_lexer.next(); goto state_1944;
	case Keyword::E: m_lexer.next(); goto state_1945;
	case Keyword::H: m_lexer.next(); goto state_1946;
	case Keyword::L: m_lexer.next(); goto state_1947;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_1948;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1963; }
	/*if (check_expr())*/ goto state_1963;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma A
state_1941:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_669;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_669;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma B
state_1942:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_670;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_670;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma C
state_1943:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_671;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_671;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma D
state_1944:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_672;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_672;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma E
state_1945:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_673;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma H
state_1946:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_674;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_674;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma L
state_1947:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_675;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_675;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen
state_1948:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1949;
	case Keyword::IX: m_lexer.next(); goto state_1955;
	case Keyword::IY: m_lexer.next(); goto state_1959;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen HL
state_1949:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1950;
	case TType::Plus: m_lexer.next(); goto state_1952;
	case TType::RParen: m_lexer.next(); goto state_1954;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen HL Minus
state_1950:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1951;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen HL Minus RParen
state_1951:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_676;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_676;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen HL Plus
state_1952:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1953;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen HL Plus RParen
state_1953:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_677;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_677;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen HL RParen
state_1954:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_678;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen IX
state_1955:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1956;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1957; }
	/*if (check_expr())*/ goto state_1957;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen IX RParen
state_1956:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_679;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen IX expr
state_1957:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1958;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen IX expr RParen
state_1958:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_680;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_680;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen IY
state_1959:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1960;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1961; }
	/*if (check_expr())*/ goto state_1961;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen IY RParen
state_1960:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_681;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_681;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen IY expr
state_1961:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1962;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma LParen IY expr RParen
state_1962:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_682;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR A Comma expr
state_1963:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_683;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_683;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR B
state_1964:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_670;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_670;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR C
state_1965:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_671;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_671;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR D
state_1966:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_672;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_672;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR E
state_1967:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_673;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR H
state_1968:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_674;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_674;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR HL
state_1969:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1970;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR HL Comma
state_1970:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_1971;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR HL Comma DE
state_1971:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_684;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_684;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR L
state_1972:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_675;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_675;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen
state_1973:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_1974;
	case Keyword::IX: m_lexer.next(); goto state_1980;
	case Keyword::IY: m_lexer.next(); goto state_1984;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen HL
state_1974:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_1975;
	case TType::Plus: m_lexer.next(); goto state_1977;
	case TType::RParen: m_lexer.next(); goto state_1979;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen HL Minus
state_1975:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1976;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen HL Minus RParen
state_1976:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_676;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_676;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen HL Plus
state_1977:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen HL Plus RParen
state_1978:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_677;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_677;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen HL RParen
state_1979:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_678;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen IX
state_1980:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1981;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1982; }
	/*if (check_expr())*/ goto state_1982;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen IX RParen
state_1981:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_679;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen IX expr
state_1982:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1983;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen IX expr RParen
state_1983:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_680;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_680;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen IY
state_1984:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1985;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1986; }
	/*if (check_expr())*/ goto state_1986;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen IY RParen
state_1985:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_681;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_681;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen IY expr
state_1986:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_1987;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR LParen IY expr RParen
state_1987:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_682;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD OR expr
state_1988:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_683;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_683;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD POP
state_1989:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::AF: m_lexer.next(); goto state_1990;
	case Keyword::BC: m_lexer.next(); goto state_1991;
	case Keyword::DE: m_lexer.next(); goto state_1992;
	case Keyword::HL: m_lexer.next(); goto state_1993;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD POP AF
state_1990:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_685;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD POP BC
state_1991:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_686;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_686;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD POP DE
state_1992:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_687;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_687;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD POP HL
state_1993:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_688;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_688;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES
state_1994:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_1995; }
	/*if (check_const_expr())*/ goto state_1995;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES const_expr
state_1995:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_1996;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES const_expr Comma
state_1996:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_1997;
	case Keyword::B: m_lexer.next(); goto state_1998;
	case Keyword::C: m_lexer.next(); goto state_1999;
	case Keyword::D: m_lexer.next(); goto state_2000;
	case Keyword::E: m_lexer.next(); goto state_2001;
	case Keyword::H: m_lexer.next(); goto state_2002;
	case Keyword::L: m_lexer.next(); goto state_2003;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES const_expr Comma A
state_1997:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_689;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_689;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES const_expr Comma B
state_1998:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_690;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_690;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES const_expr Comma C
state_1999:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_691;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_691;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES const_expr Comma D
state_2000:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_692;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_692;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES const_expr Comma E
state_2001:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_693;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_693;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES const_expr Comma H
state_2002:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_694;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RES const_expr Comma L
state_2003:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_695;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_695;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL
state_2004:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2005;
	case Keyword::B: m_lexer.next(); goto state_2006;
	case Keyword::C: m_lexer.next(); goto state_2007;
	case Keyword::D: m_lexer.next(); goto state_2008;
	case Keyword::DE: m_lexer.next(); goto state_2009;
	case Keyword::E: m_lexer.next(); goto state_2010;
	case Keyword::H: m_lexer.next(); goto state_2011;
	case Keyword::L: m_lexer.next(); goto state_2012;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2013;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL A
state_2005:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_696;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_696;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL B
state_2006:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_697;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_697;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL C
state_2007:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_698;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_698;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL D
state_2008:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_699;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_699;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL DE
state_2009:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_700;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_700;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL E
state_2010:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_701;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL H
state_2011:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_702;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL L
state_2012:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_703;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_703;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen
state_2013:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2014;
	case Keyword::IX: m_lexer.next(); goto state_2016;
	case Keyword::IY: m_lexer.next(); goto state_2020;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen HL
state_2014:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2015;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen HL RParen
state_2015:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_704;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_704;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen IX
state_2016:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2017;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2018; }
	/*if (check_expr())*/ goto state_2018;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen IX RParen
state_2017:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_705;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_705;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen IX expr
state_2018:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2019;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen IX expr RParen
state_2019:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_706;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_706;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen IY
state_2020:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2021;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2022; }
	/*if (check_expr())*/ goto state_2022;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen IY RParen
state_2021:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_707;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_707;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen IY expr
state_2022:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2023;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RL LParen IY expr RParen
state_2023:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_708;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLA
state_2024:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_709;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_709;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC
state_2025:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2026;
	case Keyword::B: m_lexer.next(); goto state_2027;
	case Keyword::C: m_lexer.next(); goto state_2028;
	case Keyword::D: m_lexer.next(); goto state_2029;
	case Keyword::E: m_lexer.next(); goto state_2030;
	case Keyword::H: m_lexer.next(); goto state_2031;
	case Keyword::L: m_lexer.next(); goto state_2032;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2033;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC A
state_2026:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_710;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_710;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC B
state_2027:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_711;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_711;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC C
state_2028:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_712;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_712;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC D
state_2029:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_713;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_713;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC E
state_2030:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_714;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_714;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC H
state_2031:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_715;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_715;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC L
state_2032:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_716;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_716;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen
state_2033:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2034;
	case Keyword::IX: m_lexer.next(); goto state_2036;
	case Keyword::IY: m_lexer.next(); goto state_2040;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen HL
state_2034:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2035;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen HL RParen
state_2035:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_717;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_717;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen IX
state_2036:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2037;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2038; }
	/*if (check_expr())*/ goto state_2038;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen IX RParen
state_2037:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_718;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_718;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen IX expr
state_2038:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen IX expr RParen
state_2039:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_719;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_719;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen IY
state_2040:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2041;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2042; }
	/*if (check_expr())*/ goto state_2042;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen IY RParen
state_2041:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_720;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_720;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen IY expr
state_2042:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2043;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLC LParen IY expr RParen
state_2043:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_721;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_721;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RLCA
state_2044:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_722;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_722;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR
state_2045:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2046;
	case Keyword::B: m_lexer.next(); goto state_2047;
	case Keyword::C: m_lexer.next(); goto state_2048;
	case Keyword::D: m_lexer.next(); goto state_2049;
	case Keyword::DE: m_lexer.next(); goto state_2050;
	case Keyword::E: m_lexer.next(); goto state_2051;
	case Keyword::H: m_lexer.next(); goto state_2052;
	case Keyword::HL: m_lexer.next(); goto state_2053;
	case Keyword::L: m_lexer.next(); goto state_2054;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2055;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR A
state_2046:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_723;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR B
state_2047:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_724;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR C
state_2048:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_725;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_725;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR D
state_2049:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_726;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_726;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR DE
state_2050:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_727;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_727;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR E
state_2051:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_728;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_728;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR H
state_2052:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_729;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR HL
state_2053:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_730;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_730;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR L
state_2054:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_731;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_731;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen
state_2055:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2056;
	case Keyword::IX: m_lexer.next(); goto state_2058;
	case Keyword::IY: m_lexer.next(); goto state_2062;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen HL
state_2056:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2057;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen HL RParen
state_2057:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_732;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_732;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen IX
state_2058:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2059;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2060; }
	/*if (check_expr())*/ goto state_2060;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen IX RParen
state_2059:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_733;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_733;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen IX expr
state_2060:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2061;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen IX expr RParen
state_2061:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_734;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_734;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen IY
state_2062:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2063;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2064; }
	/*if (check_expr())*/ goto state_2064;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen IY RParen
state_2063:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_735;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_735;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen IY expr
state_2064:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2065;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RR LParen IY expr RParen
state_2065:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_736;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_736;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRA
state_2066:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_737;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_737;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC
state_2067:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2068;
	case Keyword::B: m_lexer.next(); goto state_2069;
	case Keyword::C: m_lexer.next(); goto state_2070;
	case Keyword::D: m_lexer.next(); goto state_2071;
	case Keyword::E: m_lexer.next(); goto state_2072;
	case Keyword::H: m_lexer.next(); goto state_2073;
	case Keyword::L: m_lexer.next(); goto state_2074;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC A
state_2068:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_738;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_738;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC B
state_2069:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_739;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC C
state_2070:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_740;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC D
state_2071:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_741;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_741;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC E
state_2072:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_742;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_742;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC H
state_2073:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_743;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_743;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC L
state_2074:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_744;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_744;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen
state_2075:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2076;
	case Keyword::IX: m_lexer.next(); goto state_2078;
	case Keyword::IY: m_lexer.next(); goto state_2082;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen HL
state_2076:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2077;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen HL RParen
state_2077:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_745;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_745;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen IX
state_2078:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2079;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2080; }
	/*if (check_expr())*/ goto state_2080;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen IX RParen
state_2079:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_746;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_746;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen IX expr
state_2080:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2081;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen IX expr RParen
state_2081:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_747;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_747;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen IY
state_2082:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2083;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2084; }
	/*if (check_expr())*/ goto state_2084;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen IY RParen
state_2083:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_748;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_748;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen IY expr
state_2084:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRC LParen IY expr RParen
state_2085:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_749;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_749;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD RRCA
state_2086:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_750;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_750;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC
state_2087:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2088;
	case Keyword::B: m_lexer.next(); goto state_2113;
	case Keyword::C: m_lexer.next(); goto state_2114;
	case Keyword::D: m_lexer.next(); goto state_2115;
	case Keyword::E: m_lexer.next(); goto state_2116;
	case Keyword::H: m_lexer.next(); goto state_2117;
	case Keyword::HL: m_lexer.next(); goto state_2118;
	case Keyword::L: m_lexer.next(); goto state_2124;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2125;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2140; }
	/*if (check_expr())*/ goto state_2140;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A
state_2088:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2089;
	case TType::End: goto action_751;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma
state_2089:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2090;
	case Keyword::B: m_lexer.next(); goto state_2091;
	case Keyword::C: m_lexer.next(); goto state_2092;
	case Keyword::D: m_lexer.next(); goto state_2093;
	case Keyword::E: m_lexer.next(); goto state_2094;
	case Keyword::H: m_lexer.next(); goto state_2095;
	case Keyword::L: m_lexer.next(); goto state_2096;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2097;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2112; }
	/*if (check_expr())*/ goto state_2112;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma A
state_2090:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_751;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma B
state_2091:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_752;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_752;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma C
state_2092:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_753;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma D
state_2093:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_754;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_754;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma E
state_2094:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_755;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma H
state_2095:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_756;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma L
state_2096:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_757;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen
state_2097:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2098;
	case Keyword::IX: m_lexer.next(); goto state_2104;
	case Keyword::IY: m_lexer.next(); goto state_2108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen HL
state_2098:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2099;
	case TType::Plus: m_lexer.next(); goto state_2101;
	case TType::RParen: m_lexer.next(); goto state_2103;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen HL Minus
state_2099:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen HL Minus RParen
state_2100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_758;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen HL Plus
state_2101:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2102;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen HL Plus RParen
state_2102:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_759;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen HL RParen
state_2103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_760;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen IX
state_2104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2105;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2106; }
	/*if (check_expr())*/ goto state_2106;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen IX RParen
state_2105:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_761;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen IX expr
state_2106:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen IX expr RParen
state_2107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_762;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen IY
state_2108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2109;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2110; }
	/*if (check_expr())*/ goto state_2110;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen IY RParen
state_2109:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_763;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen IY expr
state_2110:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma LParen IY expr RParen
state_2111:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_764;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC A Comma expr
state_2112:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_765;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC B
state_2113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_752;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_752;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC C
state_2114:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_753;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC D
state_2115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_754;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_754;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC E
state_2116:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_755;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC H
state_2117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_756;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC HL
state_2118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2119;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC HL Comma
state_2119:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_2120;
	case Keyword::DE: m_lexer.next(); goto state_2121;
	case Keyword::HL: m_lexer.next(); goto state_2122;
	case Keyword::SP: m_lexer.next(); goto state_2123;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC HL Comma BC
state_2120:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_766;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_766;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC HL Comma DE
state_2121:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_767;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC HL Comma HL
state_2122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_768;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC HL Comma SP
state_2123:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_769;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_769;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC L
state_2124:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_757;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen
state_2125:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2126;
	case Keyword::IX: m_lexer.next(); goto state_2132;
	case Keyword::IY: m_lexer.next(); goto state_2136;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen HL
state_2126:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2127;
	case TType::Plus: m_lexer.next(); goto state_2129;
	case TType::RParen: m_lexer.next(); goto state_2131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen HL Minus
state_2127:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen HL Minus RParen
state_2128:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_758;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen HL Plus
state_2129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2130;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen HL Plus RParen
state_2130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_759;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen HL RParen
state_2131:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_760;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen IX
state_2132:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2133;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2134; }
	/*if (check_expr())*/ goto state_2134;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen IX RParen
state_2133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_761;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen IX expr
state_2134:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen IX expr RParen
state_2135:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_762;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen IY
state_2136:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2137;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2138; }
	/*if (check_expr())*/ goto state_2138;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen IY RParen
state_2137:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_763;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen IY expr
state_2138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC LParen IY expr RParen
state_2139:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_764;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SBC expr
state_2140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_765;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SCF
state_2141:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_770;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_770;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET
state_2142:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2143; }
	/*if (check_const_expr())*/ goto state_2143;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET const_expr
state_2143:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2144;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET const_expr Comma
state_2144:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2145;
	case Keyword::B: m_lexer.next(); goto state_2146;
	case Keyword::C: m_lexer.next(); goto state_2147;
	case Keyword::D: m_lexer.next(); goto state_2148;
	case Keyword::E: m_lexer.next(); goto state_2149;
	case Keyword::H: m_lexer.next(); goto state_2150;
	case Keyword::L: m_lexer.next(); goto state_2151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET const_expr Comma A
state_2145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_771;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET const_expr Comma B
state_2146:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_772;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_772;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET const_expr Comma C
state_2147:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_773;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET const_expr Comma D
state_2148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_774;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET const_expr Comma E
state_2149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_775;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_775;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET const_expr Comma H
state_2150:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_776;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_776;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SET const_expr Comma L
state_2151:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_777;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA
state_2152:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2153;
	case Keyword::B: m_lexer.next(); goto state_2154;
	case Keyword::C: m_lexer.next(); goto state_2155;
	case Keyword::D: m_lexer.next(); goto state_2156;
	case Keyword::E: m_lexer.next(); goto state_2157;
	case Keyword::H: m_lexer.next(); goto state_2158;
	case Keyword::L: m_lexer.next(); goto state_2159;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2160;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA A
state_2153:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_778;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_778;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA B
state_2154:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_779;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA C
state_2155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_780;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_780;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA D
state_2156:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_781;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA E
state_2157:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_782;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA H
state_2158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_783;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_783;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA L
state_2159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_784;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_784;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen
state_2160:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2161;
	case Keyword::IX: m_lexer.next(); goto state_2163;
	case Keyword::IY: m_lexer.next(); goto state_2167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen HL
state_2161:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen HL RParen
state_2162:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_785;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen IX
state_2163:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2164;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2165; }
	/*if (check_expr())*/ goto state_2165;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen IX RParen
state_2164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_786;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_786;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen IX expr
state_2165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen IX expr RParen
state_2166:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_787;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_787;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen IY
state_2167:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2168;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2169; }
	/*if (check_expr())*/ goto state_2169;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen IY RParen
state_2168:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_788;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_788;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen IY expr
state_2169:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2170;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SLA LParen IY expr RParen
state_2170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_789;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA
state_2171:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2172;
	case Keyword::B: m_lexer.next(); goto state_2173;
	case Keyword::C: m_lexer.next(); goto state_2174;
	case Keyword::D: m_lexer.next(); goto state_2175;
	case Keyword::E: m_lexer.next(); goto state_2176;
	case Keyword::H: m_lexer.next(); goto state_2177;
	case Keyword::L: m_lexer.next(); goto state_2178;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2179;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA A
state_2172:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_790;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_790;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA B
state_2173:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_791;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA C
state_2174:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_792;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_792;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA D
state_2175:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_793;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_793;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA E
state_2176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_794;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_794;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA H
state_2177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_795;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_795;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA L
state_2178:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_796;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_796;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen
state_2179:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2180;
	case Keyword::IX: m_lexer.next(); goto state_2182;
	case Keyword::IY: m_lexer.next(); goto state_2186;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen HL
state_2180:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2181;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen HL RParen
state_2181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_797;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_797;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen IX
state_2182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2183;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2184; }
	/*if (check_expr())*/ goto state_2184;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen IX RParen
state_2183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_798;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_798;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen IX expr
state_2184:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen IX expr RParen
state_2185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_799;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_799;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen IY
state_2186:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2187;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2188; }
	/*if (check_expr())*/ goto state_2188;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen IY RParen
state_2187:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_800;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_800;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen IY expr
state_2188:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRA LParen IY expr RParen
state_2189:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_801;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_801;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL
state_2190:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2191;
	case Keyword::B: m_lexer.next(); goto state_2192;
	case Keyword::C: m_lexer.next(); goto state_2193;
	case Keyword::D: m_lexer.next(); goto state_2194;
	case Keyword::E: m_lexer.next(); goto state_2195;
	case Keyword::H: m_lexer.next(); goto state_2196;
	case Keyword::L: m_lexer.next(); goto state_2197;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2198;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL A
state_2191:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_802;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_802;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL B
state_2192:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_803;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL C
state_2193:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_804;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_804;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL D
state_2194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_805;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_805;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL E
state_2195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_806;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_806;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL H
state_2196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_807;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_807;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL L
state_2197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_808;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_808;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen
state_2198:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2199;
	case Keyword::IX: m_lexer.next(); goto state_2201;
	case Keyword::IY: m_lexer.next(); goto state_2205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen HL
state_2199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen HL RParen
state_2200:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_809;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_809;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen IX
state_2201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2202;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2203; }
	/*if (check_expr())*/ goto state_2203;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen IX RParen
state_2202:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_810;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_810;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen IX expr
state_2203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2204;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen IX expr RParen
state_2204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_811;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_811;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen IY
state_2205:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2206;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2207; }
	/*if (check_expr())*/ goto state_2207;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen IY RParen
state_2206:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_812;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_812;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen IY expr
state_2207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2208;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SRL LParen IY expr RParen
state_2208:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_813;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_813;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB
state_2209:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2210;
	case Keyword::B: m_lexer.next(); goto state_2235;
	case Keyword::C: m_lexer.next(); goto state_2236;
	case Keyword::D: m_lexer.next(); goto state_2237;
	case Keyword::E: m_lexer.next(); goto state_2238;
	case Keyword::H: m_lexer.next(); goto state_2239;
	case Keyword::L: m_lexer.next(); goto state_2240;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2241;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2256; }
	/*if (check_expr())*/ goto state_2256;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A
state_2210:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2211;
	case TType::End: goto action_814;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_814;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma
state_2211:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2212;
	case Keyword::B: m_lexer.next(); goto state_2213;
	case Keyword::C: m_lexer.next(); goto state_2214;
	case Keyword::D: m_lexer.next(); goto state_2215;
	case Keyword::E: m_lexer.next(); goto state_2216;
	case Keyword::H: m_lexer.next(); goto state_2217;
	case Keyword::L: m_lexer.next(); goto state_2218;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2219;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2234; }
	/*if (check_expr())*/ goto state_2234;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma A
state_2212:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_814;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_814;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma B
state_2213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_815;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma C
state_2214:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_816;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_816;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma D
state_2215:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_817;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_817;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma E
state_2216:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_818;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_818;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma H
state_2217:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_819;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_819;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma L
state_2218:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_820;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_820;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen
state_2219:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2220;
	case Keyword::IX: m_lexer.next(); goto state_2226;
	case Keyword::IY: m_lexer.next(); goto state_2230;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen HL
state_2220:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2221;
	case TType::Plus: m_lexer.next(); goto state_2223;
	case TType::RParen: m_lexer.next(); goto state_2225;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen HL Minus
state_2221:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2222;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen HL Minus RParen
state_2222:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_821;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_821;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen HL Plus
state_2223:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2224;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen HL Plus RParen
state_2224:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_822;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_822;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen HL RParen
state_2225:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_823;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen IX
state_2226:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2227;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2228; }
	/*if (check_expr())*/ goto state_2228;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen IX RParen
state_2227:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_824;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_824;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen IX expr
state_2228:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2229;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen IX expr RParen
state_2229:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_825;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_825;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen IY
state_2230:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2231;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2232; }
	/*if (check_expr())*/ goto state_2232;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen IY RParen
state_2231:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_826;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen IY expr
state_2232:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2233;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma LParen IY expr RParen
state_2233:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_827;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_827;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB A Comma expr
state_2234:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_828;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_828;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB B
state_2235:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_815;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB C
state_2236:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_816;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_816;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB D
state_2237:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_817;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_817;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB E
state_2238:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_818;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_818;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB H
state_2239:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_819;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_819;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB L
state_2240:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_820;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_820;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen
state_2241:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2242;
	case Keyword::IX: m_lexer.next(); goto state_2248;
	case Keyword::IY: m_lexer.next(); goto state_2252;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen HL
state_2242:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2243;
	case TType::Plus: m_lexer.next(); goto state_2245;
	case TType::RParen: m_lexer.next(); goto state_2247;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen HL Minus
state_2243:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2244;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen HL Minus RParen
state_2244:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_821;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_821;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen HL Plus
state_2245:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen HL Plus RParen
state_2246:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_822;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_822;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen HL RParen
state_2247:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_823;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen IX
state_2248:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2249;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2250; }
	/*if (check_expr())*/ goto state_2250;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen IX RParen
state_2249:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_824;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_824;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen IX expr
state_2250:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2251;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen IX expr RParen
state_2251:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_825;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_825;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen IY
state_2252:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2253;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2254; }
	/*if (check_expr())*/ goto state_2254;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen IY RParen
state_2253:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_826;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen IY expr
state_2254:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2255;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB LParen IY expr RParen
state_2255:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_827;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_827;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD SUB expr
state_2256:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_828;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_828;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR
state_2257:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2258;
	case Keyword::B: m_lexer.next(); goto state_2283;
	case Keyword::C: m_lexer.next(); goto state_2284;
	case Keyword::D: m_lexer.next(); goto state_2285;
	case Keyword::E: m_lexer.next(); goto state_2286;
	case Keyword::H: m_lexer.next(); goto state_2287;
	case Keyword::L: m_lexer.next(); goto state_2288;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2289;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2304; }
	/*if (check_expr())*/ goto state_2304;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A
state_2258:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2259;
	case TType::End: goto action_829;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_829;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma
state_2259:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2260;
	case Keyword::B: m_lexer.next(); goto state_2261;
	case Keyword::C: m_lexer.next(); goto state_2262;
	case Keyword::D: m_lexer.next(); goto state_2263;
	case Keyword::E: m_lexer.next(); goto state_2264;
	case Keyword::H: m_lexer.next(); goto state_2265;
	case Keyword::L: m_lexer.next(); goto state_2266;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2267;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2282; }
	/*if (check_expr())*/ goto state_2282;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma A
state_2260:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_829;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_829;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma B
state_2261:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_830;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_830;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma C
state_2262:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_831;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_831;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma D
state_2263:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_832;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_832;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma E
state_2264:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_833;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma H
state_2265:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_834;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_834;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma L
state_2266:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_835;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen
state_2267:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2268;
	case Keyword::IX: m_lexer.next(); goto state_2274;
	case Keyword::IY: m_lexer.next(); goto state_2278;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen HL
state_2268:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2269;
	case TType::Plus: m_lexer.next(); goto state_2271;
	case TType::RParen: m_lexer.next(); goto state_2273;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen HL Minus
state_2269:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen HL Minus RParen
state_2270:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_836;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_836;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen HL Plus
state_2271:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2272;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen HL Plus RParen
state_2272:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_837;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_837;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen HL RParen
state_2273:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_838;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen IX
state_2274:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2275;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2276; }
	/*if (check_expr())*/ goto state_2276;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen IX RParen
state_2275:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_839;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_839;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen IX expr
state_2276:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2277;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen IX expr RParen
state_2277:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_840;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_840;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen IY
state_2278:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2279;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2280; }
	/*if (check_expr())*/ goto state_2280;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen IY RParen
state_2279:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_841;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen IY expr
state_2280:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma LParen IY expr RParen
state_2281:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_842;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_842;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR A Comma expr
state_2282:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_843;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_843;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR B
state_2283:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_830;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_830;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR C
state_2284:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_831;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_831;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR D
state_2285:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_832;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_832;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR E
state_2286:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_833;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR H
state_2287:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_834;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_834;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR L
state_2288:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_835;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen
state_2289:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2290;
	case Keyword::IX: m_lexer.next(); goto state_2296;
	case Keyword::IY: m_lexer.next(); goto state_2300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen HL
state_2290:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2291;
	case TType::Plus: m_lexer.next(); goto state_2293;
	case TType::RParen: m_lexer.next(); goto state_2295;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen HL Minus
state_2291:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2292;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen HL Minus RParen
state_2292:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_836;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_836;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen HL Plus
state_2293:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2294;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen HL Plus RParen
state_2294:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_837;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_837;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen HL RParen
state_2295:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_838;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen IX
state_2296:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2297;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2298; }
	/*if (check_expr())*/ goto state_2298;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen IX RParen
state_2297:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_839;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_839;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen IX expr
state_2298:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen IX expr RParen
state_2299:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_840;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_840;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen IY
state_2300:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2301;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2302; }
	/*if (check_expr())*/ goto state_2302;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen IY RParen
state_2301:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_841;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen IY expr
state_2302:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR LParen IY expr RParen
state_2303:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_842;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_842;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ALTD XOR expr
state_2304:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_843;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_843;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANA
state_2305:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2306;
	case Keyword::B: m_lexer.next(); goto state_2307;
	case Keyword::C: m_lexer.next(); goto state_2308;
	case Keyword::D: m_lexer.next(); goto state_2309;
	case Keyword::E: m_lexer.next(); goto state_2310;
	case Keyword::H: m_lexer.next(); goto state_2311;
	case Keyword::L: m_lexer.next(); goto state_2312;
	case Keyword::M: m_lexer.next(); goto state_2313;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANA A
state_2306:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_844;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_844;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANA B
state_2307:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_845;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_845;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANA C
state_2308:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_846;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_846;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANA D
state_2309:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_847;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_847;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANA E
state_2310:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_848;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_848;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANA H
state_2311:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_849;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_849;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANA L
state_2312:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_850;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_850;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANA M
state_2313:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_851;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_851;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND
state_2314:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2315;
	case Keyword::A1: m_lexer.next(); goto state_2344;
	case Keyword::B: m_lexer.next(); goto state_2369;
	case Keyword::C: m_lexer.next(); goto state_2370;
	case Keyword::D: m_lexer.next(); goto state_2371;
	case Keyword::E: m_lexer.next(); goto state_2372;
	case Keyword::H: m_lexer.next(); goto state_2373;
	case Keyword::HL: m_lexer.next(); goto state_2374;
	case Keyword::HL1: m_lexer.next(); goto state_2377;
	case Keyword::IX: m_lexer.next(); goto state_2380;
	case Keyword::IXH: m_lexer.next(); goto state_2383;
	case Keyword::IXL: m_lexer.next(); goto state_2384;
	case Keyword::IY: m_lexer.next(); goto state_2385;
	case Keyword::IYH: m_lexer.next(); goto state_2388;
	case Keyword::IYL: m_lexer.next(); goto state_2389;
	case Keyword::L: m_lexer.next(); goto state_2390;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2391;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2406; }
	/*if (check_expr())*/ goto state_2406;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A
state_2315:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2316;
	case TType::End: goto action_844;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_844;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma
state_2316:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2317;
	case Keyword::B: m_lexer.next(); goto state_2318;
	case Keyword::C: m_lexer.next(); goto state_2319;
	case Keyword::D: m_lexer.next(); goto state_2320;
	case Keyword::E: m_lexer.next(); goto state_2321;
	case Keyword::H: m_lexer.next(); goto state_2322;
	case Keyword::IXH: m_lexer.next(); goto state_2323;
	case Keyword::IXL: m_lexer.next(); goto state_2324;
	case Keyword::IYH: m_lexer.next(); goto state_2325;
	case Keyword::IYL: m_lexer.next(); goto state_2326;
	case Keyword::L: m_lexer.next(); goto state_2327;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2328;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2343; }
	/*if (check_expr())*/ goto state_2343;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma A
state_2317:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_844;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_844;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma B
state_2318:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_845;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_845;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma C
state_2319:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_846;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_846;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma D
state_2320:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_847;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_847;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma E
state_2321:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_848;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_848;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma H
state_2322:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_849;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_849;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma IXH
state_2323:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_852;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_852;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma IXL
state_2324:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_853;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_853;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma IYH
state_2325:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_854;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_854;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma IYL
state_2326:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_855;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_855;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma L
state_2327:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_850;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_850;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen
state_2328:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2329;
	case Keyword::IX: m_lexer.next(); goto state_2335;
	case Keyword::IY: m_lexer.next(); goto state_2339;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen HL
state_2329:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2330;
	case TType::Plus: m_lexer.next(); goto state_2332;
	case TType::RParen: m_lexer.next(); goto state_2334;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen HL Minus
state_2330:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2331;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen HL Minus RParen
state_2331:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_856;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_856;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen HL Plus
state_2332:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2333;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen HL Plus RParen
state_2333:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_857;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_857;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen HL RParen
state_2334:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_851;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_851;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen IX
state_2335:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2336;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2337; }
	/*if (check_expr())*/ goto state_2337;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen IX RParen
state_2336:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_858;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_858;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen IX expr
state_2337:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2338;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen IX expr RParen
state_2338:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_859;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_859;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen IY
state_2339:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2340;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2341; }
	/*if (check_expr())*/ goto state_2341;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen IY RParen
state_2340:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_860;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_860;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen IY expr
state_2341:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2342;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma LParen IY expr RParen
state_2342:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_861;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_861;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A Comma expr
state_2343:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_862;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1
state_2344:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2345;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma
state_2345:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2346;
	case Keyword::B: m_lexer.next(); goto state_2347;
	case Keyword::C: m_lexer.next(); goto state_2348;
	case Keyword::D: m_lexer.next(); goto state_2349;
	case Keyword::E: m_lexer.next(); goto state_2350;
	case Keyword::H: m_lexer.next(); goto state_2351;
	case Keyword::L: m_lexer.next(); goto state_2352;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2353;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2368; }
	/*if (check_expr())*/ goto state_2368;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma A
state_2346:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_101;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_101;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma B
state_2347:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_102;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_102;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma C
state_2348:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_103;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_103;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma D
state_2349:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_104;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma E
state_2350:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_105;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_105;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma H
state_2351:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_106;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_106;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma L
state_2352:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_107;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen
state_2353:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2354;
	case Keyword::IX: m_lexer.next(); goto state_2360;
	case Keyword::IY: m_lexer.next(); goto state_2364;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen HL
state_2354:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2355;
	case TType::Plus: m_lexer.next(); goto state_2357;
	case TType::RParen: m_lexer.next(); goto state_2359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen HL Minus
state_2355:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2356;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen HL Minus RParen
state_2356:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_108;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen HL Plus
state_2357:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen HL Plus RParen
state_2358:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_109;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen HL RParen
state_2359:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_110;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_110;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen IX
state_2360:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2361;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2362; }
	/*if (check_expr())*/ goto state_2362;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen IX RParen
state_2361:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_111;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen IX expr
state_2362:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen IX expr RParen
state_2363:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_112;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_112;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen IY
state_2364:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2365;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2366; }
	/*if (check_expr())*/ goto state_2366;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen IY RParen
state_2365:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_113;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_113;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen IY expr
state_2366:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2367;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma LParen IY expr RParen
state_2367:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_114;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND A1 Comma expr
state_2368:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_115;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND B
state_2369:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_845;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_845;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND C
state_2370:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_846;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_846;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND D
state_2371:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_847;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_847;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND E
state_2372:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_848;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_848;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND H
state_2373:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_849;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_849;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND HL
state_2374:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2375;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND HL Comma
state_2375:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_2376;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND HL Comma DE
state_2376:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_863;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_863;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND HL1
state_2377:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2378;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND HL1 Comma
state_2378:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_2379;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND HL1 Comma DE
state_2379:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_116;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_116;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IX
state_2380:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2381;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IX Comma
state_2381:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_2382;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IX Comma DE
state_2382:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_864;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_864;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IXH
state_2383:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_852;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_852;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IXL
state_2384:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_853;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_853;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IY
state_2385:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2386;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IY Comma
state_2386:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_2387;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IY Comma DE
state_2387:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_865;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_865;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IYH
state_2388:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_854;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_854;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND IYL
state_2389:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_855;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_855;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND L
state_2390:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_850;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_850;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen
state_2391:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2392;
	case Keyword::IX: m_lexer.next(); goto state_2398;
	case Keyword::IY: m_lexer.next(); goto state_2402;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen HL
state_2392:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2393;
	case TType::Plus: m_lexer.next(); goto state_2395;
	case TType::RParen: m_lexer.next(); goto state_2397;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen HL Minus
state_2393:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2394;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen HL Minus RParen
state_2394:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_856;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_856;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen HL Plus
state_2395:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2396;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen HL Plus RParen
state_2396:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_857;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_857;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen HL RParen
state_2397:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_851;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_851;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen IX
state_2398:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2399;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2400; }
	/*if (check_expr())*/ goto state_2400;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen IX RParen
state_2399:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_858;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_858;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen IX expr
state_2400:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2401;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen IX expr RParen
state_2401:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_859;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_859;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen IY
state_2402:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2403;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2404; }
	/*if (check_expr())*/ goto state_2404;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen IY RParen
state_2403:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_860;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_860;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen IY expr
state_2404:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2405;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND LParen IY expr RParen
state_2405:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_861;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_861;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: AND expr
state_2406:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_862;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANI
state_2407:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2408; }
	/*if (check_expr())*/ goto state_2408;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ANI expr
state_2408:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_862;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ARHL
state_2409:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_866;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT
state_2410:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2411; }
	/*if (check_const_expr())*/ goto state_2411;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr
state_2411:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2412;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma
state_2412:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2413;
	case Keyword::B: m_lexer.next(); goto state_2414;
	case Keyword::C: m_lexer.next(); goto state_2415;
	case Keyword::D: m_lexer.next(); goto state_2416;
	case Keyword::E: m_lexer.next(); goto state_2417;
	case Keyword::H: m_lexer.next(); goto state_2418;
	case Keyword::L: m_lexer.next(); goto state_2419;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2420;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma A
state_2413:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_867;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_867;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma B
state_2414:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_868;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_868;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma C
state_2415:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_869;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_869;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma D
state_2416:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_870;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_870;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma E
state_2417:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_871;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_871;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma H
state_2418:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_872;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_872;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma L
state_2419:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_873;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_873;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen
state_2420:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2421;
	case Keyword::IX: m_lexer.next(); goto state_2423;
	case Keyword::IY: m_lexer.next(); goto state_2427;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen HL
state_2421:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2422;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen HL RParen
state_2422:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_874;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_874;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen IX
state_2423:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2424;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2425; }
	/*if (check_expr())*/ goto state_2425;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen IX RParen
state_2424:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_875;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_875;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen IX expr
state_2425:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2426;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen IX expr RParen
state_2426:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_876;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_876;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen IY
state_2427:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2428;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2429; }
	/*if (check_expr())*/ goto state_2429;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen IY RParen
state_2428:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_877;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_877;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen IY expr
state_2429:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2430;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BIT const_expr Comma LParen IY expr RParen
state_2430:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_878;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_878;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BOOL
state_2431:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2432;
	case Keyword::HL1: m_lexer.next(); goto state_2433;
	case Keyword::IX: m_lexer.next(); goto state_2434;
	case Keyword::IY: m_lexer.next(); goto state_2435;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BOOL HL
state_2432:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_879;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_879;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BOOL HL1
state_2433:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_129;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BOOL IX
state_2434:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_880;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_880;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BOOL IY
state_2435:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_881;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_881;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BRLC
state_2436:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_2437;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BRLC DE
state_2437:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2438;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BRLC DE Comma
state_2438:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_2439;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BRLC DE Comma B
state_2439:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_882;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_882;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSLA
state_2440:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_2441;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSLA DE
state_2441:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2442;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSLA DE Comma
state_2442:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_2443;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSLA DE Comma B
state_2443:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_883;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_883;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRA
state_2444:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_2445;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRA DE
state_2445:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2446;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRA DE Comma
state_2446:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_2447;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRA DE Comma B
state_2447:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_884;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_884;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRF
state_2448:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_2449;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRF DE
state_2449:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2450;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRF DE Comma
state_2450:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_2451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRF DE Comma B
state_2451:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_885;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_885;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRL
state_2452:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_2453;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRL DE
state_2453:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRL DE Comma
state_2454:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_2455;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: BSRL DE Comma B
state_2455:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_886;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_886;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL
state_2456:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2457;
	case Keyword::LO: m_lexer.next(); goto state_2460;
	case Keyword::LZ: m_lexer.next(); goto state_2463;
	case Keyword::M: m_lexer.next(); goto state_2466;
	case Keyword::NC: m_lexer.next(); goto state_2469;
	case Keyword::NV: m_lexer.next(); goto state_2472;
	case Keyword::NZ: m_lexer.next(); goto state_2475;
	case Keyword::P: m_lexer.next(); goto state_2478;
	case Keyword::PE: m_lexer.next(); goto state_2481;
	case Keyword::PO: m_lexer.next(); goto state_2484;
	case Keyword::V: m_lexer.next(); goto state_2487;
	case Keyword::Z: m_lexer.next(); goto state_2490;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2493; }
	/*if (check_expr())*/ goto state_2493;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL C
state_2457:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2458;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL C Comma
state_2458:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2459; }
	/*if (check_expr())*/ goto state_2459;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL C Comma expr
state_2459:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_887;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_887;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL LO
state_2460:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL LO Comma
state_2461:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2462; }
	/*if (check_expr())*/ goto state_2462;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL LO Comma expr
state_2462:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_888;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL LZ
state_2463:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL LZ Comma
state_2464:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2465; }
	/*if (check_expr())*/ goto state_2465;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL LZ Comma expr
state_2465:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_889;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_889;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL M
state_2466:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL M Comma
state_2467:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2468; }
	/*if (check_expr())*/ goto state_2468;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL M Comma expr
state_2468:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_890;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_890;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL NC
state_2469:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL NC Comma
state_2470:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2471; }
	/*if (check_expr())*/ goto state_2471;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL NC Comma expr
state_2471:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_891;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_891;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL NV
state_2472:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2473;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL NV Comma
state_2473:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2474; }
	/*if (check_expr())*/ goto state_2474;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL NV Comma expr
state_2474:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL NZ
state_2475:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2476;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL NZ Comma
state_2476:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2477; }
	/*if (check_expr())*/ goto state_2477;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL NZ Comma expr
state_2477:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_893;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_893;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL P
state_2478:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2479;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL P Comma
state_2479:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2480; }
	/*if (check_expr())*/ goto state_2480;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL P Comma expr
state_2480:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_894;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_894;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL PE
state_2481:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL PE Comma
state_2482:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2483; }
	/*if (check_expr())*/ goto state_2483;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL PE Comma expr
state_2483:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL PO
state_2484:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2485;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL PO Comma
state_2485:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2486; }
	/*if (check_expr())*/ goto state_2486;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL PO Comma expr
state_2486:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL V
state_2487:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL V Comma
state_2488:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2489; }
	/*if (check_expr())*/ goto state_2489;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL V Comma expr
state_2489:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL Z
state_2490:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2491;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL Z Comma
state_2491:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2492; }
	/*if (check_expr())*/ goto state_2492;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL Z Comma expr
state_2492:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_896;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_896;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CALL expr
state_2493:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_897;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_897;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CC
state_2494:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2495; }
	/*if (check_expr())*/ goto state_2495;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CC expr
state_2495:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_887;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_887;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CCF
state_2496:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_898;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_898;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CCF1
state_2497:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_130;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_130;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CLO
state_2498:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2499; }
	/*if (check_expr())*/ goto state_2499;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CLO expr
state_2499:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_888;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CLZ
state_2500:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2501; }
	/*if (check_expr())*/ goto state_2501;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CLZ expr
state_2501:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_889;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_889;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CM
state_2502:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2503; }
	/*if (check_expr())*/ goto state_2503;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CM expr
state_2503:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_890;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_890;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMA
state_2504:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_899;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMC
state_2505:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_898;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_898;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP
state_2506:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2507;
	case Keyword::B: m_lexer.next(); goto state_2536;
	case Keyword::C: m_lexer.next(); goto state_2537;
	case Keyword::D: m_lexer.next(); goto state_2538;
	case Keyword::E: m_lexer.next(); goto state_2539;
	case Keyword::H: m_lexer.next(); goto state_2540;
	case Keyword::IXH: m_lexer.next(); goto state_2541;
	case Keyword::IXL: m_lexer.next(); goto state_2542;
	case Keyword::IYH: m_lexer.next(); goto state_2543;
	case Keyword::IYL: m_lexer.next(); goto state_2544;
	case Keyword::L: m_lexer.next(); goto state_2545;
	case Keyword::M: m_lexer.next(); goto state_2546;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2547;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2562; }
	/*if (check_expr())*/ goto state_2562;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A
state_2507:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2508;
	case TType::End: goto action_900;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_900;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma
state_2508:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2509;
	case Keyword::B: m_lexer.next(); goto state_2510;
	case Keyword::C: m_lexer.next(); goto state_2511;
	case Keyword::D: m_lexer.next(); goto state_2512;
	case Keyword::E: m_lexer.next(); goto state_2513;
	case Keyword::H: m_lexer.next(); goto state_2514;
	case Keyword::IXH: m_lexer.next(); goto state_2515;
	case Keyword::IXL: m_lexer.next(); goto state_2516;
	case Keyword::IYH: m_lexer.next(); goto state_2517;
	case Keyword::IYL: m_lexer.next(); goto state_2518;
	case Keyword::L: m_lexer.next(); goto state_2519;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2520;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2535; }
	/*if (check_expr())*/ goto state_2535;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma A
state_2509:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_900;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_900;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma B
state_2510:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_901;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma C
state_2511:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_902;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma D
state_2512:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_903;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma E
state_2513:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_904;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma H
state_2514:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_905;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_905;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma IXH
state_2515:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_906;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma IXL
state_2516:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_907;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma IYH
state_2517:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_908;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma IYL
state_2518:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_909;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma L
state_2519:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen
state_2520:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2521;
	case Keyword::IX: m_lexer.next(); goto state_2527;
	case Keyword::IY: m_lexer.next(); goto state_2531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen HL
state_2521:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2522;
	case TType::Plus: m_lexer.next(); goto state_2524;
	case TType::RParen: m_lexer.next(); goto state_2526;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen HL Minus
state_2522:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen HL Minus RParen
state_2523:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen HL Plus
state_2524:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen HL Plus RParen
state_2525:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen HL RParen
state_2526:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen IX
state_2527:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2528;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2529; }
	/*if (check_expr())*/ goto state_2529;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen IX RParen
state_2528:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen IX expr
state_2529:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2530;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen IX expr RParen
state_2530:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen IY
state_2531:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2532;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2533; }
	/*if (check_expr())*/ goto state_2533;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen IY RParen
state_2532:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen IY expr
state_2533:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma LParen IY expr RParen
state_2534:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP A Comma expr
state_2535:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP B
state_2536:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_901;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP C
state_2537:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_902;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP D
state_2538:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_903;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP E
state_2539:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_904;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP H
state_2540:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_905;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_905;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP IXH
state_2541:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_906;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP IXL
state_2542:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_907;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP IYH
state_2543:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_908;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP IYL
state_2544:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_909;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP L
state_2545:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP M
state_2546:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen
state_2547:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2548;
	case Keyword::IX: m_lexer.next(); goto state_2554;
	case Keyword::IY: m_lexer.next(); goto state_2558;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen HL
state_2548:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2549;
	case TType::Plus: m_lexer.next(); goto state_2551;
	case TType::RParen: m_lexer.next(); goto state_2553;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen HL Minus
state_2549:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2550;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen HL Minus RParen
state_2550:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen HL Plus
state_2551:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen HL Plus RParen
state_2552:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen HL RParen
state_2553:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen IX
state_2554:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2555;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2556; }
	/*if (check_expr())*/ goto state_2556;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen IX RParen
state_2555:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen IX expr
state_2556:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen IX expr RParen
state_2557:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen IY
state_2558:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2559;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2560; }
	/*if (check_expr())*/ goto state_2560;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen IY RParen
state_2559:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen IY expr
state_2560:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2561;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP LParen IY expr RParen
state_2561:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CMP expr
state_2562:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CNC
state_2563:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2564; }
	/*if (check_expr())*/ goto state_2564;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CNC expr
state_2564:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_891;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_891;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CNV
state_2565:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2566; }
	/*if (check_expr())*/ goto state_2566;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CNV expr
state_2566:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CNZ
state_2567:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2568; }
	/*if (check_expr())*/ goto state_2568;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CNZ expr
state_2568:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_893;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_893;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP
state_2569:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2570;
	case Keyword::B: m_lexer.next(); goto state_2599;
	case Keyword::C: m_lexer.next(); goto state_2600;
	case Keyword::D: m_lexer.next(); goto state_2601;
	case Keyword::E: m_lexer.next(); goto state_2602;
	case Keyword::H: m_lexer.next(); goto state_2603;
	case Keyword::IXH: m_lexer.next(); goto state_2604;
	case Keyword::IXL: m_lexer.next(); goto state_2605;
	case Keyword::IYH: m_lexer.next(); goto state_2606;
	case Keyword::IYL: m_lexer.next(); goto state_2607;
	case Keyword::L: m_lexer.next(); goto state_2608;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2609;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2624; }
	/*if (check_expr())*/ goto state_2624;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A
state_2570:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2571;
	case TType::End: goto action_900;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_900;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma
state_2571:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2572;
	case Keyword::B: m_lexer.next(); goto state_2573;
	case Keyword::C: m_lexer.next(); goto state_2574;
	case Keyword::D: m_lexer.next(); goto state_2575;
	case Keyword::E: m_lexer.next(); goto state_2576;
	case Keyword::H: m_lexer.next(); goto state_2577;
	case Keyword::IXH: m_lexer.next(); goto state_2578;
	case Keyword::IXL: m_lexer.next(); goto state_2579;
	case Keyword::IYH: m_lexer.next(); goto state_2580;
	case Keyword::IYL: m_lexer.next(); goto state_2581;
	case Keyword::L: m_lexer.next(); goto state_2582;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2583;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2598; }
	/*if (check_expr())*/ goto state_2598;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma A
state_2572:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_900;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_900;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma B
state_2573:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_901;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma C
state_2574:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_902;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma D
state_2575:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_903;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma E
state_2576:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_904;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma H
state_2577:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_905;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_905;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma IXH
state_2578:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_906;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma IXL
state_2579:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_907;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma IYH
state_2580:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_908;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma IYL
state_2581:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_909;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma L
state_2582:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen
state_2583:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2584;
	case Keyword::IX: m_lexer.next(); goto state_2590;
	case Keyword::IY: m_lexer.next(); goto state_2594;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen HL
state_2584:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2585;
	case TType::Plus: m_lexer.next(); goto state_2587;
	case TType::RParen: m_lexer.next(); goto state_2589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen HL Minus
state_2585:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen HL Minus RParen
state_2586:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen HL Plus
state_2587:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2588;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen HL Plus RParen
state_2588:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen HL RParen
state_2589:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen IX
state_2590:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2591;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2592; }
	/*if (check_expr())*/ goto state_2592;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen IX RParen
state_2591:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen IX expr
state_2592:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2593;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen IX expr RParen
state_2593:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen IY
state_2594:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2595;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2596; }
	/*if (check_expr())*/ goto state_2596;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen IY RParen
state_2595:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen IY expr
state_2596:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2597;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma LParen IY expr RParen
state_2597:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP A Comma expr
state_2598:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP B
state_2599:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_901;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP C
state_2600:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_902;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP D
state_2601:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_903;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP E
state_2602:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_904;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP H
state_2603:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_905;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_905;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP IXH
state_2604:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_906;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP IXL
state_2605:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_907;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP IYH
state_2606:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_908;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP IYL
state_2607:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_909;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP L
state_2608:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen
state_2609:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2610;
	case Keyword::IX: m_lexer.next(); goto state_2616;
	case Keyword::IY: m_lexer.next(); goto state_2620;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen HL
state_2610:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2611;
	case TType::Plus: m_lexer.next(); goto state_2613;
	case TType::RParen: m_lexer.next(); goto state_2615;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen HL Minus
state_2611:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen HL Minus RParen
state_2612:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen HL Plus
state_2613:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen HL Plus RParen
state_2614:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen HL RParen
state_2615:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen IX
state_2616:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2617;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2618; }
	/*if (check_expr())*/ goto state_2618;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen IX RParen
state_2617:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen IX expr
state_2618:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2619;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen IX expr RParen
state_2619:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen IY
state_2620:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2621;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2622; }
	/*if (check_expr())*/ goto state_2622;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen IY RParen
state_2621:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen IY expr
state_2622:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP LParen IY expr RParen
state_2623:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CP expr
state_2624:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPD
state_2625:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_919;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_919;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPDR
state_2626:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_920;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_920;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPE
state_2627:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2628; }
	/*if (check_expr())*/ goto state_2628;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPE expr
state_2628:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPI
state_2629:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_921;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_921;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2630; }
	/*if (check_expr())*/ goto state_2630;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPI expr
state_2630:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPIR
state_2631:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_922;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_922;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPL
state_2632:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2633;
	case Keyword::A1: m_lexer.next(); goto state_2634;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_899;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPL A
state_2633:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_899;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPL A1
state_2634:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_146;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPO
state_2635:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2636; }
	/*if (check_expr())*/ goto state_2636;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CPO expr
state_2636:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CV
state_2637:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2638; }
	/*if (check_expr())*/ goto state_2638;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CV expr
state_2638:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: CZ
state_2639:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2640; }
	/*if (check_expr())*/ goto state_2640;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: CZ expr
state_2640:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_896;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_896;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_C
state_2641:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2642; }
	/*if (check_expr())*/ goto state_2642;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_C expr
state_2642:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_887;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_887;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_LO
state_2643:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2644; }
	/*if (check_expr())*/ goto state_2644;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_LO expr
state_2644:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_888;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_LZ
state_2645:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2646; }
	/*if (check_expr())*/ goto state_2646;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_LZ expr
state_2646:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_889;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_889;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_M
state_2647:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2648; }
	/*if (check_expr())*/ goto state_2648;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_M expr
state_2648:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_890;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_890;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_NC
state_2649:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2650; }
	/*if (check_expr())*/ goto state_2650;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_NC expr
state_2650:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_891;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_891;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_NV
state_2651:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2652; }
	/*if (check_expr())*/ goto state_2652;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_NV expr
state_2652:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_NZ
state_2653:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2654; }
	/*if (check_expr())*/ goto state_2654;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_NZ expr
state_2654:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_893;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_893;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_P
state_2655:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2656; }
	/*if (check_expr())*/ goto state_2656;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_P expr
state_2656:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_894;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_894;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_PE
state_2657:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2658; }
	/*if (check_expr())*/ goto state_2658;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_PE expr
state_2658:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_PO
state_2659:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2660; }
	/*if (check_expr())*/ goto state_2660;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_PO expr
state_2660:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_V
state_2661:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2662; }
	/*if (check_expr())*/ goto state_2662;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_V expr
state_2662:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_Z
state_2663:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2664; }
	/*if (check_expr())*/ goto state_2664;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: C_Z expr
state_2664:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_896;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_896;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DAA
state_2665:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_923;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DAD
state_2666:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_2667;
	case Keyword::BC: m_lexer.next(); goto state_2668;
	case Keyword::D: m_lexer.next(); goto state_2669;
	case Keyword::DE: m_lexer.next(); goto state_2670;
	case Keyword::H: m_lexer.next(); goto state_2671;
	case Keyword::HL: m_lexer.next(); goto state_2672;
	case Keyword::SP: m_lexer.next(); goto state_2673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DAD B
state_2667:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_81;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_81;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DAD BC
state_2668:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_81;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_81;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DAD D
state_2669:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_82;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_82;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DAD DE
state_2670:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_82;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_82;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DAD H
state_2671:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_83;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_83;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DAD HL
state_2672:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_83;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_83;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DAD SP
state_2673:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_84;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_84;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCR
state_2674:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2675;
	case Keyword::B: m_lexer.next(); goto state_2676;
	case Keyword::C: m_lexer.next(); goto state_2677;
	case Keyword::D: m_lexer.next(); goto state_2678;
	case Keyword::E: m_lexer.next(); goto state_2679;
	case Keyword::H: m_lexer.next(); goto state_2680;
	case Keyword::L: m_lexer.next(); goto state_2681;
	case Keyword::M: m_lexer.next(); goto state_2682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCR A
state_2675:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_924;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCR B
state_2676:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_925;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCR C
state_2677:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_926;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCR D
state_2678:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_927;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_927;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCR E
state_2679:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_928;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_928;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCR H
state_2680:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_929;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_929;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCR L
state_2681:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_930;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCR M
state_2682:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_931;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCX
state_2683:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_2684;
	case Keyword::BC: m_lexer.next(); goto state_2685;
	case Keyword::D: m_lexer.next(); goto state_2686;
	case Keyword::DE: m_lexer.next(); goto state_2687;
	case Keyword::H: m_lexer.next(); goto state_2688;
	case Keyword::HL: m_lexer.next(); goto state_2689;
	case Keyword::SP: m_lexer.next(); goto state_2690;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCX B
state_2684:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_932;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCX BC
state_2685:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_932;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCX D
state_2686:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_933;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCX DE
state_2687:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_933;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCX H
state_2688:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_934;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCX HL
state_2689:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_934;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DCX SP
state_2690:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_935;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC
state_2691:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2692;
	case Keyword::A1: m_lexer.next(); goto state_2693;
	case Keyword::B: m_lexer.next(); goto state_2694;
	case Keyword::B1: m_lexer.next(); goto state_2695;
	case Keyword::BC: m_lexer.next(); goto state_2696;
	case Keyword::BC1: m_lexer.next(); goto state_2697;
	case Keyword::C: m_lexer.next(); goto state_2698;
	case Keyword::C1: m_lexer.next(); goto state_2699;
	case Keyword::D: m_lexer.next(); goto state_2700;
	case Keyword::D1: m_lexer.next(); goto state_2701;
	case Keyword::DE: m_lexer.next(); goto state_2702;
	case Keyword::DE1: m_lexer.next(); goto state_2703;
	case Keyword::E: m_lexer.next(); goto state_2704;
	case Keyword::E1: m_lexer.next(); goto state_2705;
	case Keyword::H: m_lexer.next(); goto state_2706;
	case Keyword::H1: m_lexer.next(); goto state_2707;
	case Keyword::HL: m_lexer.next(); goto state_2708;
	case Keyword::HL1: m_lexer.next(); goto state_2709;
	case Keyword::IX: m_lexer.next(); goto state_2710;
	case Keyword::IXH: m_lexer.next(); goto state_2711;
	case Keyword::IXL: m_lexer.next(); goto state_2712;
	case Keyword::IY: m_lexer.next(); goto state_2713;
	case Keyword::IYH: m_lexer.next(); goto state_2714;
	case Keyword::IYL: m_lexer.next(); goto state_2715;
	case Keyword::L: m_lexer.next(); goto state_2716;
	case Keyword::L1: m_lexer.next(); goto state_2717;
	case Keyword::SP: m_lexer.next(); goto state_2718;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2719;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC A
state_2692:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_924;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC A1
state_2693:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_147;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC B
state_2694:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_925;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC B1
state_2695:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_148;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_148;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC BC
state_2696:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_932;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC BC1
state_2697:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_149;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_149;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC C
state_2698:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_926;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC C1
state_2699:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_150;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_150;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC D
state_2700:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_927;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_927;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC D1
state_2701:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_151;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC DE
state_2702:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_933;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC DE1
state_2703:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_152;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC E
state_2704:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_928;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_928;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC E1
state_2705:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_153;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_153;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC H
state_2706:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_929;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_929;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC H1
state_2707:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_154;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_154;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC HL
state_2708:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_934;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC HL1
state_2709:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_155;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_155;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC IX
state_2710:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_936;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_936;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC IXH
state_2711:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_937;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_937;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC IXL
state_2712:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_938;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_938;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC IY
state_2713:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_939;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_939;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC IYH
state_2714:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_940;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_940;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC IYL
state_2715:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_941;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_941;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC L
state_2716:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_930;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC L1
state_2717:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_156;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_156;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC SP
state_2718:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_935;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen
state_2719:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2720;
	case Keyword::IX: m_lexer.next(); goto state_2726;
	case Keyword::IY: m_lexer.next(); goto state_2730;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen HL
state_2720:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2721;
	case TType::Plus: m_lexer.next(); goto state_2723;
	case TType::RParen: m_lexer.next(); goto state_2725;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen HL Minus
state_2721:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2722;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen HL Minus RParen
state_2722:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_942;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_942;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen HL Plus
state_2723:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen HL Plus RParen
state_2724:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_943;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_943;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen HL RParen
state_2725:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_931;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen IX
state_2726:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2727;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2728; }
	/*if (check_expr())*/ goto state_2728;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen IX RParen
state_2727:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_944;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_944;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen IX expr
state_2728:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen IX expr RParen
state_2729:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_945;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_945;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen IY
state_2730:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2731;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2732; }
	/*if (check_expr())*/ goto state_2732;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen IY RParen
state_2731:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_946;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_946;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen IY expr
state_2732:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2733;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DEC LParen IY expr RParen
state_2733:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_947;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_947;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DI
state_2734:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_948;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_948;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DJNZ
state_2735:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_2736;
	case Keyword::B1: m_lexer.next(); goto state_2739;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2742; }
	/*if (check_expr())*/ goto state_2742;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: DJNZ B
state_2736:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2737;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DJNZ B Comma
state_2737:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2738; }
	/*if (check_expr())*/ goto state_2738;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: DJNZ B Comma expr
state_2738:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_949;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_949;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DJNZ B1
state_2739:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DJNZ B1 Comma
state_2740:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2741; }
	/*if (check_expr())*/ goto state_2741;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: DJNZ B1 Comma expr
state_2741:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_164;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_164;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DJNZ expr
state_2742:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_949;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_949;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: DSUB
state_2743:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_950;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_950;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EI
state_2744:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_951;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_951;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX
state_2745:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::AF: m_lexer.next(); goto state_2746;
	case Keyword::DE: m_lexer.next(); goto state_2750;
	case Keyword::DE1: m_lexer.next(); goto state_2754;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX AF
state_2746:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2747;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX AF Comma
state_2747:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::AF: m_lexer.next(); goto state_2748;
	case Keyword::AF1: m_lexer.next(); goto state_2749;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX AF Comma AF
state_2748:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_952;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_952;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX AF Comma AF1
state_2749:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_952;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_952;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX DE
state_2750:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX DE Comma
state_2751:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2752;
	case Keyword::HL1: m_lexer.next(); goto state_2753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX DE Comma HL
state_2752:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_953;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_953;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX DE Comma HL1
state_2753:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_165;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX DE1
state_2754:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX DE1 Comma
state_2755:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2756;
	case Keyword::HL1: m_lexer.next(); goto state_2757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX DE1 Comma HL
state_2756:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_954;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_954;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX DE1 Comma HL1
state_2757:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_166;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX LParen
state_2758:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::SP: m_lexer.next(); goto state_2759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX LParen SP
state_2759:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX LParen SP RParen
state_2760:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX LParen SP RParen Comma
state_2761:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2762;
	case Keyword::HL1: m_lexer.next(); goto state_2763;
	case Keyword::IX: m_lexer.next(); goto state_2764;
	case Keyword::IY: m_lexer.next(); goto state_2765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX LParen SP RParen Comma HL
state_2762:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_955;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_955;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX LParen SP RParen Comma HL1
state_2763:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_167;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX LParen SP RParen Comma IX
state_2764:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_956;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_956;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EX LParen SP RParen Comma IY
state_2765:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_957;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_957;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: EXX
state_2766:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_959;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_959;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: HALT
state_2767:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_960;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_960;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: HLT
state_2768:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_960;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_960;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IDET
state_2769:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_961;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_961;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IM
state_2770:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2771; }
	/*if (check_const_expr())*/ goto state_2771;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IM const_expr
state_2771:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_962;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_962;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN
state_2772:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2773;
	case Keyword::B: m_lexer.next(); goto state_2779;
	case Keyword::C: m_lexer.next(); goto state_2784;
	case Keyword::D: m_lexer.next(); goto state_2789;
	case Keyword::E: m_lexer.next(); goto state_2794;
	case Keyword::F: m_lexer.next(); goto state_2799;
	case Keyword::H: m_lexer.next(); goto state_2804;
	case Keyword::L: m_lexer.next(); goto state_2809;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2814;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2817; }
	/*if (check_expr())*/ goto state_2817;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN A
state_2773:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN A Comma
state_2774:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2775;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2778; }
	/*if (check_expr())*/ goto state_2778;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN A Comma LParen
state_2775:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2776;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN A Comma LParen C
state_2776:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN A Comma LParen C RParen
state_2777:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_963;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_963;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN A Comma expr
state_2778:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_964;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_964;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN B
state_2779:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2780;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN B Comma
state_2780:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN B Comma LParen
state_2781:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN B Comma LParen C
state_2782:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2783;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN B Comma LParen C RParen
state_2783:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_965;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_965;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN C
state_2784:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN C Comma
state_2785:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2786;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN C Comma LParen
state_2786:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2787;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN C Comma LParen C
state_2787:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2788;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN C Comma LParen C RParen
state_2788:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_966;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_966;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN D
state_2789:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2790;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN D Comma
state_2790:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN D Comma LParen
state_2791:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2792;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN D Comma LParen C
state_2792:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2793;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN D Comma LParen C RParen
state_2793:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_967;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_967;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN E
state_2794:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2795;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN E Comma
state_2795:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2796;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN E Comma LParen
state_2796:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2797;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN E Comma LParen C
state_2797:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2798;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN E Comma LParen C RParen
state_2798:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_968;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_968;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN F
state_2799:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2800;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN F Comma
state_2800:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2801;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN F Comma LParen
state_2801:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2802;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN F Comma LParen C
state_2802:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN F Comma LParen C RParen
state_2803:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_969;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_969;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN H
state_2804:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2805;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN H Comma
state_2805:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2806;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN H Comma LParen
state_2806:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2807;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN H Comma LParen C
state_2807:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2808;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN H Comma LParen C RParen
state_2808:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_970;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_970;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN L
state_2809:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2810;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN L Comma
state_2810:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2811;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN L Comma LParen
state_2811:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2812;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN L Comma LParen C
state_2812:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2813;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN L Comma LParen C RParen
state_2813:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_971;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_971;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN LParen
state_2814:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_2815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN LParen C
state_2815:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2816;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN LParen C RParen
state_2816:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_969;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_969;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN expr
state_2817:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_972;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_972;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0
state_2818:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2819;
	case Keyword::B: m_lexer.next(); goto state_2822;
	case Keyword::C: m_lexer.next(); goto state_2825;
	case Keyword::D: m_lexer.next(); goto state_2828;
	case Keyword::E: m_lexer.next(); goto state_2831;
	case Keyword::F: m_lexer.next(); goto state_2834;
	case Keyword::H: m_lexer.next(); goto state_2837;
	case Keyword::L: m_lexer.next(); goto state_2840;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2843; }
	/*if (check_expr())*/ goto state_2843;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 A
state_2819:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2820;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 A Comma
state_2820:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2821; }
	/*if (check_expr())*/ goto state_2821;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 A Comma expr
state_2821:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_973;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_973;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 B
state_2822:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 B Comma
state_2823:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2824; }
	/*if (check_expr())*/ goto state_2824;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 B Comma expr
state_2824:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_974;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_974;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 C
state_2825:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 C Comma
state_2826:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2827; }
	/*if (check_expr())*/ goto state_2827;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 C Comma expr
state_2827:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_975;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_975;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 D
state_2828:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2829;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 D Comma
state_2829:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2830; }
	/*if (check_expr())*/ goto state_2830;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 D Comma expr
state_2830:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_976;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_976;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 E
state_2831:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2832;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 E Comma
state_2832:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2833; }
	/*if (check_expr())*/ goto state_2833;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 E Comma expr
state_2833:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_977;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_977;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 F
state_2834:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 F Comma
state_2835:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2836; }
	/*if (check_expr())*/ goto state_2836;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 F Comma expr
state_2836:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_978;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 H
state_2837:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 H Comma
state_2838:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2839; }
	/*if (check_expr())*/ goto state_2839;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 H Comma expr
state_2839:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_979;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_979;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 L
state_2840:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 L Comma
state_2841:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2842; }
	/*if (check_expr())*/ goto state_2842;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 L Comma expr
state_2842:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_980;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_980;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IN0 expr
state_2843:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_978;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC
state_2844:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2845;
	case Keyword::A1: m_lexer.next(); goto state_2846;
	case Keyword::B: m_lexer.next(); goto state_2847;
	case Keyword::B1: m_lexer.next(); goto state_2848;
	case Keyword::BC: m_lexer.next(); goto state_2849;
	case Keyword::BC1: m_lexer.next(); goto state_2850;
	case Keyword::C: m_lexer.next(); goto state_2851;
	case Keyword::C1: m_lexer.next(); goto state_2852;
	case Keyword::D: m_lexer.next(); goto state_2853;
	case Keyword::D1: m_lexer.next(); goto state_2854;
	case Keyword::DE: m_lexer.next(); goto state_2855;
	case Keyword::DE1: m_lexer.next(); goto state_2856;
	case Keyword::E: m_lexer.next(); goto state_2857;
	case Keyword::E1: m_lexer.next(); goto state_2858;
	case Keyword::H: m_lexer.next(); goto state_2859;
	case Keyword::H1: m_lexer.next(); goto state_2860;
	case Keyword::HL: m_lexer.next(); goto state_2861;
	case Keyword::HL1: m_lexer.next(); goto state_2862;
	case Keyword::IX: m_lexer.next(); goto state_2863;
	case Keyword::IXH: m_lexer.next(); goto state_2864;
	case Keyword::IXL: m_lexer.next(); goto state_2865;
	case Keyword::IY: m_lexer.next(); goto state_2866;
	case Keyword::IYH: m_lexer.next(); goto state_2867;
	case Keyword::IYL: m_lexer.next(); goto state_2868;
	case Keyword::L: m_lexer.next(); goto state_2869;
	case Keyword::L1: m_lexer.next(); goto state_2870;
	case Keyword::SP: m_lexer.next(); goto state_2871;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2872;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC A
state_2845:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_981;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_981;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC A1
state_2846:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_168;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC B
state_2847:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_982;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_982;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC B1
state_2848:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_169;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_169;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC BC
state_2849:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_983;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_983;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC BC1
state_2850:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_170;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_170;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC C
state_2851:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_984;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_984;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC C1
state_2852:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_171;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_171;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC D
state_2853:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_985;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_985;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC D1
state_2854:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_172;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_172;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC DE
state_2855:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_986;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_986;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC DE1
state_2856:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_173;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_173;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC E
state_2857:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_987;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_987;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC E1
state_2858:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_174;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_174;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC H
state_2859:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_988;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_988;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC H1
state_2860:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_175;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_175;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC HL
state_2861:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_989;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC HL1
state_2862:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_176;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_176;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC IX
state_2863:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_990;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_990;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC IXH
state_2864:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_991;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_991;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC IXL
state_2865:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_992;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_992;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC IY
state_2866:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_993;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_993;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC IYH
state_2867:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_994;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_994;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC IYL
state_2868:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_995;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_995;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC L
state_2869:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_996;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_996;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC L1
state_2870:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_177;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_177;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC SP
state_2871:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_997;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_997;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen
state_2872:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2873;
	case Keyword::IX: m_lexer.next(); goto state_2879;
	case Keyword::IY: m_lexer.next(); goto state_2883;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen HL
state_2873:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2874;
	case TType::Plus: m_lexer.next(); goto state_2876;
	case TType::RParen: m_lexer.next(); goto state_2878;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen HL Minus
state_2874:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2875;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen HL Minus RParen
state_2875:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_998;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_998;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen HL Plus
state_2876:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2877;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen HL Plus RParen
state_2877:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_999;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_999;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen HL RParen
state_2878:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1000;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1000;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen IX
state_2879:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2880;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2881; }
	/*if (check_expr())*/ goto state_2881;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen IX RParen
state_2880:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1001;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1001;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen IX expr
state_2881:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2882;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen IX expr RParen
state_2882:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1002;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1002;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen IY
state_2883:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2884;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2885; }
	/*if (check_expr())*/ goto state_2885;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen IY RParen
state_2884:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1003;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1003;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen IY expr
state_2885:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2886;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INC LParen IY expr RParen
state_2886:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1004;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1004;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IND
state_2887:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1005;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1005;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INDR
state_2888:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1006;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1006;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INI
state_2889:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1007;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1007;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INIR
state_2890:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1008;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1008;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INR
state_2891:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2892;
	case Keyword::B: m_lexer.next(); goto state_2893;
	case Keyword::C: m_lexer.next(); goto state_2894;
	case Keyword::D: m_lexer.next(); goto state_2895;
	case Keyword::E: m_lexer.next(); goto state_2896;
	case Keyword::H: m_lexer.next(); goto state_2897;
	case Keyword::L: m_lexer.next(); goto state_2898;
	case Keyword::M: m_lexer.next(); goto state_2899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INR A
state_2892:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_981;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_981;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INR B
state_2893:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_982;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_982;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INR C
state_2894:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_984;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_984;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INR D
state_2895:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_985;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_985;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INR E
state_2896:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_987;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_987;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INR H
state_2897:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_988;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_988;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INR L
state_2898:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_996;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_996;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INR M
state_2899:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1000;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1000;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INX
state_2900:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_2901;
	case Keyword::BC: m_lexer.next(); goto state_2902;
	case Keyword::D: m_lexer.next(); goto state_2903;
	case Keyword::DE: m_lexer.next(); goto state_2904;
	case Keyword::H: m_lexer.next(); goto state_2905;
	case Keyword::HL: m_lexer.next(); goto state_2906;
	case Keyword::SP: m_lexer.next(); goto state_2907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INX B
state_2901:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_983;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_983;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INX BC
state_2902:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_983;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_983;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INX D
state_2903:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_986;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_986;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INX DE
state_2904:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_986;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_986;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INX H
state_2905:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_989;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INX HL
state_2906:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_989;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: INX SP
state_2907:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_997;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_997;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE
state_2908:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::ADC: m_lexer.next(); goto state_2909;
	case Keyword::ADD: m_lexer.next(); goto state_2959;
	case Keyword::ALTD: m_lexer.next(); goto state_3009;
	case Keyword::AND: m_lexer.next(); goto state_3587;
	case Keyword::BIT: m_lexer.next(); goto state_3637;
	case Keyword::CMP: m_lexer.next(); goto state_3651;
	case Keyword::CP: m_lexer.next(); goto state_3684;
	case Keyword::DEC: m_lexer.next(); goto state_3717;
	case Keyword::INC: m_lexer.next(); goto state_3733;
	case Keyword::LD: m_lexer.next(); goto state_3749;
	case Keyword::LDD: m_lexer.next(); goto state_4263;
	case Keyword::LDDR: m_lexer.next(); goto state_4323;
	case Keyword::LDDSR: m_lexer.next(); goto state_4324;
	case Keyword::LDI: m_lexer.next(); goto state_4325;
	case Keyword::LDIR: m_lexer.next(); goto state_4385;
	case Keyword::LDISR: m_lexer.next(); goto state_4386;
	case Keyword::LSDDR: m_lexer.next(); goto state_4387;
	case Keyword::LSDR: m_lexer.next(); goto state_4388;
	case Keyword::LSIDR: m_lexer.next(); goto state_4389;
	case Keyword::LSIR: m_lexer.next(); goto state_4390;
	case Keyword::OR: m_lexer.next(); goto state_4391;
	case Keyword::RES: m_lexer.next(); goto state_4441;
	case Keyword::RL: m_lexer.next(); goto state_4455;
	case Keyword::RLC: m_lexer.next(); goto state_4467;
	case Keyword::RR: m_lexer.next(); goto state_4479;
	case Keyword::RRC: m_lexer.next(); goto state_4491;
	case Keyword::SBC: m_lexer.next(); goto state_4503;
	case Keyword::SET: m_lexer.next(); goto state_4553;
	case Keyword::SLA: m_lexer.next(); goto state_4567;
	case Keyword::SRA: m_lexer.next(); goto state_4579;
	case Keyword::SRL: m_lexer.next(); goto state_4591;
	case Keyword::SUB: m_lexer.next(); goto state_4603;
	case Keyword::XOR: m_lexer.next(); goto state_4653;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC
state_2909:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2910;
	case Keyword::A1: m_lexer.next(); goto state_2927;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2944;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A
state_2910:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma
state_2911:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen
state_2912:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2913;
	case Keyword::IX: m_lexer.next(); goto state_2919;
	case Keyword::IY: m_lexer.next(); goto state_2923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen HL
state_2913:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2914;
	case TType::Plus: m_lexer.next(); goto state_2916;
	case TType::RParen: m_lexer.next(); goto state_2918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen HL Minus
state_2914:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen HL Minus RParen
state_2915:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1009;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1009;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen HL Plus
state_2916:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen HL Plus RParen
state_2917:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1010;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1010;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen HL RParen
state_2918:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1011;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1011;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen IX
state_2919:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2920;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2921; }
	/*if (check_expr())*/ goto state_2921;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen IX RParen
state_2920:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1012;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1012;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen IX expr
state_2921:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2922;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen IX expr RParen
state_2922:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1013;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1013;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen IY
state_2923:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2924;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2925; }
	/*if (check_expr())*/ goto state_2925;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen IY RParen
state_2924:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1014;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1014;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen IY expr
state_2925:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A Comma LParen IY expr RParen
state_2926:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1015;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1015;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1
state_2927:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2928;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma
state_2928:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2929;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen
state_2929:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2930;
	case Keyword::IX: m_lexer.next(); goto state_2936;
	case Keyword::IY: m_lexer.next(); goto state_2940;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen HL
state_2930:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2931;
	case TType::Plus: m_lexer.next(); goto state_2933;
	case TType::RParen: m_lexer.next(); goto state_2935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen HL Minus
state_2931:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen HL Minus RParen
state_2932:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1016;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1016;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen HL Plus
state_2933:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen HL Plus RParen
state_2934:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1017;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1017;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen HL RParen
state_2935:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1018;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1018;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen IX
state_2936:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2937;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2938; }
	/*if (check_expr())*/ goto state_2938;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen IX RParen
state_2937:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1019;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1019;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen IX expr
state_2938:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2939;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen IX expr RParen
state_2939:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1020;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1020;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen IY
state_2940:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2941;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2942; }
	/*if (check_expr())*/ goto state_2942;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen IY RParen
state_2941:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1021;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1021;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen IY expr
state_2942:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2943;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC A1 Comma LParen IY expr RParen
state_2943:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1022;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1022;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen
state_2944:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2945;
	case Keyword::IX: m_lexer.next(); goto state_2951;
	case Keyword::IY: m_lexer.next(); goto state_2955;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen HL
state_2945:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2946;
	case TType::Plus: m_lexer.next(); goto state_2948;
	case TType::RParen: m_lexer.next(); goto state_2950;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen HL Minus
state_2946:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2947;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen HL Minus RParen
state_2947:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1009;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1009;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen HL Plus
state_2948:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2949;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen HL Plus RParen
state_2949:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1010;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1010;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen HL RParen
state_2950:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1011;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1011;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen IX
state_2951:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2952;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2953; }
	/*if (check_expr())*/ goto state_2953;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen IX RParen
state_2952:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1012;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1012;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen IX expr
state_2953:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2954;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen IX expr RParen
state_2954:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1013;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1013;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen IY
state_2955:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2956;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2957; }
	/*if (check_expr())*/ goto state_2957;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen IY RParen
state_2956:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1014;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1014;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen IY expr
state_2957:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2958;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADC LParen IY expr RParen
state_2958:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1015;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1015;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD
state_2959:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_2960;
	case Keyword::A1: m_lexer.next(); goto state_2977;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2994;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A
state_2960:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2961;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma
state_2961:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2962;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen
state_2962:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2963;
	case Keyword::IX: m_lexer.next(); goto state_2969;
	case Keyword::IY: m_lexer.next(); goto state_2973;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen HL
state_2963:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2964;
	case TType::Plus: m_lexer.next(); goto state_2966;
	case TType::RParen: m_lexer.next(); goto state_2968;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen HL Minus
state_2964:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2965;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen HL Minus RParen
state_2965:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1023;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1023;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen HL Plus
state_2966:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2967;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen HL Plus RParen
state_2967:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1024;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1024;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen HL RParen
state_2968:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1025;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1025;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen IX
state_2969:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2970;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2971; }
	/*if (check_expr())*/ goto state_2971;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen IX RParen
state_2970:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1026;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1026;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen IX expr
state_2971:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2972;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen IX expr RParen
state_2972:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1027;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1027;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen IY
state_2973:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2974;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2975; }
	/*if (check_expr())*/ goto state_2975;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen IY RParen
state_2974:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1028;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1028;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen IY expr
state_2975:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2976;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A Comma LParen IY expr RParen
state_2976:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1029;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1029;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1
state_2977:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_2978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma
state_2978:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_2979;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen
state_2979:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2980;
	case Keyword::IX: m_lexer.next(); goto state_2986;
	case Keyword::IY: m_lexer.next(); goto state_2990;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen HL
state_2980:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2981;
	case TType::Plus: m_lexer.next(); goto state_2983;
	case TType::RParen: m_lexer.next(); goto state_2985;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen HL Minus
state_2981:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2982;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen HL Minus RParen
state_2982:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1030;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1030;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen HL Plus
state_2983:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2984;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen HL Plus RParen
state_2984:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1031;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1031;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen HL RParen
state_2985:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1032;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1032;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen IX
state_2986:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2987;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2988; }
	/*if (check_expr())*/ goto state_2988;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen IX RParen
state_2987:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1033;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1033;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen IX expr
state_2988:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen IX expr RParen
state_2989:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1034;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1034;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen IY
state_2990:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2991;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_2992; }
	/*if (check_expr())*/ goto state_2992;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen IY RParen
state_2991:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1035;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1035;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen IY expr
state_2992:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2993;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD A1 Comma LParen IY expr RParen
state_2993:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1036;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1036;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen
state_2994:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_2995;
	case Keyword::IX: m_lexer.next(); goto state_3001;
	case Keyword::IY: m_lexer.next(); goto state_3005;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen HL
state_2995:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_2996;
	case TType::Plus: m_lexer.next(); goto state_2998;
	case TType::RParen: m_lexer.next(); goto state_3000;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen HL Minus
state_2996:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2997;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen HL Minus RParen
state_2997:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1023;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1023;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen HL Plus
state_2998:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_2999;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen HL Plus RParen
state_2999:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1024;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1024;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen HL RParen
state_3000:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1025;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1025;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen IX
state_3001:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3002;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3003; }
	/*if (check_expr())*/ goto state_3003;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen IX RParen
state_3002:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1026;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1026;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen IX expr
state_3003:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3004;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen IX expr RParen
state_3004:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1027;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1027;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen IY
state_3005:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3006;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3007; }
	/*if (check_expr())*/ goto state_3007;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen IY RParen
state_3006:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1028;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1028;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen IY expr
state_3007:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3008;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ADD LParen IY expr RParen
state_3008:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1029;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1029;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD
state_3009:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::ADC: m_lexer.next(); goto state_3010;
	case Keyword::ADD: m_lexer.next(); goto state_3043;
	case Keyword::AND: m_lexer.next(); goto state_3076;
	case Keyword::BIT: m_lexer.next(); goto state_3109;
	case Keyword::CP: m_lexer.next(); goto state_3123;
	case Keyword::DEC: m_lexer.next(); goto state_3156;
	case Keyword::INC: m_lexer.next(); goto state_3172;
	case Keyword::LD: m_lexer.next(); goto state_3188;
	case Keyword::OR: m_lexer.next(); goto state_3371;
	case Keyword::RL: m_lexer.next(); goto state_3404;
	case Keyword::RLC: m_lexer.next(); goto state_3416;
	case Keyword::RR: m_lexer.next(); goto state_3428;
	case Keyword::RRC: m_lexer.next(); goto state_3440;
	case Keyword::SBC: m_lexer.next(); goto state_3452;
	case Keyword::SLA: m_lexer.next(); goto state_3485;
	case Keyword::SRA: m_lexer.next(); goto state_3497;
	case Keyword::SRL: m_lexer.next(); goto state_3509;
	case Keyword::SUB: m_lexer.next(); goto state_3521;
	case Keyword::XOR: m_lexer.next(); goto state_3554;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC
state_3010:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3011;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3028;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A
state_3011:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3012;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma
state_3012:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3013;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen
state_3013:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3014;
	case Keyword::IX: m_lexer.next(); goto state_3020;
	case Keyword::IY: m_lexer.next(); goto state_3024;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen HL
state_3014:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3015;
	case TType::Plus: m_lexer.next(); goto state_3017;
	case TType::RParen: m_lexer.next(); goto state_3019;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen HL Minus
state_3015:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3016;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen HL Minus RParen
state_3016:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1016;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1016;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen HL Plus
state_3017:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3018;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen HL Plus RParen
state_3018:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1017;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1017;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen HL RParen
state_3019:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1018;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1018;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen IX
state_3020:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3021;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3022; }
	/*if (check_expr())*/ goto state_3022;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen IX RParen
state_3021:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1019;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1019;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen IX expr
state_3022:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3023;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen IX expr RParen
state_3023:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1020;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1020;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen IY
state_3024:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3025;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3026; }
	/*if (check_expr())*/ goto state_3026;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen IY RParen
state_3025:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1021;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1021;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen IY expr
state_3026:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3027;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC A Comma LParen IY expr RParen
state_3027:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1022;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1022;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen
state_3028:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3029;
	case Keyword::IX: m_lexer.next(); goto state_3035;
	case Keyword::IY: m_lexer.next(); goto state_3039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen HL
state_3029:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3030;
	case TType::Plus: m_lexer.next(); goto state_3032;
	case TType::RParen: m_lexer.next(); goto state_3034;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen HL Minus
state_3030:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3031;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen HL Minus RParen
state_3031:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1016;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1016;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen HL Plus
state_3032:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3033;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen HL Plus RParen
state_3033:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1017;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1017;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen HL RParen
state_3034:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1018;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1018;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen IX
state_3035:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3036;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3037; }
	/*if (check_expr())*/ goto state_3037;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen IX RParen
state_3036:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1019;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1019;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen IX expr
state_3037:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3038;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen IX expr RParen
state_3038:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1020;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1020;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen IY
state_3039:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3040;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3041; }
	/*if (check_expr())*/ goto state_3041;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen IY RParen
state_3040:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1021;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1021;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen IY expr
state_3041:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3042;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADC LParen IY expr RParen
state_3042:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1022;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1022;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD
state_3043:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3044;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3061;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A
state_3044:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3045;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma
state_3045:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3046;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen
state_3046:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3047;
	case Keyword::IX: m_lexer.next(); goto state_3053;
	case Keyword::IY: m_lexer.next(); goto state_3057;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen HL
state_3047:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3048;
	case TType::Plus: m_lexer.next(); goto state_3050;
	case TType::RParen: m_lexer.next(); goto state_3052;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen HL Minus
state_3048:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3049;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen HL Minus RParen
state_3049:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1030;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1030;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen HL Plus
state_3050:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3051;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen HL Plus RParen
state_3051:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1031;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1031;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen HL RParen
state_3052:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1032;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1032;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen IX
state_3053:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3054;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3055; }
	/*if (check_expr())*/ goto state_3055;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen IX RParen
state_3054:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1033;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1033;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen IX expr
state_3055:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3056;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen IX expr RParen
state_3056:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1034;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1034;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen IY
state_3057:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3058;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3059; }
	/*if (check_expr())*/ goto state_3059;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen IY RParen
state_3058:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1035;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1035;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen IY expr
state_3059:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3060;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD A Comma LParen IY expr RParen
state_3060:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1036;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1036;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen
state_3061:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3062;
	case Keyword::IX: m_lexer.next(); goto state_3068;
	case Keyword::IY: m_lexer.next(); goto state_3072;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen HL
state_3062:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3063;
	case TType::Plus: m_lexer.next(); goto state_3065;
	case TType::RParen: m_lexer.next(); goto state_3067;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen HL Minus
state_3063:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3064;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen HL Minus RParen
state_3064:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1030;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1030;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen HL Plus
state_3065:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3066;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen HL Plus RParen
state_3066:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1031;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1031;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen HL RParen
state_3067:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1032;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1032;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen IX
state_3068:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3069;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3070; }
	/*if (check_expr())*/ goto state_3070;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen IX RParen
state_3069:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1033;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1033;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen IX expr
state_3070:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3071;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen IX expr RParen
state_3071:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1034;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1034;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen IY
state_3072:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3073;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3074; }
	/*if (check_expr())*/ goto state_3074;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen IY RParen
state_3073:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1035;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1035;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen IY expr
state_3074:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD ADD LParen IY expr RParen
state_3075:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1036;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1036;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND
state_3076:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3077;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3094;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A
state_3077:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3078;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma
state_3078:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3079;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen
state_3079:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3080;
	case Keyword::IX: m_lexer.next(); goto state_3086;
	case Keyword::IY: m_lexer.next(); goto state_3090;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen HL
state_3080:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3081;
	case TType::Plus: m_lexer.next(); goto state_3083;
	case TType::RParen: m_lexer.next(); goto state_3085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen HL Minus
state_3081:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3082;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen HL Minus RParen
state_3082:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1037;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1037;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen HL Plus
state_3083:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3084;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen HL Plus RParen
state_3084:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1038;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1038;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen HL RParen
state_3085:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1039;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen IX
state_3086:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3087;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3088; }
	/*if (check_expr())*/ goto state_3088;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen IX RParen
state_3087:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1040;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1040;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen IX expr
state_3088:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3089;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen IX expr RParen
state_3089:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1041;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1041;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen IY
state_3090:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3091;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3092; }
	/*if (check_expr())*/ goto state_3092;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen IY RParen
state_3091:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1042;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1042;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen IY expr
state_3092:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3093;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND A Comma LParen IY expr RParen
state_3093:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1043;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1043;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen
state_3094:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3095;
	case Keyword::IX: m_lexer.next(); goto state_3101;
	case Keyword::IY: m_lexer.next(); goto state_3105;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen HL
state_3095:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3096;
	case TType::Plus: m_lexer.next(); goto state_3098;
	case TType::RParen: m_lexer.next(); goto state_3100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen HL Minus
state_3096:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3097;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen HL Minus RParen
state_3097:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1037;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1037;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen HL Plus
state_3098:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3099;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen HL Plus RParen
state_3099:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1038;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1038;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen HL RParen
state_3100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1039;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen IX
state_3101:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3102;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3103; }
	/*if (check_expr())*/ goto state_3103;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen IX RParen
state_3102:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1040;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1040;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen IX expr
state_3103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen IX expr RParen
state_3104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1041;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1041;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen IY
state_3105:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3106;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3107; }
	/*if (check_expr())*/ goto state_3107;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen IY RParen
state_3106:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1042;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1042;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen IY expr
state_3107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD AND LParen IY expr RParen
state_3108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1043;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1043;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT
state_3109:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3110; }
	/*if (check_const_expr())*/ goto state_3110;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr
state_3110:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma
state_3111:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3112;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen
state_3112:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3113;
	case Keyword::IX: m_lexer.next(); goto state_3115;
	case Keyword::IY: m_lexer.next(); goto state_3119;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen HL
state_3113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen HL RParen
state_3114:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1044;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1044;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen IX
state_3115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3116;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3117; }
	/*if (check_expr())*/ goto state_3117;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen IX RParen
state_3116:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1045;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1045;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen IX expr
state_3117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3118;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen IX expr RParen
state_3118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1046;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1046;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen IY
state_3119:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3120;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3121; }
	/*if (check_expr())*/ goto state_3121;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen IY RParen
state_3120:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1047;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1047;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen IY expr
state_3121:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3122;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD BIT const_expr Comma LParen IY expr RParen
state_3122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1048;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1048;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP
state_3123:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3124;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A
state_3124:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3125;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma
state_3125:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3126;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen
state_3126:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3127;
	case Keyword::IX: m_lexer.next(); goto state_3133;
	case Keyword::IY: m_lexer.next(); goto state_3137;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen HL
state_3127:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3128;
	case TType::Plus: m_lexer.next(); goto state_3130;
	case TType::RParen: m_lexer.next(); goto state_3132;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen HL Minus
state_3128:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen HL Minus RParen
state_3129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1049;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1049;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen HL Plus
state_3130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen HL Plus RParen
state_3131:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1050;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1050;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen HL RParen
state_3132:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1051;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1051;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen IX
state_3133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3134;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3135; }
	/*if (check_expr())*/ goto state_3135;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen IX RParen
state_3134:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1052;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1052;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen IX expr
state_3135:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3136;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen IX expr RParen
state_3136:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1053;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1053;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen IY
state_3137:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3138;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3139; }
	/*if (check_expr())*/ goto state_3139;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen IY RParen
state_3138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1054;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1054;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen IY expr
state_3139:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP A Comma LParen IY expr RParen
state_3140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1055;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1055;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen
state_3141:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3142;
	case Keyword::IX: m_lexer.next(); goto state_3148;
	case Keyword::IY: m_lexer.next(); goto state_3152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen HL
state_3142:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3143;
	case TType::Plus: m_lexer.next(); goto state_3145;
	case TType::RParen: m_lexer.next(); goto state_3147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen HL Minus
state_3143:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3144;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen HL Minus RParen
state_3144:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1049;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1049;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen HL Plus
state_3145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen HL Plus RParen
state_3146:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1050;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1050;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen HL RParen
state_3147:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1051;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1051;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen IX
state_3148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3149;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3150; }
	/*if (check_expr())*/ goto state_3150;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen IX RParen
state_3149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1052;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1052;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen IX expr
state_3150:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen IX expr RParen
state_3151:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1053;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1053;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen IY
state_3152:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3153;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3154; }
	/*if (check_expr())*/ goto state_3154;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen IY RParen
state_3153:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1054;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1054;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen IY expr
state_3154:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3155;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD CP LParen IY expr RParen
state_3155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1055;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1055;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC
state_3156:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3157;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen
state_3157:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3158;
	case Keyword::IX: m_lexer.next(); goto state_3164;
	case Keyword::IY: m_lexer.next(); goto state_3168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen HL
state_3158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3159;
	case TType::Plus: m_lexer.next(); goto state_3161;
	case TType::RParen: m_lexer.next(); goto state_3163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen HL Minus
state_3159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3160;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen HL Minus RParen
state_3160:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1056;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1056;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen HL Plus
state_3161:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen HL Plus RParen
state_3162:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1057;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1057;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen HL RParen
state_3163:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1058;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1058;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen IX
state_3164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3165;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3166; }
	/*if (check_expr())*/ goto state_3166;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen IX RParen
state_3165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1059;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1059;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen IX expr
state_3166:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen IX expr RParen
state_3167:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1060;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1060;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen IY
state_3168:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3169;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3170; }
	/*if (check_expr())*/ goto state_3170;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen IY RParen
state_3169:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1061;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1061;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen IY expr
state_3170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3171;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD DEC LParen IY expr RParen
state_3171:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1062;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1062;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC
state_3172:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3173;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen
state_3173:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3174;
	case Keyword::IX: m_lexer.next(); goto state_3180;
	case Keyword::IY: m_lexer.next(); goto state_3184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen HL
state_3174:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3175;
	case TType::Plus: m_lexer.next(); goto state_3177;
	case TType::RParen: m_lexer.next(); goto state_3179;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen HL Minus
state_3175:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3176;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen HL Minus RParen
state_3176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1063;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1063;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen HL Plus
state_3177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3178;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen HL Plus RParen
state_3178:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1064;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1064;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen HL RParen
state_3179:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1065;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1065;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen IX
state_3180:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3181;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3182; }
	/*if (check_expr())*/ goto state_3182;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen IX RParen
state_3181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1066;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1066;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen IX expr
state_3182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3183;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen IX expr RParen
state_3183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1067;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1067;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen IY
state_3184:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3185;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3186; }
	/*if (check_expr())*/ goto state_3186;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen IY RParen
state_3185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1068;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1068;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen IY expr
state_3186:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD INC LParen IY expr RParen
state_3187:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1069;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1069;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD
state_3188:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3189;
	case Keyword::B: m_lexer.next(); goto state_3223;
	case Keyword::BC: m_lexer.next(); goto state_3244;
	case Keyword::C: m_lexer.next(); goto state_3247;
	case Keyword::D: m_lexer.next(); goto state_3268;
	case Keyword::DE: m_lexer.next(); goto state_3289;
	case Keyword::E: m_lexer.next(); goto state_3292;
	case Keyword::H: m_lexer.next(); goto state_3313;
	case Keyword::HL: m_lexer.next(); goto state_3334;
	case Keyword::L: m_lexer.next(); goto state_3350;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A
state_3189:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma
state_3190:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3191;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3222; }
	/*if (check_expr())*/ goto state_3222;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen
state_3191:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_3192;
	case Keyword::DE: m_lexer.next(); goto state_3198;
	case Keyword::HL: m_lexer.next(); goto state_3204;
	case Keyword::HLD: m_lexer.next(); goto state_3210;
	case Keyword::HLI: m_lexer.next(); goto state_3212;
	case Keyword::IX: m_lexer.next(); goto state_3214;
	case Keyword::IY: m_lexer.next(); goto state_3218;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen BC
state_3192:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3193;
	case TType::Plus: m_lexer.next(); goto state_3195;
	case TType::RParen: m_lexer.next(); goto state_3197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen BC Minus
state_3193:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen BC Minus RParen
state_3194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1070;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1070;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen BC Plus
state_3195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen BC Plus RParen
state_3196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1071;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1071;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen BC RParen
state_3197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1072;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1072;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen DE
state_3198:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3199;
	case TType::Plus: m_lexer.next(); goto state_3201;
	case TType::RParen: m_lexer.next(); goto state_3203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen DE Minus
state_3199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen DE Minus RParen
state_3200:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1073;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1073;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen DE Plus
state_3201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3202;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen DE Plus RParen
state_3202:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1074;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1074;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen DE RParen
state_3203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1075;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HL
state_3204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3205;
	case TType::Plus: m_lexer.next(); goto state_3207;
	case TType::RParen: m_lexer.next(); goto state_3209;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HL Minus
state_3205:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3206;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HL Minus RParen
state_3206:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1076;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1076;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HL Plus
state_3207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3208;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HL Plus RParen
state_3208:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1077;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1077;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HL RParen
state_3209:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1078;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1078;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HLD
state_3210:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HLD RParen
state_3211:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1076;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1076;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HLI
state_3212:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen HLI RParen
state_3213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1077;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1077;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen IX
state_3214:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3215;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3216; }
	/*if (check_expr())*/ goto state_3216;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen IX RParen
state_3215:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1079;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1079;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen IX expr
state_3216:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3217;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen IX expr RParen
state_3217:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1080;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1080;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen IY
state_3218:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3219;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3220; }
	/*if (check_expr())*/ goto state_3220;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen IY RParen
state_3219:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1081;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1081;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen IY expr
state_3220:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3221;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma LParen IY expr RParen
state_3221:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1082;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1082;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD A Comma expr
state_3222:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1083;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1083;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B
state_3223:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3224;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma
state_3224:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3225;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen
state_3225:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3226;
	case Keyword::HLD: m_lexer.next(); goto state_3232;
	case Keyword::HLI: m_lexer.next(); goto state_3234;
	case Keyword::IX: m_lexer.next(); goto state_3236;
	case Keyword::IY: m_lexer.next(); goto state_3240;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HL
state_3226:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3227;
	case TType::Plus: m_lexer.next(); goto state_3229;
	case TType::RParen: m_lexer.next(); goto state_3231;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HL Minus
state_3227:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3228;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HL Minus RParen
state_3228:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1084;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1084;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HL Plus
state_3229:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3230;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HL Plus RParen
state_3230:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1085;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HL RParen
state_3231:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1086;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1086;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HLD
state_3232:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3233;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HLD RParen
state_3233:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1084;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1084;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HLI
state_3234:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3235;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen HLI RParen
state_3235:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1085;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen IX
state_3236:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3237;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3238; }
	/*if (check_expr())*/ goto state_3238;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen IX RParen
state_3237:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1087;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1087;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen IX expr
state_3238:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3239;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen IX expr RParen
state_3239:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1088;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1088;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen IY
state_3240:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3241;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3242; }
	/*if (check_expr())*/ goto state_3242;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen IY RParen
state_3241:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1089;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1089;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen IY expr
state_3242:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3243;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD B Comma LParen IY expr RParen
state_3243:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1090;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1090;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD BC
state_3244:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3245;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD BC Comma
state_3245:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3246; }
	/*if (check_expr())*/ goto state_3246;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD BC Comma expr
state_3246:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1091;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1091;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C
state_3247:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3248;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma
state_3248:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3249;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen
state_3249:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3250;
	case Keyword::HLD: m_lexer.next(); goto state_3256;
	case Keyword::HLI: m_lexer.next(); goto state_3258;
	case Keyword::IX: m_lexer.next(); goto state_3260;
	case Keyword::IY: m_lexer.next(); goto state_3264;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HL
state_3250:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3251;
	case TType::Plus: m_lexer.next(); goto state_3253;
	case TType::RParen: m_lexer.next(); goto state_3255;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HL Minus
state_3251:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3252;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HL Minus RParen
state_3252:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1092;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1092;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HL Plus
state_3253:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3254;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HL Plus RParen
state_3254:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1093;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1093;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HL RParen
state_3255:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1094;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1094;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HLD
state_3256:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3257;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HLD RParen
state_3257:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1092;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1092;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HLI
state_3258:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3259;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen HLI RParen
state_3259:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1093;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1093;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen IX
state_3260:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3261;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3262; }
	/*if (check_expr())*/ goto state_3262;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen IX RParen
state_3261:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1095;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1095;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen IX expr
state_3262:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3263;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen IX expr RParen
state_3263:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1096;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1096;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen IY
state_3264:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3265;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3266; }
	/*if (check_expr())*/ goto state_3266;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen IY RParen
state_3265:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1097;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1097;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen IY expr
state_3266:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3267;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD C Comma LParen IY expr RParen
state_3267:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1098;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1098;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D
state_3268:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma
state_3269:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen
state_3270:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3271;
	case Keyword::HLD: m_lexer.next(); goto state_3277;
	case Keyword::HLI: m_lexer.next(); goto state_3279;
	case Keyword::IX: m_lexer.next(); goto state_3281;
	case Keyword::IY: m_lexer.next(); goto state_3285;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HL
state_3271:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3272;
	case TType::Plus: m_lexer.next(); goto state_3274;
	case TType::RParen: m_lexer.next(); goto state_3276;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HL Minus
state_3272:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3273;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HL Minus RParen
state_3273:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1099;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1099;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HL Plus
state_3274:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HL Plus RParen
state_3275:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1100;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HL RParen
state_3276:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1101;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1101;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HLD
state_3277:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3278;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HLD RParen
state_3278:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1099;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1099;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HLI
state_3279:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3280;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen HLI RParen
state_3280:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1100;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen IX
state_3281:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3282;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3283; }
	/*if (check_expr())*/ goto state_3283;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen IX RParen
state_3282:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1102;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1102;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen IX expr
state_3283:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3284;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen IX expr RParen
state_3284:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1103;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1103;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen IY
state_3285:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3286;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3287; }
	/*if (check_expr())*/ goto state_3287;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen IY RParen
state_3286:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1104;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen IY expr
state_3287:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3288;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD D Comma LParen IY expr RParen
state_3288:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1105;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1105;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD DE
state_3289:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3290;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD DE Comma
state_3290:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3291; }
	/*if (check_expr())*/ goto state_3291;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD DE Comma expr
state_3291:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1106;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1106;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E
state_3292:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3293;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma
state_3293:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3294;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen
state_3294:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3295;
	case Keyword::HLD: m_lexer.next(); goto state_3301;
	case Keyword::HLI: m_lexer.next(); goto state_3303;
	case Keyword::IX: m_lexer.next(); goto state_3305;
	case Keyword::IY: m_lexer.next(); goto state_3309;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HL
state_3295:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3296;
	case TType::Plus: m_lexer.next(); goto state_3298;
	case TType::RParen: m_lexer.next(); goto state_3300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HL Minus
state_3296:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3297;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HL Minus RParen
state_3297:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1107;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HL Plus
state_3298:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HL Plus RParen
state_3299:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1108;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HL RParen
state_3300:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1109;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HLD
state_3301:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3302;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HLD RParen
state_3302:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1107;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HLI
state_3303:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3304;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen HLI RParen
state_3304:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1108;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen IX
state_3305:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3306;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3307; }
	/*if (check_expr())*/ goto state_3307;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen IX RParen
state_3306:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1110;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1110;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen IX expr
state_3307:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3308;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen IX expr RParen
state_3308:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1111;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen IY
state_3309:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3310;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3311; }
	/*if (check_expr())*/ goto state_3311;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen IY RParen
state_3310:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1112;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1112;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen IY expr
state_3311:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3312;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD E Comma LParen IY expr RParen
state_3312:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1113;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1113;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H
state_3313:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3314;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma
state_3314:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen
state_3315:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3316;
	case Keyword::HLD: m_lexer.next(); goto state_3322;
	case Keyword::HLI: m_lexer.next(); goto state_3324;
	case Keyword::IX: m_lexer.next(); goto state_3326;
	case Keyword::IY: m_lexer.next(); goto state_3330;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HL
state_3316:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3317;
	case TType::Plus: m_lexer.next(); goto state_3319;
	case TType::RParen: m_lexer.next(); goto state_3321;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HL Minus
state_3317:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3318;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HL Minus RParen
state_3318:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1114;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HL Plus
state_3319:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3320;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HL Plus RParen
state_3320:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1115;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HL RParen
state_3321:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1116;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1116;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HLD
state_3322:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3323;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HLD RParen
state_3323:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1114;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HLI
state_3324:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3325;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen HLI RParen
state_3325:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1115;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen IX
state_3326:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3327;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3328; }
	/*if (check_expr())*/ goto state_3328;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen IX RParen
state_3327:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1117;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1117;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen IX expr
state_3328:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3329;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen IX expr RParen
state_3329:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1118;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1118;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen IY
state_3330:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3331;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3332; }
	/*if (check_expr())*/ goto state_3332;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen IY RParen
state_3331:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1119;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1119;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen IY expr
state_3332:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3333;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD H Comma LParen IY expr RParen
state_3333:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1120;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1120;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL
state_3334:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3335;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma
state_3335:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3336;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3349; }
	/*if (check_expr())*/ goto state_3349;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen
state_3336:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3337;
	case Keyword::IX: m_lexer.next(); goto state_3341;
	case Keyword::IY: m_lexer.next(); goto state_3345;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen HL
state_3337:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3338;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3339; }
	/*if (check_expr())*/ goto state_3339;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen HL RParen
state_3338:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1121;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1121;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen HL expr
state_3339:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3340;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen HL expr RParen
state_3340:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1122;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1122;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen IX
state_3341:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3342;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3343; }
	/*if (check_expr())*/ goto state_3343;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen IX RParen
state_3342:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1123;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1123;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen IX expr
state_3343:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3344;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen IX expr RParen
state_3344:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1124;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1124;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen IY
state_3345:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3346;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3347; }
	/*if (check_expr())*/ goto state_3347;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen IY RParen
state_3346:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1125;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1125;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen IY expr
state_3347:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma LParen IY expr RParen
state_3348:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1126;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1126;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD HL Comma expr
state_3349:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1127;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1127;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L
state_3350:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma
state_3351:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3352;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen
state_3352:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3353;
	case Keyword::HLD: m_lexer.next(); goto state_3359;
	case Keyword::HLI: m_lexer.next(); goto state_3361;
	case Keyword::IX: m_lexer.next(); goto state_3363;
	case Keyword::IY: m_lexer.next(); goto state_3367;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HL
state_3353:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3354;
	case TType::Plus: m_lexer.next(); goto state_3356;
	case TType::RParen: m_lexer.next(); goto state_3358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HL Minus
state_3354:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3355;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HL Minus RParen
state_3355:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1128;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HL Plus
state_3356:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HL Plus RParen
state_3357:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1129;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HL RParen
state_3358:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1130;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1130;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HLD
state_3359:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3360;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HLD RParen
state_3360:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1128;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HLI
state_3361:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3362;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen HLI RParen
state_3362:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1129;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen IX
state_3363:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3364;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3365; }
	/*if (check_expr())*/ goto state_3365;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen IX RParen
state_3364:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1131;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen IX expr
state_3365:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3366;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen IX expr RParen
state_3366:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1132;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1132;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen IY
state_3367:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3368;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3369; }
	/*if (check_expr())*/ goto state_3369;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen IY RParen
state_3368:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1133;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1133;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen IY expr
state_3369:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3370;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD LD L Comma LParen IY expr RParen
state_3370:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1134;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1134;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR
state_3371:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3372;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3389;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A
state_3372:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3373;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma
state_3373:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3374;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen
state_3374:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3375;
	case Keyword::IX: m_lexer.next(); goto state_3381;
	case Keyword::IY: m_lexer.next(); goto state_3385;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen HL
state_3375:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3376;
	case TType::Plus: m_lexer.next(); goto state_3378;
	case TType::RParen: m_lexer.next(); goto state_3380;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen HL Minus
state_3376:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3377;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen HL Minus RParen
state_3377:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1135;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen HL Plus
state_3378:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3379;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen HL Plus RParen
state_3379:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1136;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1136;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen HL RParen
state_3380:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1137;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1137;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen IX
state_3381:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3382;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3383; }
	/*if (check_expr())*/ goto state_3383;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen IX RParen
state_3382:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1138;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen IX expr
state_3383:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3384;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen IX expr RParen
state_3384:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1139;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen IY
state_3385:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3386;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3387; }
	/*if (check_expr())*/ goto state_3387;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen IY RParen
state_3386:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1140;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen IY expr
state_3387:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3388;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR A Comma LParen IY expr RParen
state_3388:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1141;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen
state_3389:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3390;
	case Keyword::IX: m_lexer.next(); goto state_3396;
	case Keyword::IY: m_lexer.next(); goto state_3400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen HL
state_3390:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3391;
	case TType::Plus: m_lexer.next(); goto state_3393;
	case TType::RParen: m_lexer.next(); goto state_3395;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen HL Minus
state_3391:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3392;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen HL Minus RParen
state_3392:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1135;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen HL Plus
state_3393:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3394;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen HL Plus RParen
state_3394:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1136;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1136;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen HL RParen
state_3395:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1137;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1137;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen IX
state_3396:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3397;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3398; }
	/*if (check_expr())*/ goto state_3398;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen IX RParen
state_3397:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1138;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen IX expr
state_3398:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3399;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen IX expr RParen
state_3399:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1139;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen IY
state_3400:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3401;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3402; }
	/*if (check_expr())*/ goto state_3402;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen IY RParen
state_3401:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1140;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen IY expr
state_3402:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3403;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD OR LParen IY expr RParen
state_3403:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1141;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL
state_3404:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3405;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen
state_3405:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3406;
	case Keyword::IX: m_lexer.next(); goto state_3408;
	case Keyword::IY: m_lexer.next(); goto state_3412;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen HL
state_3406:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3407;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen HL RParen
state_3407:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1142;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1142;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen IX
state_3408:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3409;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3410; }
	/*if (check_expr())*/ goto state_3410;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen IX RParen
state_3409:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1143;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1143;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen IX expr
state_3410:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3411;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen IX expr RParen
state_3411:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1144;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1144;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen IY
state_3412:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3413;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3414; }
	/*if (check_expr())*/ goto state_3414;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen IY RParen
state_3413:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1145;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1145;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen IY expr
state_3414:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3415;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RL LParen IY expr RParen
state_3415:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1146;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC
state_3416:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen
state_3417:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3418;
	case Keyword::IX: m_lexer.next(); goto state_3420;
	case Keyword::IY: m_lexer.next(); goto state_3424;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen HL
state_3418:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3419;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen HL RParen
state_3419:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1147;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen IX
state_3420:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3421;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3422; }
	/*if (check_expr())*/ goto state_3422;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen IX RParen
state_3421:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1148;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1148;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen IX expr
state_3422:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3423;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen IX expr RParen
state_3423:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1149;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1149;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen IY
state_3424:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3425;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3426; }
	/*if (check_expr())*/ goto state_3426;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen IY RParen
state_3425:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1150;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1150;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen IY expr
state_3426:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3427;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RLC LParen IY expr RParen
state_3427:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1151;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR
state_3428:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3429;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen
state_3429:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3430;
	case Keyword::IX: m_lexer.next(); goto state_3432;
	case Keyword::IY: m_lexer.next(); goto state_3436;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen HL
state_3430:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3431;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen HL RParen
state_3431:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1152;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen IX
state_3432:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3433;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3434; }
	/*if (check_expr())*/ goto state_3434;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen IX RParen
state_3433:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1153;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1153;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen IX expr
state_3434:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3435;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen IX expr RParen
state_3435:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1154;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1154;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen IY
state_3436:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3437;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3438; }
	/*if (check_expr())*/ goto state_3438;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen IY RParen
state_3437:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1155;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1155;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen IY expr
state_3438:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3439;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RR LParen IY expr RParen
state_3439:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1156;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1156;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC
state_3440:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3441;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen
state_3441:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3442;
	case Keyword::IX: m_lexer.next(); goto state_3444;
	case Keyword::IY: m_lexer.next(); goto state_3448;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen HL
state_3442:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3443;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen HL RParen
state_3443:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1157;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1157;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen IX
state_3444:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3445;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3446; }
	/*if (check_expr())*/ goto state_3446;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen IX RParen
state_3445:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1158;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1158;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen IX expr
state_3446:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3447;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen IX expr RParen
state_3447:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1159;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1159;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen IY
state_3448:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3449;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3450; }
	/*if (check_expr())*/ goto state_3450;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen IY RParen
state_3449:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1160;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1160;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen IY expr
state_3450:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD RRC LParen IY expr RParen
state_3451:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1161;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1161;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC
state_3452:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3453;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A
state_3453:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma
state_3454:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3455;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen
state_3455:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3456;
	case Keyword::IX: m_lexer.next(); goto state_3462;
	case Keyword::IY: m_lexer.next(); goto state_3466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen HL
state_3456:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3457;
	case TType::Plus: m_lexer.next(); goto state_3459;
	case TType::RParen: m_lexer.next(); goto state_3461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen HL Minus
state_3457:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3458;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen HL Minus RParen
state_3458:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1162;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen HL Plus
state_3459:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3460;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen HL Plus RParen
state_3460:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1163;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen HL RParen
state_3461:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1164;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1164;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen IX
state_3462:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3463;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3464; }
	/*if (check_expr())*/ goto state_3464;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen IX RParen
state_3463:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1165;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen IX expr
state_3464:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen IX expr RParen
state_3465:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1166;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen IY
state_3466:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3467;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3468; }
	/*if (check_expr())*/ goto state_3468;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen IY RParen
state_3467:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1167;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen IY expr
state_3468:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC A Comma LParen IY expr RParen
state_3469:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1168;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen
state_3470:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3471;
	case Keyword::IX: m_lexer.next(); goto state_3477;
	case Keyword::IY: m_lexer.next(); goto state_3481;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen HL
state_3471:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3472;
	case TType::Plus: m_lexer.next(); goto state_3474;
	case TType::RParen: m_lexer.next(); goto state_3476;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen HL Minus
state_3472:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3473;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen HL Minus RParen
state_3473:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1162;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen HL Plus
state_3474:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen HL Plus RParen
state_3475:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1163;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen HL RParen
state_3476:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1164;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1164;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen IX
state_3477:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3478;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3479; }
	/*if (check_expr())*/ goto state_3479;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen IX RParen
state_3478:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1165;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen IX expr
state_3479:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3480;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen IX expr RParen
state_3480:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1166;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen IY
state_3481:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3482;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3483; }
	/*if (check_expr())*/ goto state_3483;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen IY RParen
state_3482:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1167;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen IY expr
state_3483:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3484;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SBC LParen IY expr RParen
state_3484:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1168;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA
state_3485:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen
state_3486:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3487;
	case Keyword::IX: m_lexer.next(); goto state_3489;
	case Keyword::IY: m_lexer.next(); goto state_3493;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen HL
state_3487:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen HL RParen
state_3488:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1169;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1169;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen IX
state_3489:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3490;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3491; }
	/*if (check_expr())*/ goto state_3491;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen IX RParen
state_3490:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1170;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1170;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen IX expr
state_3491:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3492;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen IX expr RParen
state_3492:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1171;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1171;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen IY
state_3493:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3494;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3495; }
	/*if (check_expr())*/ goto state_3495;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen IY RParen
state_3494:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1172;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1172;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen IY expr
state_3495:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3496;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SLA LParen IY expr RParen
state_3496:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1173;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1173;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA
state_3497:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3498;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen
state_3498:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3499;
	case Keyword::IX: m_lexer.next(); goto state_3501;
	case Keyword::IY: m_lexer.next(); goto state_3505;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen HL
state_3499:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen HL RParen
state_3500:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1174;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1174;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen IX
state_3501:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3502;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3503; }
	/*if (check_expr())*/ goto state_3503;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen IX RParen
state_3502:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1175;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1175;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen IX expr
state_3503:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3504;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen IX expr RParen
state_3504:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1176;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1176;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen IY
state_3505:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3506;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3507; }
	/*if (check_expr())*/ goto state_3507;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen IY RParen
state_3506:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1177;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1177;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen IY expr
state_3507:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3508;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRA LParen IY expr RParen
state_3508:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1178;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1178;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL
state_3509:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3510;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen
state_3510:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3511;
	case Keyword::IX: m_lexer.next(); goto state_3513;
	case Keyword::IY: m_lexer.next(); goto state_3517;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen HL
state_3511:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3512;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen HL RParen
state_3512:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1179;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1179;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen IX
state_3513:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3514;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3515; }
	/*if (check_expr())*/ goto state_3515;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen IX RParen
state_3514:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1180;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1180;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen IX expr
state_3515:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3516;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen IX expr RParen
state_3516:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1181;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1181;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen IY
state_3517:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3518;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3519; }
	/*if (check_expr())*/ goto state_3519;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen IY RParen
state_3518:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1182;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1182;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen IY expr
state_3519:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3520;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SRL LParen IY expr RParen
state_3520:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1183;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1183;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB
state_3521:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3522;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3539;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A
state_3522:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma
state_3523:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen
state_3524:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3525;
	case Keyword::IX: m_lexer.next(); goto state_3531;
	case Keyword::IY: m_lexer.next(); goto state_3535;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen HL
state_3525:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3526;
	case TType::Plus: m_lexer.next(); goto state_3528;
	case TType::RParen: m_lexer.next(); goto state_3530;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen HL Minus
state_3526:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3527;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen HL Minus RParen
state_3527:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1184;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen HL Plus
state_3528:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3529;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen HL Plus RParen
state_3529:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1185;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen HL RParen
state_3530:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1186;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1186;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen IX
state_3531:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3532;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3533; }
	/*if (check_expr())*/ goto state_3533;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen IX RParen
state_3532:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1187;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen IX expr
state_3533:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen IX expr RParen
state_3534:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1188;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen IY
state_3535:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3536;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3537; }
	/*if (check_expr())*/ goto state_3537;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen IY RParen
state_3536:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1189;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen IY expr
state_3537:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3538;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB A Comma LParen IY expr RParen
state_3538:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1190;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen
state_3539:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3540;
	case Keyword::IX: m_lexer.next(); goto state_3546;
	case Keyword::IY: m_lexer.next(); goto state_3550;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen HL
state_3540:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3541;
	case TType::Plus: m_lexer.next(); goto state_3543;
	case TType::RParen: m_lexer.next(); goto state_3545;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen HL Minus
state_3541:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3542;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen HL Minus RParen
state_3542:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1184;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen HL Plus
state_3543:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3544;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen HL Plus RParen
state_3544:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1185;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen HL RParen
state_3545:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1186;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1186;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen IX
state_3546:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3547;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3548; }
	/*if (check_expr())*/ goto state_3548;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen IX RParen
state_3547:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1187;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen IX expr
state_3548:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen IX expr RParen
state_3549:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1188;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen IY
state_3550:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3551;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3552; }
	/*if (check_expr())*/ goto state_3552;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen IY RParen
state_3551:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1189;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen IY expr
state_3552:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3553;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD SUB LParen IY expr RParen
state_3553:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1190;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR
state_3554:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3555;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3572;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A
state_3555:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma
state_3556:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen
state_3557:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3558;
	case Keyword::IX: m_lexer.next(); goto state_3564;
	case Keyword::IY: m_lexer.next(); goto state_3568;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen HL
state_3558:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3559;
	case TType::Plus: m_lexer.next(); goto state_3561;
	case TType::RParen: m_lexer.next(); goto state_3563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen HL Minus
state_3559:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3560;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen HL Minus RParen
state_3560:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1191;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1191;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen HL Plus
state_3561:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen HL Plus RParen
state_3562:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1192;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1192;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen HL RParen
state_3563:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1193;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1193;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen IX
state_3564:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3565;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3566; }
	/*if (check_expr())*/ goto state_3566;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen IX RParen
state_3565:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1194;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen IX expr
state_3566:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen IX expr RParen
state_3567:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1195;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen IY
state_3568:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3569;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3570; }
	/*if (check_expr())*/ goto state_3570;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen IY RParen
state_3569:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1196;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen IY expr
state_3570:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3571;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR A Comma LParen IY expr RParen
state_3571:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1197;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen
state_3572:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3573;
	case Keyword::IX: m_lexer.next(); goto state_3579;
	case Keyword::IY: m_lexer.next(); goto state_3583;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen HL
state_3573:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3574;
	case TType::Plus: m_lexer.next(); goto state_3576;
	case TType::RParen: m_lexer.next(); goto state_3578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen HL Minus
state_3574:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3575;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen HL Minus RParen
state_3575:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1191;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1191;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen HL Plus
state_3576:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen HL Plus RParen
state_3577:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1192;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1192;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen HL RParen
state_3578:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1193;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1193;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen IX
state_3579:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3580;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3581; }
	/*if (check_expr())*/ goto state_3581;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen IX RParen
state_3580:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1194;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen IX expr
state_3581:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen IX expr RParen
state_3582:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1195;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen IY
state_3583:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3584;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3585; }
	/*if (check_expr())*/ goto state_3585;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen IY RParen
state_3584:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1196;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen IY expr
state_3585:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE ALTD XOR LParen IY expr RParen
state_3586:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1197;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND
state_3587:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3588;
	case Keyword::A1: m_lexer.next(); goto state_3605;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3622;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A
state_3588:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma
state_3589:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3590;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen
state_3590:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3591;
	case Keyword::IX: m_lexer.next(); goto state_3597;
	case Keyword::IY: m_lexer.next(); goto state_3601;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen HL
state_3591:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3592;
	case TType::Plus: m_lexer.next(); goto state_3594;
	case TType::RParen: m_lexer.next(); goto state_3596;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen HL Minus
state_3592:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3593;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen HL Minus RParen
state_3593:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1198;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1198;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen HL Plus
state_3594:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3595;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen HL Plus RParen
state_3595:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1199;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1199;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen HL RParen
state_3596:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1200;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen IX
state_3597:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3598;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3599; }
	/*if (check_expr())*/ goto state_3599;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen IX RParen
state_3598:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1201;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1201;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen IX expr
state_3599:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen IX expr RParen
state_3600:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1202;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1202;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen IY
state_3601:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3602;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3603; }
	/*if (check_expr())*/ goto state_3603;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen IY RParen
state_3602:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1203;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen IY expr
state_3603:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3604;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A Comma LParen IY expr RParen
state_3604:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1204;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1204;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1
state_3605:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3606;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma
state_3606:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3607;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen
state_3607:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3608;
	case Keyword::IX: m_lexer.next(); goto state_3614;
	case Keyword::IY: m_lexer.next(); goto state_3618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen HL
state_3608:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3609;
	case TType::Plus: m_lexer.next(); goto state_3611;
	case TType::RParen: m_lexer.next(); goto state_3613;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen HL Minus
state_3609:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3610;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen HL Minus RParen
state_3610:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1037;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1037;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen HL Plus
state_3611:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen HL Plus RParen
state_3612:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1038;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1038;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen HL RParen
state_3613:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1039;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen IX
state_3614:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3615;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3616; }
	/*if (check_expr())*/ goto state_3616;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen IX RParen
state_3615:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1040;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1040;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen IX expr
state_3616:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen IX expr RParen
state_3617:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1041;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1041;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen IY
state_3618:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3619;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3620; }
	/*if (check_expr())*/ goto state_3620;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen IY RParen
state_3619:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1042;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1042;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen IY expr
state_3620:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3621;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND A1 Comma LParen IY expr RParen
state_3621:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1043;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1043;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen
state_3622:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3623;
	case Keyword::IX: m_lexer.next(); goto state_3629;
	case Keyword::IY: m_lexer.next(); goto state_3633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen HL
state_3623:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3624;
	case TType::Plus: m_lexer.next(); goto state_3626;
	case TType::RParen: m_lexer.next(); goto state_3628;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen HL Minus
state_3624:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3625;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen HL Minus RParen
state_3625:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1198;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1198;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen HL Plus
state_3626:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3627;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen HL Plus RParen
state_3627:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1199;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1199;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen HL RParen
state_3628:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1200;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen IX
state_3629:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3630;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3631; }
	/*if (check_expr())*/ goto state_3631;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen IX RParen
state_3630:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1201;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1201;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen IX expr
state_3631:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen IX expr RParen
state_3632:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1202;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1202;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen IY
state_3633:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3634;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3635; }
	/*if (check_expr())*/ goto state_3635;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen IY RParen
state_3634:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1203;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen IY expr
state_3635:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE AND LParen IY expr RParen
state_3636:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1204;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1204;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT
state_3637:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3638; }
	/*if (check_const_expr())*/ goto state_3638;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr
state_3638:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma
state_3639:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen
state_3640:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3641;
	case Keyword::IX: m_lexer.next(); goto state_3643;
	case Keyword::IY: m_lexer.next(); goto state_3647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen HL
state_3641:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3642;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen HL RParen
state_3642:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1205;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen IX
state_3643:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3644;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3645; }
	/*if (check_expr())*/ goto state_3645;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen IX RParen
state_3644:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1206;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1206;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen IX expr
state_3645:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen IX expr RParen
state_3646:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1207;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1207;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen IY
state_3647:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3648;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3649; }
	/*if (check_expr())*/ goto state_3649;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen IY RParen
state_3648:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1208;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1208;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen IY expr
state_3649:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE BIT const_expr Comma LParen IY expr RParen
state_3650:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1209;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1209;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP
state_3651:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3652;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3669;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A
state_3652:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3653;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma
state_3653:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3654;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen
state_3654:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3655;
	case Keyword::IX: m_lexer.next(); goto state_3661;
	case Keyword::IY: m_lexer.next(); goto state_3665;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen HL
state_3655:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3656;
	case TType::Plus: m_lexer.next(); goto state_3658;
	case TType::RParen: m_lexer.next(); goto state_3660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen HL Minus
state_3656:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3657;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen HL Minus RParen
state_3657:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1210;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen HL Plus
state_3658:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen HL Plus RParen
state_3659:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1211;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen HL RParen
state_3660:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1212;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen IX
state_3661:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3662;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3663; }
	/*if (check_expr())*/ goto state_3663;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen IX RParen
state_3662:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1213;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen IX expr
state_3663:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen IX expr RParen
state_3664:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1214;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen IY
state_3665:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3666;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3667; }
	/*if (check_expr())*/ goto state_3667;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen IY RParen
state_3666:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1215;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen IY expr
state_3667:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3668;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP A Comma LParen IY expr RParen
state_3668:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1216;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1216;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen
state_3669:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3670;
	case Keyword::IX: m_lexer.next(); goto state_3676;
	case Keyword::IY: m_lexer.next(); goto state_3680;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen HL
state_3670:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3671;
	case TType::Plus: m_lexer.next(); goto state_3673;
	case TType::RParen: m_lexer.next(); goto state_3675;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen HL Minus
state_3671:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3672;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen HL Minus RParen
state_3672:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1210;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen HL Plus
state_3673:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3674;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen HL Plus RParen
state_3674:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1211;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen HL RParen
state_3675:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1212;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen IX
state_3676:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3677;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3678; }
	/*if (check_expr())*/ goto state_3678;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen IX RParen
state_3677:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1213;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen IX expr
state_3678:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen IX expr RParen
state_3679:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1214;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen IY
state_3680:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3681;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3682; }
	/*if (check_expr())*/ goto state_3682;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen IY RParen
state_3681:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1215;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen IY expr
state_3682:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3683;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CMP LParen IY expr RParen
state_3683:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1216;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1216;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP
state_3684:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3685;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A
state_3685:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3686;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma
state_3686:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3687;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen
state_3687:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3688;
	case Keyword::IX: m_lexer.next(); goto state_3694;
	case Keyword::IY: m_lexer.next(); goto state_3698;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen HL
state_3688:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3689;
	case TType::Plus: m_lexer.next(); goto state_3691;
	case TType::RParen: m_lexer.next(); goto state_3693;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen HL Minus
state_3689:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3690;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen HL Minus RParen
state_3690:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1210;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen HL Plus
state_3691:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3692;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen HL Plus RParen
state_3692:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1211;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen HL RParen
state_3693:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1212;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen IX
state_3694:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3695;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3696; }
	/*if (check_expr())*/ goto state_3696;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen IX RParen
state_3695:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1213;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen IX expr
state_3696:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3697;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen IX expr RParen
state_3697:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1214;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen IY
state_3698:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3699;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3700; }
	/*if (check_expr())*/ goto state_3700;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen IY RParen
state_3699:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1215;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen IY expr
state_3700:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP A Comma LParen IY expr RParen
state_3701:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1216;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1216;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen
state_3702:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3703;
	case Keyword::IX: m_lexer.next(); goto state_3709;
	case Keyword::IY: m_lexer.next(); goto state_3713;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen HL
state_3703:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3704;
	case TType::Plus: m_lexer.next(); goto state_3706;
	case TType::RParen: m_lexer.next(); goto state_3708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen HL Minus
state_3704:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3705;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen HL Minus RParen
state_3705:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1210;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen HL Plus
state_3706:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3707;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen HL Plus RParen
state_3707:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1211;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen HL RParen
state_3708:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1212;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen IX
state_3709:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3710;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3711; }
	/*if (check_expr())*/ goto state_3711;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen IX RParen
state_3710:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1213;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen IX expr
state_3711:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3712;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen IX expr RParen
state_3712:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1214;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen IY
state_3713:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3714;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3715; }
	/*if (check_expr())*/ goto state_3715;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen IY RParen
state_3714:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1215;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen IY expr
state_3715:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3716;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE CP LParen IY expr RParen
state_3716:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1216;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1216;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC
state_3717:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3718;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen
state_3718:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3719;
	case Keyword::IX: m_lexer.next(); goto state_3725;
	case Keyword::IY: m_lexer.next(); goto state_3729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen HL
state_3719:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3720;
	case TType::Plus: m_lexer.next(); goto state_3722;
	case TType::RParen: m_lexer.next(); goto state_3724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen HL Minus
state_3720:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3721;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen HL Minus RParen
state_3721:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1217;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1217;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen HL Plus
state_3722:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen HL Plus RParen
state_3723:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1218;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1218;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen HL RParen
state_3724:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1219;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1219;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen IX
state_3725:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3726;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3727; }
	/*if (check_expr())*/ goto state_3727;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen IX RParen
state_3726:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1220;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1220;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen IX expr
state_3727:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3728;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen IX expr RParen
state_3728:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1221;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1221;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen IY
state_3729:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3730;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3731; }
	/*if (check_expr())*/ goto state_3731;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen IY RParen
state_3730:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1222;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1222;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen IY expr
state_3731:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3732;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE DEC LParen IY expr RParen
state_3732:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1223;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1223;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC
state_3733:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3734;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen
state_3734:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3735;
	case Keyword::IX: m_lexer.next(); goto state_3741;
	case Keyword::IY: m_lexer.next(); goto state_3745;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen HL
state_3735:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3736;
	case TType::Plus: m_lexer.next(); goto state_3738;
	case TType::RParen: m_lexer.next(); goto state_3740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen HL Minus
state_3736:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3737;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen HL Minus RParen
state_3737:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1224;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1224;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen HL Plus
state_3738:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen HL Plus RParen
state_3739:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1225;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1225;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen HL RParen
state_3740:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1226;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1226;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen IX
state_3741:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3742;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3743; }
	/*if (check_expr())*/ goto state_3743;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen IX RParen
state_3742:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1227;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1227;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen IX expr
state_3743:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3744;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen IX expr RParen
state_3744:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1228;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1228;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen IY
state_3745:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3746;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3747; }
	/*if (check_expr())*/ goto state_3747;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen IY RParen
state_3746:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1229;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1229;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen IY expr
state_3747:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3748;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE INC LParen IY expr RParen
state_3748:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1230;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1230;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD
state_3749:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_3750;
	case Keyword::A1: m_lexer.next(); goto state_3784;
	case Keyword::B: m_lexer.next(); goto state_3818;
	case Keyword::B1: m_lexer.next(); goto state_3839;
	case Keyword::BC: m_lexer.next(); goto state_3860;
	case Keyword::BC1: m_lexer.next(); goto state_3863;
	case Keyword::C: m_lexer.next(); goto state_3866;
	case Keyword::C1: m_lexer.next(); goto state_3887;
	case Keyword::D: m_lexer.next(); goto state_3908;
	case Keyword::D1: m_lexer.next(); goto state_3929;
	case Keyword::DE: m_lexer.next(); goto state_3950;
	case Keyword::DE1: m_lexer.next(); goto state_3953;
	case Keyword::E: m_lexer.next(); goto state_3956;
	case Keyword::E1: m_lexer.next(); goto state_3977;
	case Keyword::H: m_lexer.next(); goto state_3998;
	case Keyword::H1: m_lexer.next(); goto state_4019;
	case Keyword::HL: m_lexer.next(); goto state_4040;
	case Keyword::HL1: m_lexer.next(); goto state_4056;
	case Keyword::IX: m_lexer.next(); goto state_4072;
	case Keyword::IY: m_lexer.next(); goto state_4075;
	case Keyword::L: m_lexer.next(); goto state_4078;
	case Keyword::L1: m_lexer.next(); goto state_4099;
	case Keyword::SP: m_lexer.next(); goto state_4120;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4123;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4254; }
	/*if (check_expr())*/ goto state_4254;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A
state_3750:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma
state_3751:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3752;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3783; }
	/*if (check_expr())*/ goto state_3783;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen
state_3752:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_3753;
	case Keyword::DE: m_lexer.next(); goto state_3759;
	case Keyword::HL: m_lexer.next(); goto state_3765;
	case Keyword::HLD: m_lexer.next(); goto state_3771;
	case Keyword::HLI: m_lexer.next(); goto state_3773;
	case Keyword::IX: m_lexer.next(); goto state_3775;
	case Keyword::IY: m_lexer.next(); goto state_3779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen BC
state_3753:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3754;
	case TType::Plus: m_lexer.next(); goto state_3756;
	case TType::RParen: m_lexer.next(); goto state_3758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen BC Minus
state_3754:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen BC Minus RParen
state_3755:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1231;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1231;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen BC Plus
state_3756:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen BC Plus RParen
state_3757:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1232;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1232;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen BC RParen
state_3758:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1233;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1233;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen DE
state_3759:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3760;
	case TType::Plus: m_lexer.next(); goto state_3762;
	case TType::RParen: m_lexer.next(); goto state_3764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen DE Minus
state_3760:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen DE Minus RParen
state_3761:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1234;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1234;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen DE Plus
state_3762:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen DE Plus RParen
state_3763:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1235;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1235;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen DE RParen
state_3764:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1236;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1236;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HL
state_3765:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3766;
	case TType::Plus: m_lexer.next(); goto state_3768;
	case TType::RParen: m_lexer.next(); goto state_3770;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HL Minus
state_3766:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HL Minus RParen
state_3767:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1237;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1237;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HL Plus
state_3768:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3769;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HL Plus RParen
state_3769:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1238;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1238;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HL RParen
state_3770:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1239;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1239;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HLD
state_3771:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3772;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HLD RParen
state_3772:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1237;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1237;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HLI
state_3773:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen HLI RParen
state_3774:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1238;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1238;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen IX
state_3775:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3776;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3777; }
	/*if (check_expr())*/ goto state_3777;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen IX RParen
state_3776:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1240;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1240;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen IX expr
state_3777:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3778;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen IX expr RParen
state_3778:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1241;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1241;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen IY
state_3779:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3780;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3781; }
	/*if (check_expr())*/ goto state_3781;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen IY RParen
state_3780:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1242;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1242;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen IY expr
state_3781:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma LParen IY expr RParen
state_3782:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1243;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1243;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A Comma expr
state_3783:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1244;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1244;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1
state_3784:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma
state_3785:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3786;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3817; }
	/*if (check_expr())*/ goto state_3817;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen
state_3786:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_3787;
	case Keyword::DE: m_lexer.next(); goto state_3793;
	case Keyword::HL: m_lexer.next(); goto state_3799;
	case Keyword::HLD: m_lexer.next(); goto state_3805;
	case Keyword::HLI: m_lexer.next(); goto state_3807;
	case Keyword::IX: m_lexer.next(); goto state_3809;
	case Keyword::IY: m_lexer.next(); goto state_3813;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen BC
state_3787:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3788;
	case TType::Plus: m_lexer.next(); goto state_3790;
	case TType::RParen: m_lexer.next(); goto state_3792;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen BC Minus
state_3788:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen BC Minus RParen
state_3789:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1070;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1070;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen BC Plus
state_3790:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen BC Plus RParen
state_3791:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1071;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1071;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen BC RParen
state_3792:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1072;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1072;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen DE
state_3793:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3794;
	case TType::Plus: m_lexer.next(); goto state_3796;
	case TType::RParen: m_lexer.next(); goto state_3798;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen DE Minus
state_3794:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3795;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen DE Minus RParen
state_3795:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1073;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1073;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen DE Plus
state_3796:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3797;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen DE Plus RParen
state_3797:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1074;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1074;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen DE RParen
state_3798:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1075;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HL
state_3799:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3800;
	case TType::Plus: m_lexer.next(); goto state_3802;
	case TType::RParen: m_lexer.next(); goto state_3804;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HL Minus
state_3800:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3801;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HL Minus RParen
state_3801:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1076;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1076;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HL Plus
state_3802:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HL Plus RParen
state_3803:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1077;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1077;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HL RParen
state_3804:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1078;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1078;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HLD
state_3805:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3806;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HLD RParen
state_3806:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1076;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1076;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HLI
state_3807:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3808;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen HLI RParen
state_3808:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1077;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1077;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen IX
state_3809:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3810;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3811; }
	/*if (check_expr())*/ goto state_3811;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen IX RParen
state_3810:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1079;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1079;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen IX expr
state_3811:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3812;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen IX expr RParen
state_3812:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1080;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1080;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen IY
state_3813:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3814;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3815; }
	/*if (check_expr())*/ goto state_3815;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen IY RParen
state_3814:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1081;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1081;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen IY expr
state_3815:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3816;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma LParen IY expr RParen
state_3816:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1082;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1082;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD A1 Comma expr
state_3817:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1083;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1083;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B
state_3818:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3819;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma
state_3819:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3820;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen
state_3820:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3821;
	case Keyword::HLD: m_lexer.next(); goto state_3827;
	case Keyword::HLI: m_lexer.next(); goto state_3829;
	case Keyword::IX: m_lexer.next(); goto state_3831;
	case Keyword::IY: m_lexer.next(); goto state_3835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HL
state_3821:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3822;
	case TType::Plus: m_lexer.next(); goto state_3824;
	case TType::RParen: m_lexer.next(); goto state_3826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HL Minus
state_3822:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HL Minus RParen
state_3823:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1245;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1245;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HL Plus
state_3824:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3825;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HL Plus RParen
state_3825:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1246;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HL RParen
state_3826:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1247;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1247;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HLD
state_3827:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3828;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HLD RParen
state_3828:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1245;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1245;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HLI
state_3829:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3830;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen HLI RParen
state_3830:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1246;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen IX
state_3831:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3832;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3833; }
	/*if (check_expr())*/ goto state_3833;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen IX RParen
state_3832:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1248;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1248;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen IX expr
state_3833:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3834;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen IX expr RParen
state_3834:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1249;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1249;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen IY
state_3835:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3836;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3837; }
	/*if (check_expr())*/ goto state_3837;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen IY RParen
state_3836:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1250;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1250;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen IY expr
state_3837:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B Comma LParen IY expr RParen
state_3838:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1251;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1251;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1
state_3839:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3840;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma
state_3840:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen
state_3841:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3842;
	case Keyword::HLD: m_lexer.next(); goto state_3848;
	case Keyword::HLI: m_lexer.next(); goto state_3850;
	case Keyword::IX: m_lexer.next(); goto state_3852;
	case Keyword::IY: m_lexer.next(); goto state_3856;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HL
state_3842:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3843;
	case TType::Plus: m_lexer.next(); goto state_3845;
	case TType::RParen: m_lexer.next(); goto state_3847;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HL Minus
state_3843:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3844;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HL Minus RParen
state_3844:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1084;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1084;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HL Plus
state_3845:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3846;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HL Plus RParen
state_3846:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1085;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HL RParen
state_3847:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1086;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1086;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HLD
state_3848:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3849;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HLD RParen
state_3849:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1084;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1084;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HLI
state_3850:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3851;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen HLI RParen
state_3851:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1085;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen IX
state_3852:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3853;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3854; }
	/*if (check_expr())*/ goto state_3854;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen IX RParen
state_3853:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1087;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1087;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen IX expr
state_3854:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3855;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen IX expr RParen
state_3855:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1088;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1088;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen IY
state_3856:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3857;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3858; }
	/*if (check_expr())*/ goto state_3858;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen IY RParen
state_3857:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1089;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1089;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen IY expr
state_3858:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3859;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD B1 Comma LParen IY expr RParen
state_3859:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1090;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1090;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD BC
state_3860:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3861;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD BC Comma
state_3861:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3862; }
	/*if (check_expr())*/ goto state_3862;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD BC Comma expr
state_3862:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1252;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1252;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD BC1
state_3863:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3864;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD BC1 Comma
state_3864:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3865; }
	/*if (check_expr())*/ goto state_3865;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD BC1 Comma expr
state_3865:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1091;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1091;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C
state_3866:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3867;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma
state_3867:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3868;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen
state_3868:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3869;
	case Keyword::HLD: m_lexer.next(); goto state_3875;
	case Keyword::HLI: m_lexer.next(); goto state_3877;
	case Keyword::IX: m_lexer.next(); goto state_3879;
	case Keyword::IY: m_lexer.next(); goto state_3883;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HL
state_3869:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3870;
	case TType::Plus: m_lexer.next(); goto state_3872;
	case TType::RParen: m_lexer.next(); goto state_3874;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HL Minus
state_3870:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3871;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HL Minus RParen
state_3871:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1253;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1253;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HL Plus
state_3872:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3873;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HL Plus RParen
state_3873:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1254;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1254;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HL RParen
state_3874:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1255;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1255;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HLD
state_3875:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3876;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HLD RParen
state_3876:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1253;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1253;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HLI
state_3877:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3878;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen HLI RParen
state_3878:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1254;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1254;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen IX
state_3879:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3880;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3881; }
	/*if (check_expr())*/ goto state_3881;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen IX RParen
state_3880:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1256;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1256;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen IX expr
state_3881:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3882;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen IX expr RParen
state_3882:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1257;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1257;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen IY
state_3883:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3884;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3885; }
	/*if (check_expr())*/ goto state_3885;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen IY RParen
state_3884:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1258;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1258;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen IY expr
state_3885:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3886;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C Comma LParen IY expr RParen
state_3886:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1259;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1259;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1
state_3887:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma
state_3888:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3889;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen
state_3889:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3890;
	case Keyword::HLD: m_lexer.next(); goto state_3896;
	case Keyword::HLI: m_lexer.next(); goto state_3898;
	case Keyword::IX: m_lexer.next(); goto state_3900;
	case Keyword::IY: m_lexer.next(); goto state_3904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HL
state_3890:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3891;
	case TType::Plus: m_lexer.next(); goto state_3893;
	case TType::RParen: m_lexer.next(); goto state_3895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HL Minus
state_3891:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HL Minus RParen
state_3892:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1092;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1092;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HL Plus
state_3893:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3894;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HL Plus RParen
state_3894:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1093;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1093;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HL RParen
state_3895:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1094;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1094;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HLD
state_3896:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3897;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HLD RParen
state_3897:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1092;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1092;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HLI
state_3898:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen HLI RParen
state_3899:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1093;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1093;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen IX
state_3900:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3901;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3902; }
	/*if (check_expr())*/ goto state_3902;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen IX RParen
state_3901:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1095;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1095;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen IX expr
state_3902:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen IX expr RParen
state_3903:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1096;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1096;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen IY
state_3904:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3905;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3906; }
	/*if (check_expr())*/ goto state_3906;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen IY RParen
state_3905:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1097;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1097;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen IY expr
state_3906:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD C1 Comma LParen IY expr RParen
state_3907:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1098;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1098;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D
state_3908:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma
state_3909:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen
state_3910:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3911;
	case Keyword::HLD: m_lexer.next(); goto state_3917;
	case Keyword::HLI: m_lexer.next(); goto state_3919;
	case Keyword::IX: m_lexer.next(); goto state_3921;
	case Keyword::IY: m_lexer.next(); goto state_3925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HL
state_3911:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3912;
	case TType::Plus: m_lexer.next(); goto state_3914;
	case TType::RParen: m_lexer.next(); goto state_3916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HL Minus
state_3912:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HL Minus RParen
state_3913:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1260;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1260;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HL Plus
state_3914:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HL Plus RParen
state_3915:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1261;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HL RParen
state_3916:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1262;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1262;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HLD
state_3917:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HLD RParen
state_3918:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1260;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1260;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HLI
state_3919:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3920;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen HLI RParen
state_3920:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1261;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen IX
state_3921:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3922;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3923; }
	/*if (check_expr())*/ goto state_3923;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen IX RParen
state_3922:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1263;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1263;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen IX expr
state_3923:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen IX expr RParen
state_3924:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1264;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1264;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen IY
state_3925:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3926;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3927; }
	/*if (check_expr())*/ goto state_3927;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen IY RParen
state_3926:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1265;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1265;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen IY expr
state_3927:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3928;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D Comma LParen IY expr RParen
state_3928:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1266;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1266;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1
state_3929:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma
state_3930:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen
state_3931:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3932;
	case Keyword::HLD: m_lexer.next(); goto state_3938;
	case Keyword::HLI: m_lexer.next(); goto state_3940;
	case Keyword::IX: m_lexer.next(); goto state_3942;
	case Keyword::IY: m_lexer.next(); goto state_3946;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HL
state_3932:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3933;
	case TType::Plus: m_lexer.next(); goto state_3935;
	case TType::RParen: m_lexer.next(); goto state_3937;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HL Minus
state_3933:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HL Minus RParen
state_3934:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1099;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1099;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HL Plus
state_3935:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3936;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HL Plus RParen
state_3936:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1100;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HL RParen
state_3937:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1101;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1101;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HLD
state_3938:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3939;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HLD RParen
state_3939:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1099;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1099;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HLI
state_3940:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3941;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen HLI RParen
state_3941:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1100;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen IX
state_3942:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3943;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3944; }
	/*if (check_expr())*/ goto state_3944;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen IX RParen
state_3943:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1102;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1102;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen IX expr
state_3944:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3945;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen IX expr RParen
state_3945:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1103;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1103;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen IY
state_3946:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3947;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3948; }
	/*if (check_expr())*/ goto state_3948;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen IY RParen
state_3947:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1104;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen IY expr
state_3948:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3949;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD D1 Comma LParen IY expr RParen
state_3949:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1105;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1105;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD DE
state_3950:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3951;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD DE Comma
state_3951:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3952; }
	/*if (check_expr())*/ goto state_3952;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD DE Comma expr
state_3952:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1267;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1267;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD DE1
state_3953:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3954;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD DE1 Comma
state_3954:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3955; }
	/*if (check_expr())*/ goto state_3955;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD DE1 Comma expr
state_3955:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1106;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1106;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E
state_3956:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3957;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma
state_3957:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3958;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen
state_3958:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3959;
	case Keyword::HLD: m_lexer.next(); goto state_3965;
	case Keyword::HLI: m_lexer.next(); goto state_3967;
	case Keyword::IX: m_lexer.next(); goto state_3969;
	case Keyword::IY: m_lexer.next(); goto state_3973;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HL
state_3959:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3960;
	case TType::Plus: m_lexer.next(); goto state_3962;
	case TType::RParen: m_lexer.next(); goto state_3964;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HL Minus
state_3960:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3961;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HL Minus RParen
state_3961:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1268;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1268;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HL Plus
state_3962:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3963;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HL Plus RParen
state_3963:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1269;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HL RParen
state_3964:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1270;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HLD
state_3965:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3966;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HLD RParen
state_3966:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1268;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1268;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HLI
state_3967:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3968;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen HLI RParen
state_3968:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1269;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen IX
state_3969:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3970;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3971; }
	/*if (check_expr())*/ goto state_3971;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen IX RParen
state_3970:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1271;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1271;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen IX expr
state_3971:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3972;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen IX expr RParen
state_3972:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1272;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1272;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen IY
state_3973:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3974;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3975; }
	/*if (check_expr())*/ goto state_3975;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen IY RParen
state_3974:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1273;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1273;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen IY expr
state_3975:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3976;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E Comma LParen IY expr RParen
state_3976:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1274;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1274;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1
state_3977:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma
state_3978:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_3979;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen
state_3979:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_3980;
	case Keyword::HLD: m_lexer.next(); goto state_3986;
	case Keyword::HLI: m_lexer.next(); goto state_3988;
	case Keyword::IX: m_lexer.next(); goto state_3990;
	case Keyword::IY: m_lexer.next(); goto state_3994;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HL
state_3980:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_3981;
	case TType::Plus: m_lexer.next(); goto state_3983;
	case TType::RParen: m_lexer.next(); goto state_3985;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HL Minus
state_3981:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3982;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HL Minus RParen
state_3982:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1107;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HL Plus
state_3983:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3984;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HL Plus RParen
state_3984:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1108;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HL RParen
state_3985:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1109;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HLD
state_3986:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3987;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HLD RParen
state_3987:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1107;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HLI
state_3988:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen HLI RParen
state_3989:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1108;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen IX
state_3990:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3991;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3992; }
	/*if (check_expr())*/ goto state_3992;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen IX RParen
state_3991:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1110;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1110;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen IX expr
state_3992:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3993;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen IX expr RParen
state_3993:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1111;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen IY
state_3994:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3995;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_3996; }
	/*if (check_expr())*/ goto state_3996;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen IY RParen
state_3995:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1112;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1112;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen IY expr
state_3996:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_3997;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD E1 Comma LParen IY expr RParen
state_3997:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1113;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1113;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H
state_3998:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_3999;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma
state_3999:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4000;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen
state_4000:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4001;
	case Keyword::HLD: m_lexer.next(); goto state_4007;
	case Keyword::HLI: m_lexer.next(); goto state_4009;
	case Keyword::IX: m_lexer.next(); goto state_4011;
	case Keyword::IY: m_lexer.next(); goto state_4015;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HL
state_4001:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4002;
	case TType::Plus: m_lexer.next(); goto state_4004;
	case TType::RParen: m_lexer.next(); goto state_4006;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HL Minus
state_4002:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4003;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HL Minus RParen
state_4003:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1275;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HL Plus
state_4004:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4005;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HL Plus RParen
state_4005:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1276;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1276;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HL RParen
state_4006:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1277;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1277;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HLD
state_4007:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4008;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HLD RParen
state_4008:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1275;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HLI
state_4009:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4010;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen HLI RParen
state_4010:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1276;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1276;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen IX
state_4011:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4012;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4013; }
	/*if (check_expr())*/ goto state_4013;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen IX RParen
state_4012:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1278;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1278;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen IX expr
state_4013:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4014;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen IX expr RParen
state_4014:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1279;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1279;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen IY
state_4015:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4016;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4017; }
	/*if (check_expr())*/ goto state_4017;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen IY RParen
state_4016:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1280;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1280;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen IY expr
state_4017:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4018;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H Comma LParen IY expr RParen
state_4018:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1281;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1
state_4019:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4020;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma
state_4020:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4021;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen
state_4021:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4022;
	case Keyword::HLD: m_lexer.next(); goto state_4028;
	case Keyword::HLI: m_lexer.next(); goto state_4030;
	case Keyword::IX: m_lexer.next(); goto state_4032;
	case Keyword::IY: m_lexer.next(); goto state_4036;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HL
state_4022:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4023;
	case TType::Plus: m_lexer.next(); goto state_4025;
	case TType::RParen: m_lexer.next(); goto state_4027;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HL Minus
state_4023:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4024;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HL Minus RParen
state_4024:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1114;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HL Plus
state_4025:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4026;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HL Plus RParen
state_4026:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1115;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HL RParen
state_4027:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1116;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1116;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HLD
state_4028:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4029;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HLD RParen
state_4029:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1114;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HLI
state_4030:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4031;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen HLI RParen
state_4031:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1115;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen IX
state_4032:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4033;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4034; }
	/*if (check_expr())*/ goto state_4034;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen IX RParen
state_4033:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1117;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1117;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen IX expr
state_4034:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4035;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen IX expr RParen
state_4035:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1118;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1118;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen IY
state_4036:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4037;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4038; }
	/*if (check_expr())*/ goto state_4038;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen IY RParen
state_4037:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1119;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1119;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen IY expr
state_4038:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD H1 Comma LParen IY expr RParen
state_4039:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1120;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1120;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL
state_4040:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4041;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma
state_4041:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4042;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4055; }
	/*if (check_expr())*/ goto state_4055;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen
state_4042:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4043;
	case Keyword::IX: m_lexer.next(); goto state_4047;
	case Keyword::IY: m_lexer.next(); goto state_4051;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen HL
state_4043:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4044;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4045; }
	/*if (check_expr())*/ goto state_4045;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen HL RParen
state_4044:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1282;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1282;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen HL expr
state_4045:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4046;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen HL expr RParen
state_4046:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1283;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1283;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen IX
state_4047:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4048;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4049; }
	/*if (check_expr())*/ goto state_4049;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen IX RParen
state_4048:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1284;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1284;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen IX expr
state_4049:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4050;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen IX expr RParen
state_4050:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1285;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1285;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen IY
state_4051:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4052;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4053; }
	/*if (check_expr())*/ goto state_4053;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen IY RParen
state_4052:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1286;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1286;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen IY expr
state_4053:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4054;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma LParen IY expr RParen
state_4054:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1287;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1287;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL Comma expr
state_4055:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1288;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1288;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1
state_4056:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4057;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma
state_4057:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4058;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4071; }
	/*if (check_expr())*/ goto state_4071;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen
state_4058:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4059;
	case Keyword::IX: m_lexer.next(); goto state_4063;
	case Keyword::IY: m_lexer.next(); goto state_4067;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen HL
state_4059:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4060;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4061; }
	/*if (check_expr())*/ goto state_4061;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen HL RParen
state_4060:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1121;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1121;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen HL expr
state_4061:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4062;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen HL expr RParen
state_4062:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1122;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1122;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen IX
state_4063:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4064;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4065; }
	/*if (check_expr())*/ goto state_4065;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen IX RParen
state_4064:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1123;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1123;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen IX expr
state_4065:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4066;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen IX expr RParen
state_4066:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1124;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1124;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen IY
state_4067:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4068;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4069; }
	/*if (check_expr())*/ goto state_4069;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen IY RParen
state_4068:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1125;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1125;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen IY expr
state_4069:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4070;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma LParen IY expr RParen
state_4070:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1126;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1126;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD HL1 Comma expr
state_4071:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1127;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1127;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD IX
state_4072:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4073;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD IX Comma
state_4073:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4074; }
	/*if (check_expr())*/ goto state_4074;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD IX Comma expr
state_4074:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1289;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1289;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD IY
state_4075:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4076;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD IY Comma
state_4076:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4077; }
	/*if (check_expr())*/ goto state_4077;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD IY Comma expr
state_4077:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1290;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1290;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L
state_4078:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4079;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma
state_4079:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4080;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen
state_4080:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4081;
	case Keyword::HLD: m_lexer.next(); goto state_4087;
	case Keyword::HLI: m_lexer.next(); goto state_4089;
	case Keyword::IX: m_lexer.next(); goto state_4091;
	case Keyword::IY: m_lexer.next(); goto state_4095;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HL
state_4081:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4082;
	case TType::Plus: m_lexer.next(); goto state_4084;
	case TType::RParen: m_lexer.next(); goto state_4086;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HL Minus
state_4082:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4083;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HL Minus RParen
state_4083:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1291;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1291;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HL Plus
state_4084:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HL Plus RParen
state_4085:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1292;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1292;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HL RParen
state_4086:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1293;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1293;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HLD
state_4087:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4088;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HLD RParen
state_4088:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1291;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1291;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HLI
state_4089:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4090;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen HLI RParen
state_4090:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1292;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1292;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen IX
state_4091:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4092;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4093; }
	/*if (check_expr())*/ goto state_4093;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen IX RParen
state_4092:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1294;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1294;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen IX expr
state_4093:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4094;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen IX expr RParen
state_4094:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1295;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1295;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen IY
state_4095:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4096;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4097; }
	/*if (check_expr())*/ goto state_4097;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen IY RParen
state_4096:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1296;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1296;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen IY expr
state_4097:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4098;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L Comma LParen IY expr RParen
state_4098:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1297;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1297;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1
state_4099:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma
state_4100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4101;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen
state_4101:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4102;
	case Keyword::HLD: m_lexer.next(); goto state_4108;
	case Keyword::HLI: m_lexer.next(); goto state_4110;
	case Keyword::IX: m_lexer.next(); goto state_4112;
	case Keyword::IY: m_lexer.next(); goto state_4116;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HL
state_4102:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4103;
	case TType::Plus: m_lexer.next(); goto state_4105;
	case TType::RParen: m_lexer.next(); goto state_4107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HL Minus
state_4103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HL Minus RParen
state_4104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1128;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HL Plus
state_4105:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4106;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HL Plus RParen
state_4106:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1129;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HL RParen
state_4107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1130;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1130;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HLD
state_4108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HLD RParen
state_4109:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1128;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HLI
state_4110:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen HLI RParen
state_4111:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1129;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen IX
state_4112:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4113;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4114; }
	/*if (check_expr())*/ goto state_4114;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen IX RParen
state_4113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1131;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen IX expr
state_4114:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen IX expr RParen
state_4115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1132;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1132;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen IY
state_4116:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4117;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4118; }
	/*if (check_expr())*/ goto state_4118;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen IY RParen
state_4117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1133;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1133;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen IY expr
state_4118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4119;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD L1 Comma LParen IY expr RParen
state_4119:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1134;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1134;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD SP
state_4120:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4121;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD SP Comma
state_4121:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4122; }
	/*if (check_expr())*/ goto state_4122;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD SP Comma expr
state_4122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1298;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1298;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen
state_4123:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_4124;
	case Keyword::DE: m_lexer.next(); goto state_4136;
	case Keyword::HL: m_lexer.next(); goto state_4148;
	case Keyword::HLD: m_lexer.next(); goto state_4186;
	case Keyword::HLI: m_lexer.next(); goto state_4196;
	case Keyword::IX: m_lexer.next(); goto state_4206;
	case Keyword::IY: m_lexer.next(); goto state_4230;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC
state_4124:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4125;
	case TType::Plus: m_lexer.next(); goto state_4129;
	case TType::RParen: m_lexer.next(); goto state_4133;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC Minus
state_4125:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4126;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC Minus RParen
state_4126:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4127;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC Minus RParen Comma
state_4127:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC Minus RParen Comma A
state_4128:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1299;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC Plus
state_4129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4130;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC Plus RParen
state_4130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC Plus RParen Comma
state_4131:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4132;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC Plus RParen Comma A
state_4132:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1300;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC RParen
state_4133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4134;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC RParen Comma
state_4134:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen BC RParen Comma A
state_4135:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1301;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1301;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE
state_4136:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4137;
	case TType::Plus: m_lexer.next(); goto state_4141;
	case TType::RParen: m_lexer.next(); goto state_4145;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE Minus
state_4137:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE Minus RParen
state_4138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE Minus RParen Comma
state_4139:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE Minus RParen Comma A
state_4140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1302;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1302;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE Plus
state_4141:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4142;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE Plus RParen
state_4142:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4143;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE Plus RParen Comma
state_4143:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4144;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE Plus RParen Comma A
state_4144:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1303;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE RParen
state_4145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE RParen Comma
state_4146:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen DE RParen Comma A
state_4147:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1304;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1304;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL
state_4148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4149;
	case TType::Plus: m_lexer.next(); goto state_4160;
	case TType::RParen: m_lexer.next(); goto state_4171;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4182; }
	/*if (check_expr())*/ goto state_4182;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus
state_4149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4150;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen
state_4150:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen Comma
state_4151:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4152;
	case Keyword::B: m_lexer.next(); goto state_4153;
	case Keyword::C: m_lexer.next(); goto state_4154;
	case Keyword::D: m_lexer.next(); goto state_4155;
	case Keyword::E: m_lexer.next(); goto state_4156;
	case Keyword::H: m_lexer.next(); goto state_4157;
	case Keyword::L: m_lexer.next(); goto state_4158;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4159; }
	/*if (check_expr())*/ goto state_4159;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen Comma A
state_4152:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1305;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1305;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen Comma B
state_4153:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1306;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1306;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen Comma C
state_4154:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1307;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen Comma D
state_4155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1308;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1308;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen Comma E
state_4156:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1309;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1309;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen Comma H
state_4157:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1310;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1310;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen Comma L
state_4158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1311;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Minus RParen Comma expr
state_4159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1312;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1312;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus
state_4160:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4161;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen
state_4161:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen Comma
state_4162:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4163;
	case Keyword::B: m_lexer.next(); goto state_4164;
	case Keyword::C: m_lexer.next(); goto state_4165;
	case Keyword::D: m_lexer.next(); goto state_4166;
	case Keyword::E: m_lexer.next(); goto state_4167;
	case Keyword::H: m_lexer.next(); goto state_4168;
	case Keyword::L: m_lexer.next(); goto state_4169;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4170; }
	/*if (check_expr())*/ goto state_4170;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen Comma A
state_4163:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1313;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1313;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen Comma B
state_4164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1314;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1314;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen Comma C
state_4165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1315;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen Comma D
state_4166:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1316;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1316;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen Comma E
state_4167:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1317;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1317;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen Comma H
state_4168:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1318;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1318;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen Comma L
state_4169:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1319;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1319;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL Plus RParen Comma expr
state_4170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1320;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1320;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen
state_4171:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4172;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma
state_4172:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4173;
	case Keyword::B: m_lexer.next(); goto state_4174;
	case Keyword::C: m_lexer.next(); goto state_4175;
	case Keyword::D: m_lexer.next(); goto state_4176;
	case Keyword::E: m_lexer.next(); goto state_4177;
	case Keyword::H: m_lexer.next(); goto state_4178;
	case Keyword::HL: m_lexer.next(); goto state_4179;
	case Keyword::L: m_lexer.next(); goto state_4180;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4181; }
	/*if (check_expr())*/ goto state_4181;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma A
state_4173:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1321;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1321;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma B
state_4174:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1322;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1322;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma C
state_4175:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1323;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1323;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma D
state_4176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1324;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1324;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma E
state_4177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1325;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1325;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma H
state_4178:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1326;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1326;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma HL
state_4179:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1327;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1327;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma L
state_4180:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1328;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1328;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL RParen Comma expr
state_4181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1329;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1329;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL expr
state_4182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4183;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL expr RParen
state_4183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL expr RParen Comma
state_4184:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HL expr RParen Comma HL
state_4185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1330;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1330;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD
state_4186:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD RParen
state_4187:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD RParen Comma
state_4188:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4189;
	case Keyword::B: m_lexer.next(); goto state_4190;
	case Keyword::C: m_lexer.next(); goto state_4191;
	case Keyword::D: m_lexer.next(); goto state_4192;
	case Keyword::E: m_lexer.next(); goto state_4193;
	case Keyword::H: m_lexer.next(); goto state_4194;
	case Keyword::L: m_lexer.next(); goto state_4195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD RParen Comma A
state_4189:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1305;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1305;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD RParen Comma B
state_4190:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1306;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1306;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD RParen Comma C
state_4191:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1307;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD RParen Comma D
state_4192:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1308;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1308;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD RParen Comma E
state_4193:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1309;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1309;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD RParen Comma H
state_4194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1310;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1310;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLD RParen Comma L
state_4195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1311;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI
state_4196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI RParen
state_4197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4198;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI RParen Comma
state_4198:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4199;
	case Keyword::B: m_lexer.next(); goto state_4200;
	case Keyword::C: m_lexer.next(); goto state_4201;
	case Keyword::D: m_lexer.next(); goto state_4202;
	case Keyword::E: m_lexer.next(); goto state_4203;
	case Keyword::H: m_lexer.next(); goto state_4204;
	case Keyword::L: m_lexer.next(); goto state_4205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI RParen Comma A
state_4199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1313;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1313;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI RParen Comma B
state_4200:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1314;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1314;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI RParen Comma C
state_4201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1315;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI RParen Comma D
state_4202:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1316;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1316;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI RParen Comma E
state_4203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1317;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1317;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI RParen Comma H
state_4204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1318;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1318;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen HLI RParen Comma L
state_4205:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1319;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1319;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX
state_4206:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4207;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4218; }
	/*if (check_expr())*/ goto state_4218;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen
state_4207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4208;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma
state_4208:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4209;
	case Keyword::B: m_lexer.next(); goto state_4210;
	case Keyword::C: m_lexer.next(); goto state_4211;
	case Keyword::D: m_lexer.next(); goto state_4212;
	case Keyword::E: m_lexer.next(); goto state_4213;
	case Keyword::H: m_lexer.next(); goto state_4214;
	case Keyword::HL: m_lexer.next(); goto state_4215;
	case Keyword::L: m_lexer.next(); goto state_4216;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4217; }
	/*if (check_expr())*/ goto state_4217;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma A
state_4209:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1331;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1331;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma B
state_4210:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1332;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1332;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma C
state_4211:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1333;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1333;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma D
state_4212:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1334;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1334;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma E
state_4213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1335;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1335;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma H
state_4214:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1336;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1336;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma HL
state_4215:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1337;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1337;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma L
state_4216:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1338;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1338;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX RParen Comma expr
state_4217:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1339;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1339;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr
state_4218:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4219;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen
state_4219:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4220;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma
state_4220:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4221;
	case Keyword::B: m_lexer.next(); goto state_4222;
	case Keyword::C: m_lexer.next(); goto state_4223;
	case Keyword::D: m_lexer.next(); goto state_4224;
	case Keyword::E: m_lexer.next(); goto state_4225;
	case Keyword::H: m_lexer.next(); goto state_4226;
	case Keyword::HL: m_lexer.next(); goto state_4227;
	case Keyword::L: m_lexer.next(); goto state_4228;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4229; }
	/*if (check_expr())*/ goto state_4229;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma A
state_4221:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1340;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1340;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma B
state_4222:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1341;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1341;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma C
state_4223:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1342;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1342;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma D
state_4224:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1343;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1343;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma E
state_4225:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1344;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1344;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma H
state_4226:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1345;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1345;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma HL
state_4227:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1346;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1346;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma L
state_4228:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1347;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1347;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IX expr RParen Comma expr
state_4229:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1348;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY
state_4230:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4231;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4242; }
	/*if (check_expr())*/ goto state_4242;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen
state_4231:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4232;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma
state_4232:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4233;
	case Keyword::B: m_lexer.next(); goto state_4234;
	case Keyword::C: m_lexer.next(); goto state_4235;
	case Keyword::D: m_lexer.next(); goto state_4236;
	case Keyword::E: m_lexer.next(); goto state_4237;
	case Keyword::H: m_lexer.next(); goto state_4238;
	case Keyword::HL: m_lexer.next(); goto state_4239;
	case Keyword::L: m_lexer.next(); goto state_4240;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4241; }
	/*if (check_expr())*/ goto state_4241;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma A
state_4233:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1349;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma B
state_4234:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1350;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1350;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma C
state_4235:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1351;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma D
state_4236:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1352;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1352;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma E
state_4237:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1353;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1353;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma H
state_4238:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1354;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1354;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma HL
state_4239:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1355;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1355;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma L
state_4240:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1356;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1356;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY RParen Comma expr
state_4241:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1357;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr
state_4242:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4243;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen
state_4243:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4244;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma
state_4244:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4245;
	case Keyword::B: m_lexer.next(); goto state_4246;
	case Keyword::C: m_lexer.next(); goto state_4247;
	case Keyword::D: m_lexer.next(); goto state_4248;
	case Keyword::E: m_lexer.next(); goto state_4249;
	case Keyword::H: m_lexer.next(); goto state_4250;
	case Keyword::HL: m_lexer.next(); goto state_4251;
	case Keyword::L: m_lexer.next(); goto state_4252;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4253; }
	/*if (check_expr())*/ goto state_4253;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma A
state_4245:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1358;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma B
state_4246:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1359;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma C
state_4247:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1360;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1360;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma D
state_4248:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1361;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1361;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma E
state_4249:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1362;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1362;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma H
state_4250:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1363;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma HL
state_4251:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1364;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1364;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma L
state_4252:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1365;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1365;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD LParen IY expr RParen Comma expr
state_4253:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1366;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1366;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD expr
state_4254:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4255;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD expr Comma
state_4255:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4256;
	case Keyword::BC: m_lexer.next(); goto state_4257;
	case Keyword::DE: m_lexer.next(); goto state_4258;
	case Keyword::HL: m_lexer.next(); goto state_4259;
	case Keyword::IX: m_lexer.next(); goto state_4260;
	case Keyword::IY: m_lexer.next(); goto state_4261;
	case Keyword::SP: m_lexer.next(); goto state_4262;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD expr Comma A
state_4256:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1367;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1367;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD expr Comma BC
state_4257:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1368;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1368;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD expr Comma DE
state_4258:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1369;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1369;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD expr Comma HL
state_4259:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1370;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1370;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD expr Comma IX
state_4260:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1371;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1371;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD expr Comma IY
state_4261:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1372;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1372;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LD expr Comma SP
state_4262:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1373;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1373;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD
state_4263:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4264;
	case Keyword::B: m_lexer.next(); goto state_4273;
	case Keyword::C: m_lexer.next(); goto state_4278;
	case Keyword::D: m_lexer.next(); goto state_4283;
	case Keyword::E: m_lexer.next(); goto state_4288;
	case Keyword::H: m_lexer.next(); goto state_4293;
	case Keyword::L: m_lexer.next(); goto state_4298;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1374;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1374;
	case TType::LParen: m_lexer.next(); goto state_4303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD A
state_4264:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4265;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD A Comma
state_4265:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4266;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD A Comma LParen
state_4266:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_4267;
	case Keyword::DE: m_lexer.next(); goto state_4269;
	case Keyword::HL: m_lexer.next(); goto state_4271;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD A Comma LParen BC
state_4267:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4268;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD A Comma LParen BC RParen
state_4268:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1231;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1231;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD A Comma LParen DE
state_4269:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD A Comma LParen DE RParen
state_4270:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1234;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1234;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD A Comma LParen HL
state_4271:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4272;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD A Comma LParen HL RParen
state_4272:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1237;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1237;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD B
state_4273:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4274;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD B Comma
state_4274:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD B Comma LParen
state_4275:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4276;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD B Comma LParen HL
state_4276:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4277;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD B Comma LParen HL RParen
state_4277:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1245;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1245;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD C
state_4278:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4279;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD C Comma
state_4279:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4280;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD C Comma LParen
state_4280:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD C Comma LParen HL
state_4281:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4282;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD C Comma LParen HL RParen
state_4282:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1253;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1253;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD D
state_4283:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4284;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD D Comma
state_4284:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4285;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD D Comma LParen
state_4285:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4286;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD D Comma LParen HL
state_4286:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4287;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD D Comma LParen HL RParen
state_4287:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1260;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1260;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD E
state_4288:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4289;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD E Comma
state_4289:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4290;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD E Comma LParen
state_4290:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4291;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD E Comma LParen HL
state_4291:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4292;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD E Comma LParen HL RParen
state_4292:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1268;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1268;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD H
state_4293:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4294;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD H Comma
state_4294:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4295;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD H Comma LParen
state_4295:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4296;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD H Comma LParen HL
state_4296:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4297;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD H Comma LParen HL RParen
state_4297:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1275;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD L
state_4298:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD L Comma
state_4299:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD L Comma LParen
state_4300:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4301;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD L Comma LParen HL
state_4301:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4302;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD L Comma LParen HL RParen
state_4302:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1291;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1291;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen
state_4303:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_4304;
	case Keyword::DE: m_lexer.next(); goto state_4308;
	case Keyword::HL: m_lexer.next(); goto state_4312;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen BC
state_4304:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4305;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen BC RParen
state_4305:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4306;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen BC RParen Comma
state_4306:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen BC RParen Comma A
state_4307:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1299;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen DE
state_4308:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4309;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen DE RParen
state_4309:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4310;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen DE RParen Comma
state_4310:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen DE RParen Comma A
state_4311:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1302;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1302;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL
state_4312:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4313;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen
state_4313:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4314;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen Comma
state_4314:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4315;
	case Keyword::B: m_lexer.next(); goto state_4316;
	case Keyword::C: m_lexer.next(); goto state_4317;
	case Keyword::D: m_lexer.next(); goto state_4318;
	case Keyword::E: m_lexer.next(); goto state_4319;
	case Keyword::H: m_lexer.next(); goto state_4320;
	case Keyword::L: m_lexer.next(); goto state_4321;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4322; }
	/*if (check_expr())*/ goto state_4322;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen Comma A
state_4315:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1305;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1305;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen Comma B
state_4316:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1306;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1306;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen Comma C
state_4317:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1307;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen Comma D
state_4318:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1308;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1308;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen Comma E
state_4319:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1309;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1309;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen Comma H
state_4320:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1310;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1310;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen Comma L
state_4321:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1311;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDD LParen HL RParen Comma expr
state_4322:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1312;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1312;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDDR
state_4323:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1375;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1375;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDDSR
state_4324:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1376;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1376;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI
state_4325:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4326;
	case Keyword::B: m_lexer.next(); goto state_4335;
	case Keyword::C: m_lexer.next(); goto state_4340;
	case Keyword::D: m_lexer.next(); goto state_4345;
	case Keyword::E: m_lexer.next(); goto state_4350;
	case Keyword::H: m_lexer.next(); goto state_4355;
	case Keyword::L: m_lexer.next(); goto state_4360;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1377;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1377;
	case TType::LParen: m_lexer.next(); goto state_4365;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI A
state_4326:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4327;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI A Comma
state_4327:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4328;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI A Comma LParen
state_4328:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_4329;
	case Keyword::DE: m_lexer.next(); goto state_4331;
	case Keyword::HL: m_lexer.next(); goto state_4333;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI A Comma LParen BC
state_4329:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4330;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI A Comma LParen BC RParen
state_4330:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1232;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1232;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI A Comma LParen DE
state_4331:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4332;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI A Comma LParen DE RParen
state_4332:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1235;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1235;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI A Comma LParen HL
state_4333:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4334;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI A Comma LParen HL RParen
state_4334:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1238;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1238;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI B
state_4335:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4336;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI B Comma
state_4336:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4337;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI B Comma LParen
state_4337:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4338;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI B Comma LParen HL
state_4338:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4339;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI B Comma LParen HL RParen
state_4339:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1246;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI C
state_4340:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4341;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI C Comma
state_4341:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4342;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI C Comma LParen
state_4342:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4343;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI C Comma LParen HL
state_4343:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4344;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI C Comma LParen HL RParen
state_4344:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1254;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1254;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI D
state_4345:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4346;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI D Comma
state_4346:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4347;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI D Comma LParen
state_4347:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI D Comma LParen HL
state_4348:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI D Comma LParen HL RParen
state_4349:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1261;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI E
state_4350:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI E Comma
state_4351:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4352;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI E Comma LParen
state_4352:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4353;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI E Comma LParen HL
state_4353:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4354;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI E Comma LParen HL RParen
state_4354:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1269;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI H
state_4355:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4356;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI H Comma
state_4356:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI H Comma LParen
state_4357:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI H Comma LParen HL
state_4358:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI H Comma LParen HL RParen
state_4359:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1276;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1276;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI L
state_4360:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4361;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI L Comma
state_4361:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4362;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI L Comma LParen
state_4362:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI L Comma LParen HL
state_4363:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4364;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI L Comma LParen HL RParen
state_4364:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1292;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1292;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen
state_4365:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_4366;
	case Keyword::DE: m_lexer.next(); goto state_4370;
	case Keyword::HL: m_lexer.next(); goto state_4374;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen BC
state_4366:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4367;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen BC RParen
state_4367:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4368;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen BC RParen Comma
state_4368:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4369;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen BC RParen Comma A
state_4369:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1300;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen DE
state_4370:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4371;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen DE RParen
state_4371:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4372;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen DE RParen Comma
state_4372:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4373;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen DE RParen Comma A
state_4373:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1303;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL
state_4374:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4375;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen
state_4375:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4376;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen Comma
state_4376:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4377;
	case Keyword::B: m_lexer.next(); goto state_4378;
	case Keyword::C: m_lexer.next(); goto state_4379;
	case Keyword::D: m_lexer.next(); goto state_4380;
	case Keyword::E: m_lexer.next(); goto state_4381;
	case Keyword::H: m_lexer.next(); goto state_4382;
	case Keyword::L: m_lexer.next(); goto state_4383;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4384; }
	/*if (check_expr())*/ goto state_4384;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen Comma A
state_4377:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1313;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1313;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen Comma B
state_4378:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1314;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1314;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen Comma C
state_4379:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1315;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen Comma D
state_4380:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1316;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1316;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen Comma E
state_4381:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1317;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1317;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen Comma H
state_4382:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1318;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1318;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen Comma L
state_4383:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1319;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1319;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDI LParen HL RParen Comma expr
state_4384:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1320;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1320;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDIR
state_4385:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1378;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1378;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LDISR
state_4386:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1379;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1379;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LSDDR
state_4387:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1380;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1380;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LSDR
state_4388:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1381;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1381;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LSIDR
state_4389:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1382;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1382;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE LSIR
state_4390:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1383;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1383;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR
state_4391:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4392;
	case Keyword::A1: m_lexer.next(); goto state_4409;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4426;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A
state_4392:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4393;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma
state_4393:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4394;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen
state_4394:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4395;
	case Keyword::IX: m_lexer.next(); goto state_4401;
	case Keyword::IY: m_lexer.next(); goto state_4405;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen HL
state_4395:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4396;
	case TType::Plus: m_lexer.next(); goto state_4398;
	case TType::RParen: m_lexer.next(); goto state_4400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen HL Minus
state_4396:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4397;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen HL Minus RParen
state_4397:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1384;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1384;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen HL Plus
state_4398:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4399;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen HL Plus RParen
state_4399:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1385;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1385;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen HL RParen
state_4400:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1386;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1386;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen IX
state_4401:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4402;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4403; }
	/*if (check_expr())*/ goto state_4403;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen IX RParen
state_4402:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1387;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1387;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen IX expr
state_4403:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4404;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen IX expr RParen
state_4404:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1388;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1388;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen IY
state_4405:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4406;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4407; }
	/*if (check_expr())*/ goto state_4407;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen IY RParen
state_4406:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1389;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1389;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen IY expr
state_4407:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4408;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A Comma LParen IY expr RParen
state_4408:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1390;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1390;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1
state_4409:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4410;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma
state_4410:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4411;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen
state_4411:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4412;
	case Keyword::IX: m_lexer.next(); goto state_4418;
	case Keyword::IY: m_lexer.next(); goto state_4422;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen HL
state_4412:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4413;
	case TType::Plus: m_lexer.next(); goto state_4415;
	case TType::RParen: m_lexer.next(); goto state_4417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen HL Minus
state_4413:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4414;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen HL Minus RParen
state_4414:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1135;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen HL Plus
state_4415:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4416;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen HL Plus RParen
state_4416:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1136;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1136;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen HL RParen
state_4417:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1137;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1137;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen IX
state_4418:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4419;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4420; }
	/*if (check_expr())*/ goto state_4420;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen IX RParen
state_4419:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1138;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen IX expr
state_4420:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen IX expr RParen
state_4421:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1139;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen IY
state_4422:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4423;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4424; }
	/*if (check_expr())*/ goto state_4424;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen IY RParen
state_4423:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1140;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen IY expr
state_4424:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4425;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR A1 Comma LParen IY expr RParen
state_4425:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1141;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen
state_4426:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4427;
	case Keyword::IX: m_lexer.next(); goto state_4433;
	case Keyword::IY: m_lexer.next(); goto state_4437;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen HL
state_4427:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4428;
	case TType::Plus: m_lexer.next(); goto state_4430;
	case TType::RParen: m_lexer.next(); goto state_4432;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen HL Minus
state_4428:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4429;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen HL Minus RParen
state_4429:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1384;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1384;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen HL Plus
state_4430:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4431;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen HL Plus RParen
state_4431:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1385;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1385;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen HL RParen
state_4432:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1386;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1386;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen IX
state_4433:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4434;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4435; }
	/*if (check_expr())*/ goto state_4435;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen IX RParen
state_4434:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1387;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1387;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen IX expr
state_4435:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4436;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen IX expr RParen
state_4436:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1388;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1388;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen IY
state_4437:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4438;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4439; }
	/*if (check_expr())*/ goto state_4439;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen IY RParen
state_4438:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1389;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1389;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen IY expr
state_4439:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4440;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE OR LParen IY expr RParen
state_4440:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1390;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1390;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES
state_4441:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4442; }
	/*if (check_const_expr())*/ goto state_4442;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr
state_4442:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4443;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma
state_4443:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4444;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen
state_4444:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4445;
	case Keyword::IX: m_lexer.next(); goto state_4447;
	case Keyword::IY: m_lexer.next(); goto state_4451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen HL
state_4445:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4446;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen HL RParen
state_4446:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1391;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1391;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen IX
state_4447:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4448;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4449; }
	/*if (check_expr())*/ goto state_4449;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen IX RParen
state_4448:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1392;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1392;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen IX expr
state_4449:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4450;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen IX expr RParen
state_4450:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1393;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1393;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen IY
state_4451:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4452;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4453; }
	/*if (check_expr())*/ goto state_4453;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen IY RParen
state_4452:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1394;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1394;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen IY expr
state_4453:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RES const_expr Comma LParen IY expr RParen
state_4454:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1395;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1395;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL
state_4455:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4456;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen
state_4456:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4457;
	case Keyword::IX: m_lexer.next(); goto state_4459;
	case Keyword::IY: m_lexer.next(); goto state_4463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen HL
state_4457:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4458;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen HL RParen
state_4458:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1396;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1396;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen IX
state_4459:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4460;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4461; }
	/*if (check_expr())*/ goto state_4461;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen IX RParen
state_4460:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1397;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1397;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen IX expr
state_4461:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4462;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen IX expr RParen
state_4462:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1398;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1398;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen IY
state_4463:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4464;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4465; }
	/*if (check_expr())*/ goto state_4465;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen IY RParen
state_4464:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1399;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1399;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen IY expr
state_4465:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RL LParen IY expr RParen
state_4466:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1400;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC
state_4467:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4468;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen
state_4468:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4469;
	case Keyword::IX: m_lexer.next(); goto state_4471;
	case Keyword::IY: m_lexer.next(); goto state_4475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen HL
state_4469:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen HL RParen
state_4470:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1401;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1401;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen IX
state_4471:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4472;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4473; }
	/*if (check_expr())*/ goto state_4473;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen IX RParen
state_4472:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1402;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1402;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen IX expr
state_4473:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4474;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen IX expr RParen
state_4474:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1403;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1403;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen IY
state_4475:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4476;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4477; }
	/*if (check_expr())*/ goto state_4477;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen IY RParen
state_4476:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1404;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1404;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen IY expr
state_4477:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RLC LParen IY expr RParen
state_4478:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1405;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1405;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR
state_4479:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4480;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen
state_4480:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4481;
	case Keyword::IX: m_lexer.next(); goto state_4483;
	case Keyword::IY: m_lexer.next(); goto state_4487;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen HL
state_4481:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen HL RParen
state_4482:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1406;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1406;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen IX
state_4483:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4484;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4485; }
	/*if (check_expr())*/ goto state_4485;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen IX RParen
state_4484:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1407;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1407;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen IX expr
state_4485:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen IX expr RParen
state_4486:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1408;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1408;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen IY
state_4487:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4488;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4489; }
	/*if (check_expr())*/ goto state_4489;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen IY RParen
state_4488:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1409;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1409;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen IY expr
state_4489:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4490;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RR LParen IY expr RParen
state_4490:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1410;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1410;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC
state_4491:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4492;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen
state_4492:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4493;
	case Keyword::IX: m_lexer.next(); goto state_4495;
	case Keyword::IY: m_lexer.next(); goto state_4499;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen HL
state_4493:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4494;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen HL RParen
state_4494:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1411;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1411;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen IX
state_4495:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4496;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4497; }
	/*if (check_expr())*/ goto state_4497;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen IX RParen
state_4496:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1412;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1412;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen IX expr
state_4497:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4498;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen IX expr RParen
state_4498:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1413;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1413;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen IY
state_4499:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4500;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4501; }
	/*if (check_expr())*/ goto state_4501;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen IY RParen
state_4500:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1414;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1414;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen IY expr
state_4501:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4502;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE RRC LParen IY expr RParen
state_4502:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1415;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1415;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC
state_4503:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4504;
	case Keyword::A1: m_lexer.next(); goto state_4521;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4538;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A
state_4504:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4505;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma
state_4505:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4506;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen
state_4506:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4507;
	case Keyword::IX: m_lexer.next(); goto state_4513;
	case Keyword::IY: m_lexer.next(); goto state_4517;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen HL
state_4507:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4508;
	case TType::Plus: m_lexer.next(); goto state_4510;
	case TType::RParen: m_lexer.next(); goto state_4512;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen HL Minus
state_4508:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4509;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen HL Minus RParen
state_4509:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1416;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1416;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen HL Plus
state_4510:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4511;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen HL Plus RParen
state_4511:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1417;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen HL RParen
state_4512:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1418;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1418;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen IX
state_4513:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4514;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4515; }
	/*if (check_expr())*/ goto state_4515;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen IX RParen
state_4514:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1419;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1419;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen IX expr
state_4515:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4516;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen IX expr RParen
state_4516:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1420;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1420;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen IY
state_4517:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4518;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4519; }
	/*if (check_expr())*/ goto state_4519;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen IY RParen
state_4518:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1421;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen IY expr
state_4519:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4520;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A Comma LParen IY expr RParen
state_4520:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1422;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1422;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1
state_4521:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4522;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma
state_4522:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen
state_4523:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4524;
	case Keyword::IX: m_lexer.next(); goto state_4530;
	case Keyword::IY: m_lexer.next(); goto state_4534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen HL
state_4524:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4525;
	case TType::Plus: m_lexer.next(); goto state_4527;
	case TType::RParen: m_lexer.next(); goto state_4529;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen HL Minus
state_4525:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4526;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen HL Minus RParen
state_4526:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1162;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen HL Plus
state_4527:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4528;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen HL Plus RParen
state_4528:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1163;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen HL RParen
state_4529:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1164;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1164;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen IX
state_4530:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4531;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4532; }
	/*if (check_expr())*/ goto state_4532;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen IX RParen
state_4531:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1165;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen IX expr
state_4532:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4533;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen IX expr RParen
state_4533:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1166;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen IY
state_4534:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4535;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4536; }
	/*if (check_expr())*/ goto state_4536;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen IY RParen
state_4535:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1167;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen IY expr
state_4536:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4537;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC A1 Comma LParen IY expr RParen
state_4537:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1168;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen
state_4538:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4539;
	case Keyword::IX: m_lexer.next(); goto state_4545;
	case Keyword::IY: m_lexer.next(); goto state_4549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen HL
state_4539:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4540;
	case TType::Plus: m_lexer.next(); goto state_4542;
	case TType::RParen: m_lexer.next(); goto state_4544;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen HL Minus
state_4540:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen HL Minus RParen
state_4541:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1416;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1416;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen HL Plus
state_4542:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen HL Plus RParen
state_4543:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1417;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen HL RParen
state_4544:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1418;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1418;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen IX
state_4545:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4546;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4547; }
	/*if (check_expr())*/ goto state_4547;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen IX RParen
state_4546:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1419;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1419;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen IX expr
state_4547:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4548;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen IX expr RParen
state_4548:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1420;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1420;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen IY
state_4549:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4550;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4551; }
	/*if (check_expr())*/ goto state_4551;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen IY RParen
state_4550:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1421;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen IY expr
state_4551:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SBC LParen IY expr RParen
state_4552:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1422;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1422;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET
state_4553:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4554; }
	/*if (check_const_expr())*/ goto state_4554;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr
state_4554:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4555;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma
state_4555:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen
state_4556:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4557;
	case Keyword::IX: m_lexer.next(); goto state_4559;
	case Keyword::IY: m_lexer.next(); goto state_4563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen HL
state_4557:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4558;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen HL RParen
state_4558:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1423;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1423;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen IX
state_4559:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4560;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4561; }
	/*if (check_expr())*/ goto state_4561;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen IX RParen
state_4560:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1424;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1424;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen IX expr
state_4561:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen IX expr RParen
state_4562:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1425;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1425;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen IY
state_4563:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4564;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4565; }
	/*if (check_expr())*/ goto state_4565;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen IY RParen
state_4564:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1426;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1426;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen IY expr
state_4565:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4566;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SET const_expr Comma LParen IY expr RParen
state_4566:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1427;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1427;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA
state_4567:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4568;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen
state_4568:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4569;
	case Keyword::IX: m_lexer.next(); goto state_4571;
	case Keyword::IY: m_lexer.next(); goto state_4575;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen HL
state_4569:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4570;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen HL RParen
state_4570:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1428;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1428;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen IX
state_4571:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4572;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4573; }
	/*if (check_expr())*/ goto state_4573;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen IX RParen
state_4572:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1429;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1429;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen IX expr
state_4573:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen IX expr RParen
state_4574:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1430;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1430;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen IY
state_4575:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4576;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4577; }
	/*if (check_expr())*/ goto state_4577;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen IY RParen
state_4576:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1431;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1431;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen IY expr
state_4577:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SLA LParen IY expr RParen
state_4578:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1432;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1432;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA
state_4579:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen
state_4580:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4581;
	case Keyword::IX: m_lexer.next(); goto state_4583;
	case Keyword::IY: m_lexer.next(); goto state_4587;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen HL
state_4581:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen HL RParen
state_4582:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1433;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1433;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen IX
state_4583:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4584;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4585; }
	/*if (check_expr())*/ goto state_4585;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen IX RParen
state_4584:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1434;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1434;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen IX expr
state_4585:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen IX expr RParen
state_4586:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1435;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1435;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen IY
state_4587:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4588;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4589; }
	/*if (check_expr())*/ goto state_4589;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen IY RParen
state_4588:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1436;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1436;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen IY expr
state_4589:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4590;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRA LParen IY expr RParen
state_4590:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1437;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1437;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL
state_4591:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4592;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen
state_4592:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4593;
	case Keyword::IX: m_lexer.next(); goto state_4595;
	case Keyword::IY: m_lexer.next(); goto state_4599;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen HL
state_4593:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4594;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen HL RParen
state_4594:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1438;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1438;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen IX
state_4595:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4596;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4597; }
	/*if (check_expr())*/ goto state_4597;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen IX RParen
state_4596:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1439;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1439;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen IX expr
state_4597:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4598;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen IX expr RParen
state_4598:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1440;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1440;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen IY
state_4599:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4600;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4601; }
	/*if (check_expr())*/ goto state_4601;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen IY RParen
state_4600:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1441;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1441;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen IY expr
state_4601:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4602;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SRL LParen IY expr RParen
state_4602:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1442;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1442;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB
state_4603:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4604;
	case Keyword::A1: m_lexer.next(); goto state_4621;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4638;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A
state_4604:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4605;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma
state_4605:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4606;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen
state_4606:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4607;
	case Keyword::IX: m_lexer.next(); goto state_4613;
	case Keyword::IY: m_lexer.next(); goto state_4617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen HL
state_4607:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4608;
	case TType::Plus: m_lexer.next(); goto state_4610;
	case TType::RParen: m_lexer.next(); goto state_4612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen HL Minus
state_4608:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4609;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen HL Minus RParen
state_4609:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1443;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1443;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen HL Plus
state_4610:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen HL Plus RParen
state_4611:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1444;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1444;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen HL RParen
state_4612:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1445;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1445;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen IX
state_4613:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4614;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4615; }
	/*if (check_expr())*/ goto state_4615;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen IX RParen
state_4614:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1446;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1446;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen IX expr
state_4615:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4616;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen IX expr RParen
state_4616:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1447;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1447;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen IY
state_4617:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4618;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4619; }
	/*if (check_expr())*/ goto state_4619;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen IY RParen
state_4618:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1448;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1448;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen IY expr
state_4619:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4620;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A Comma LParen IY expr RParen
state_4620:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1449;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1449;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1
state_4621:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4622;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma
state_4622:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen
state_4623:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4624;
	case Keyword::IX: m_lexer.next(); goto state_4630;
	case Keyword::IY: m_lexer.next(); goto state_4634;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen HL
state_4624:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4625;
	case TType::Plus: m_lexer.next(); goto state_4627;
	case TType::RParen: m_lexer.next(); goto state_4629;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen HL Minus
state_4625:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4626;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen HL Minus RParen
state_4626:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1184;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen HL Plus
state_4627:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4628;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen HL Plus RParen
state_4628:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1185;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen HL RParen
state_4629:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1186;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1186;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen IX
state_4630:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4631;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4632; }
	/*if (check_expr())*/ goto state_4632;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen IX RParen
state_4631:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1187;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen IX expr
state_4632:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen IX expr RParen
state_4633:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1188;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen IY
state_4634:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4635;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4636; }
	/*if (check_expr())*/ goto state_4636;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen IY RParen
state_4635:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1189;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen IY expr
state_4636:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB A1 Comma LParen IY expr RParen
state_4637:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1190;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen
state_4638:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4639;
	case Keyword::IX: m_lexer.next(); goto state_4645;
	case Keyword::IY: m_lexer.next(); goto state_4649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen HL
state_4639:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4640;
	case TType::Plus: m_lexer.next(); goto state_4642;
	case TType::RParen: m_lexer.next(); goto state_4644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen HL Minus
state_4640:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4641;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen HL Minus RParen
state_4641:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1443;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1443;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen HL Plus
state_4642:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4643;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen HL Plus RParen
state_4643:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1444;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1444;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen HL RParen
state_4644:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1445;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1445;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen IX
state_4645:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4646;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4647; }
	/*if (check_expr())*/ goto state_4647;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen IX RParen
state_4646:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1446;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1446;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen IX expr
state_4647:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4648;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen IX expr RParen
state_4648:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1447;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1447;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen IY
state_4649:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4650;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4651; }
	/*if (check_expr())*/ goto state_4651;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen IY RParen
state_4650:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1448;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1448;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen IY expr
state_4651:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4652;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE SUB LParen IY expr RParen
state_4652:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1449;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1449;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR
state_4653:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4654;
	case Keyword::A1: m_lexer.next(); goto state_4671;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4688;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A
state_4654:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4655;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma
state_4655:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen
state_4656:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4657;
	case Keyword::IX: m_lexer.next(); goto state_4663;
	case Keyword::IY: m_lexer.next(); goto state_4667;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen HL
state_4657:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4658;
	case TType::Plus: m_lexer.next(); goto state_4660;
	case TType::RParen: m_lexer.next(); goto state_4662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen HL Minus
state_4658:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen HL Minus RParen
state_4659:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1450;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1450;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen HL Plus
state_4660:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen HL Plus RParen
state_4661:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1451;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen HL RParen
state_4662:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1452;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1452;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen IX
state_4663:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4664;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4665; }
	/*if (check_expr())*/ goto state_4665;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen IX RParen
state_4664:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1453;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1453;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen IX expr
state_4665:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4666;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen IX expr RParen
state_4666:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1454;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen IY
state_4667:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4668;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4669; }
	/*if (check_expr())*/ goto state_4669;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen IY RParen
state_4668:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1455;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1455;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen IY expr
state_4669:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4670;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A Comma LParen IY expr RParen
state_4670:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1456;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1456;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1
state_4671:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4672;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma
state_4672:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen
state_4673:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4674;
	case Keyword::IX: m_lexer.next(); goto state_4680;
	case Keyword::IY: m_lexer.next(); goto state_4684;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen HL
state_4674:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4675;
	case TType::Plus: m_lexer.next(); goto state_4677;
	case TType::RParen: m_lexer.next(); goto state_4679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen HL Minus
state_4675:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4676;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen HL Minus RParen
state_4676:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1191;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1191;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen HL Plus
state_4677:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen HL Plus RParen
state_4678:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1192;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1192;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen HL RParen
state_4679:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1193;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1193;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen IX
state_4680:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4681;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4682; }
	/*if (check_expr())*/ goto state_4682;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen IX RParen
state_4681:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1194;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen IX expr
state_4682:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4683;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen IX expr RParen
state_4683:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1195;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen IY
state_4684:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4685;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4686; }
	/*if (check_expr())*/ goto state_4686;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen IY RParen
state_4685:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1196;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen IY expr
state_4686:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4687;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR A1 Comma LParen IY expr RParen
state_4687:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1197;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen
state_4688:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4689;
	case Keyword::IX: m_lexer.next(); goto state_4695;
	case Keyword::IY: m_lexer.next(); goto state_4699;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen HL
state_4689:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4690;
	case TType::Plus: m_lexer.next(); goto state_4692;
	case TType::RParen: m_lexer.next(); goto state_4694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen HL Minus
state_4690:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4691;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen HL Minus RParen
state_4691:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1450;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1450;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen HL Plus
state_4692:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4693;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen HL Plus RParen
state_4693:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1451;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen HL RParen
state_4694:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1452;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1452;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen IX
state_4695:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4696;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4697; }
	/*if (check_expr())*/ goto state_4697;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen IX RParen
state_4696:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1453;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1453;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen IX expr
state_4697:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4698;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen IX expr RParen
state_4698:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1454;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen IY
state_4699:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4700;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4701; }
	/*if (check_expr())*/ goto state_4701;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen IY RParen
state_4700:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1455;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1455;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen IY expr
state_4701:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOE XOR LParen IY expr RParen
state_4702:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1456;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1456;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI
state_4703:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::ADC: m_lexer.next(); goto state_4704;
	case Keyword::ADD: m_lexer.next(); goto state_4754;
	case Keyword::ALTD: m_lexer.next(); goto state_4804;
	case Keyword::AND: m_lexer.next(); goto state_5382;
	case Keyword::BIT: m_lexer.next(); goto state_5432;
	case Keyword::CMP: m_lexer.next(); goto state_5446;
	case Keyword::CP: m_lexer.next(); goto state_5479;
	case Keyword::DEC: m_lexer.next(); goto state_5512;
	case Keyword::INC: m_lexer.next(); goto state_5528;
	case Keyword::LD: m_lexer.next(); goto state_5544;
	case Keyword::LDD: m_lexer.next(); goto state_6058;
	case Keyword::LDDR: m_lexer.next(); goto state_6118;
	case Keyword::LDDSR: m_lexer.next(); goto state_6119;
	case Keyword::LDI: m_lexer.next(); goto state_6120;
	case Keyword::LDIR: m_lexer.next(); goto state_6180;
	case Keyword::LDISR: m_lexer.next(); goto state_6181;
	case Keyword::LSDDR: m_lexer.next(); goto state_6182;
	case Keyword::LSDR: m_lexer.next(); goto state_6183;
	case Keyword::LSIDR: m_lexer.next(); goto state_6184;
	case Keyword::LSIR: m_lexer.next(); goto state_6185;
	case Keyword::OR: m_lexer.next(); goto state_6186;
	case Keyword::RES: m_lexer.next(); goto state_6236;
	case Keyword::RL: m_lexer.next(); goto state_6250;
	case Keyword::RLC: m_lexer.next(); goto state_6262;
	case Keyword::RR: m_lexer.next(); goto state_6274;
	case Keyword::RRC: m_lexer.next(); goto state_6286;
	case Keyword::SBC: m_lexer.next(); goto state_6298;
	case Keyword::SET: m_lexer.next(); goto state_6348;
	case Keyword::SLA: m_lexer.next(); goto state_6362;
	case Keyword::SRA: m_lexer.next(); goto state_6374;
	case Keyword::SRL: m_lexer.next(); goto state_6386;
	case Keyword::SUB: m_lexer.next(); goto state_6398;
	case Keyword::XOR: m_lexer.next(); goto state_6448;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC
state_4704:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4705;
	case Keyword::A1: m_lexer.next(); goto state_4722;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A
state_4705:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4706;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma
state_4706:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4707;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen
state_4707:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4708;
	case Keyword::IX: m_lexer.next(); goto state_4714;
	case Keyword::IY: m_lexer.next(); goto state_4718;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen HL
state_4708:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4709;
	case TType::Plus: m_lexer.next(); goto state_4711;
	case TType::RParen: m_lexer.next(); goto state_4713;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen HL Minus
state_4709:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4710;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen HL Minus RParen
state_4710:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1457;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1457;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen HL Plus
state_4711:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4712;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen HL Plus RParen
state_4712:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1458;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1458;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen HL RParen
state_4713:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1459;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1459;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen IX
state_4714:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4715;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4716; }
	/*if (check_expr())*/ goto state_4716;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen IX RParen
state_4715:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1460;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1460;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen IX expr
state_4716:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4717;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen IX expr RParen
state_4717:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1461;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen IY
state_4718:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4719;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4720; }
	/*if (check_expr())*/ goto state_4720;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen IY RParen
state_4719:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1462;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1462;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen IY expr
state_4720:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4721;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A Comma LParen IY expr RParen
state_4721:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1463;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1
state_4722:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma
state_4723:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen
state_4724:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4725;
	case Keyword::IX: m_lexer.next(); goto state_4731;
	case Keyword::IY: m_lexer.next(); goto state_4735;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen HL
state_4725:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4726;
	case TType::Plus: m_lexer.next(); goto state_4728;
	case TType::RParen: m_lexer.next(); goto state_4730;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen HL Minus
state_4726:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4727;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen HL Minus RParen
state_4727:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1464;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen HL Plus
state_4728:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen HL Plus RParen
state_4729:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1465;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen HL RParen
state_4730:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen IX
state_4731:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4732;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4733; }
	/*if (check_expr())*/ goto state_4733;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen IX RParen
state_4732:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1467;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen IX expr
state_4733:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4734;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen IX expr RParen
state_4734:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1468;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1468;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen IY
state_4735:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4736;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4737; }
	/*if (check_expr())*/ goto state_4737;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen IY RParen
state_4736:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1469;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen IY expr
state_4737:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4738;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC A1 Comma LParen IY expr RParen
state_4738:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1470;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen
state_4739:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4740;
	case Keyword::IX: m_lexer.next(); goto state_4746;
	case Keyword::IY: m_lexer.next(); goto state_4750;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen HL
state_4740:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4741;
	case TType::Plus: m_lexer.next(); goto state_4743;
	case TType::RParen: m_lexer.next(); goto state_4745;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen HL Minus
state_4741:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4742;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen HL Minus RParen
state_4742:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1457;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1457;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen HL Plus
state_4743:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4744;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen HL Plus RParen
state_4744:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1458;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1458;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen HL RParen
state_4745:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1459;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1459;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen IX
state_4746:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4747;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4748; }
	/*if (check_expr())*/ goto state_4748;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen IX RParen
state_4747:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1460;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1460;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen IX expr
state_4748:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4749;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen IX expr RParen
state_4749:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1461;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen IY
state_4750:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4751;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4752; }
	/*if (check_expr())*/ goto state_4752;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen IY RParen
state_4751:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1462;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1462;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen IY expr
state_4752:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADC LParen IY expr RParen
state_4753:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1463;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD
state_4754:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4755;
	case Keyword::A1: m_lexer.next(); goto state_4772;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A
state_4755:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma
state_4756:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen
state_4757:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4758;
	case Keyword::IX: m_lexer.next(); goto state_4764;
	case Keyword::IY: m_lexer.next(); goto state_4768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen HL
state_4758:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4759;
	case TType::Plus: m_lexer.next(); goto state_4761;
	case TType::RParen: m_lexer.next(); goto state_4763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen HL Minus
state_4759:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen HL Minus RParen
state_4760:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1471;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1471;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen HL Plus
state_4761:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen HL Plus RParen
state_4762:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1472;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1472;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen HL RParen
state_4763:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1473;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1473;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen IX
state_4764:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4765;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4766; }
	/*if (check_expr())*/ goto state_4766;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen IX RParen
state_4765:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1474;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1474;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen IX expr
state_4766:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen IX expr RParen
state_4767:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1475;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen IY
state_4768:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4769;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4770; }
	/*if (check_expr())*/ goto state_4770;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen IY RParen
state_4769:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1476;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1476;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen IY expr
state_4770:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A Comma LParen IY expr RParen
state_4771:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1477;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1477;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1
state_4772:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma
state_4773:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen
state_4774:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4775;
	case Keyword::IX: m_lexer.next(); goto state_4781;
	case Keyword::IY: m_lexer.next(); goto state_4785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen HL
state_4775:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4776;
	case TType::Plus: m_lexer.next(); goto state_4778;
	case TType::RParen: m_lexer.next(); goto state_4780;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen HL Minus
state_4776:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen HL Minus RParen
state_4777:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1478;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen HL Plus
state_4778:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen HL Plus RParen
state_4779:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1479;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1479;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen HL RParen
state_4780:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1480;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1480;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen IX
state_4781:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4782;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4783; }
	/*if (check_expr())*/ goto state_4783;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen IX RParen
state_4782:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1481;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1481;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen IX expr
state_4783:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4784;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen IX expr RParen
state_4784:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1482;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen IY
state_4785:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4786;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4787; }
	/*if (check_expr())*/ goto state_4787;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen IY RParen
state_4786:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1483;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1483;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen IY expr
state_4787:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4788;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD A1 Comma LParen IY expr RParen
state_4788:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1484;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1484;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen
state_4789:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4790;
	case Keyword::IX: m_lexer.next(); goto state_4796;
	case Keyword::IY: m_lexer.next(); goto state_4800;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen HL
state_4790:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4791;
	case TType::Plus: m_lexer.next(); goto state_4793;
	case TType::RParen: m_lexer.next(); goto state_4795;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen HL Minus
state_4791:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4792;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen HL Minus RParen
state_4792:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1471;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1471;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen HL Plus
state_4793:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4794;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen HL Plus RParen
state_4794:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1472;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1472;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen HL RParen
state_4795:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1473;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1473;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen IX
state_4796:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4797;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4798; }
	/*if (check_expr())*/ goto state_4798;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen IX RParen
state_4797:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1474;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1474;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen IX expr
state_4798:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4799;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen IX expr RParen
state_4799:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1475;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen IY
state_4800:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4801;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4802; }
	/*if (check_expr())*/ goto state_4802;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen IY RParen
state_4801:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1476;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1476;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen IY expr
state_4802:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ADD LParen IY expr RParen
state_4803:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1477;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1477;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD
state_4804:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::ADC: m_lexer.next(); goto state_4805;
	case Keyword::ADD: m_lexer.next(); goto state_4838;
	case Keyword::AND: m_lexer.next(); goto state_4871;
	case Keyword::BIT: m_lexer.next(); goto state_4904;
	case Keyword::CP: m_lexer.next(); goto state_4918;
	case Keyword::DEC: m_lexer.next(); goto state_4951;
	case Keyword::INC: m_lexer.next(); goto state_4967;
	case Keyword::LD: m_lexer.next(); goto state_4983;
	case Keyword::OR: m_lexer.next(); goto state_5166;
	case Keyword::RL: m_lexer.next(); goto state_5199;
	case Keyword::RLC: m_lexer.next(); goto state_5211;
	case Keyword::RR: m_lexer.next(); goto state_5223;
	case Keyword::RRC: m_lexer.next(); goto state_5235;
	case Keyword::SBC: m_lexer.next(); goto state_5247;
	case Keyword::SLA: m_lexer.next(); goto state_5280;
	case Keyword::SRA: m_lexer.next(); goto state_5292;
	case Keyword::SRL: m_lexer.next(); goto state_5304;
	case Keyword::SUB: m_lexer.next(); goto state_5316;
	case Keyword::XOR: m_lexer.next(); goto state_5349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC
state_4805:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4806;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A
state_4806:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4807;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma
state_4807:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4808;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen
state_4808:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4809;
	case Keyword::IX: m_lexer.next(); goto state_4815;
	case Keyword::IY: m_lexer.next(); goto state_4819;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen HL
state_4809:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4810;
	case TType::Plus: m_lexer.next(); goto state_4812;
	case TType::RParen: m_lexer.next(); goto state_4814;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen HL Minus
state_4810:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4811;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen HL Minus RParen
state_4811:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1464;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen HL Plus
state_4812:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4813;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen HL Plus RParen
state_4813:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1465;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen HL RParen
state_4814:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen IX
state_4815:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4816;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4817; }
	/*if (check_expr())*/ goto state_4817;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen IX RParen
state_4816:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1467;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen IX expr
state_4817:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4818;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen IX expr RParen
state_4818:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1468;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1468;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen IY
state_4819:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4820;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4821; }
	/*if (check_expr())*/ goto state_4821;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen IY RParen
state_4820:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1469;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen IY expr
state_4821:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4822;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC A Comma LParen IY expr RParen
state_4822:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1470;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen
state_4823:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4824;
	case Keyword::IX: m_lexer.next(); goto state_4830;
	case Keyword::IY: m_lexer.next(); goto state_4834;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen HL
state_4824:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4825;
	case TType::Plus: m_lexer.next(); goto state_4827;
	case TType::RParen: m_lexer.next(); goto state_4829;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen HL Minus
state_4825:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen HL Minus RParen
state_4826:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1464;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen HL Plus
state_4827:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4828;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen HL Plus RParen
state_4828:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1465;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen HL RParen
state_4829:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen IX
state_4830:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4831;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4832; }
	/*if (check_expr())*/ goto state_4832;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen IX RParen
state_4831:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1467;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen IX expr
state_4832:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen IX expr RParen
state_4833:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1468;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1468;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen IY
state_4834:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4835;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4836; }
	/*if (check_expr())*/ goto state_4836;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen IY RParen
state_4835:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1469;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen IY expr
state_4836:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4837;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADC LParen IY expr RParen
state_4837:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1470;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD
state_4838:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4839;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4856;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A
state_4839:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4840;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma
state_4840:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen
state_4841:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4842;
	case Keyword::IX: m_lexer.next(); goto state_4848;
	case Keyword::IY: m_lexer.next(); goto state_4852;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen HL
state_4842:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4843;
	case TType::Plus: m_lexer.next(); goto state_4845;
	case TType::RParen: m_lexer.next(); goto state_4847;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen HL Minus
state_4843:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4844;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen HL Minus RParen
state_4844:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1478;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen HL Plus
state_4845:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4846;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen HL Plus RParen
state_4846:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1479;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1479;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen HL RParen
state_4847:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1480;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1480;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen IX
state_4848:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4849;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4850; }
	/*if (check_expr())*/ goto state_4850;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen IX RParen
state_4849:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1481;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1481;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen IX expr
state_4850:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4851;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen IX expr RParen
state_4851:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1482;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen IY
state_4852:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4853;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4854; }
	/*if (check_expr())*/ goto state_4854;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen IY RParen
state_4853:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1483;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1483;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen IY expr
state_4854:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4855;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD A Comma LParen IY expr RParen
state_4855:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1484;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1484;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen
state_4856:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4857;
	case Keyword::IX: m_lexer.next(); goto state_4863;
	case Keyword::IY: m_lexer.next(); goto state_4867;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen HL
state_4857:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4858;
	case TType::Plus: m_lexer.next(); goto state_4860;
	case TType::RParen: m_lexer.next(); goto state_4862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen HL Minus
state_4858:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4859;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen HL Minus RParen
state_4859:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1478;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen HL Plus
state_4860:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4861;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen HL Plus RParen
state_4861:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1479;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1479;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen HL RParen
state_4862:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1480;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1480;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen IX
state_4863:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4864;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4865; }
	/*if (check_expr())*/ goto state_4865;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen IX RParen
state_4864:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1481;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1481;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen IX expr
state_4865:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen IX expr RParen
state_4866:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1482;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen IY
state_4867:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4868;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4869; }
	/*if (check_expr())*/ goto state_4869;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen IY RParen
state_4868:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1483;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1483;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen IY expr
state_4869:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4870;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD ADD LParen IY expr RParen
state_4870:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1484;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1484;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND
state_4871:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4872;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4889;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A
state_4872:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4873;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma
state_4873:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4874;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen
state_4874:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4875;
	case Keyword::IX: m_lexer.next(); goto state_4881;
	case Keyword::IY: m_lexer.next(); goto state_4885;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen HL
state_4875:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4876;
	case TType::Plus: m_lexer.next(); goto state_4878;
	case TType::RParen: m_lexer.next(); goto state_4880;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen HL Minus
state_4876:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4877;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen HL Minus RParen
state_4877:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1485;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1485;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen HL Plus
state_4878:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4879;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen HL Plus RParen
state_4879:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1486;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen HL RParen
state_4880:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1487;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1487;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen IX
state_4881:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4882;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4883; }
	/*if (check_expr())*/ goto state_4883;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen IX RParen
state_4882:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1488;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen IX expr
state_4883:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4884;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen IX expr RParen
state_4884:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1489;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1489;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen IY
state_4885:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4886;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4887; }
	/*if (check_expr())*/ goto state_4887;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen IY RParen
state_4886:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1490;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1490;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen IY expr
state_4887:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND A Comma LParen IY expr RParen
state_4888:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1491;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1491;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen
state_4889:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4890;
	case Keyword::IX: m_lexer.next(); goto state_4896;
	case Keyword::IY: m_lexer.next(); goto state_4900;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen HL
state_4890:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4891;
	case TType::Plus: m_lexer.next(); goto state_4893;
	case TType::RParen: m_lexer.next(); goto state_4895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen HL Minus
state_4891:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen HL Minus RParen
state_4892:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1485;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1485;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen HL Plus
state_4893:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4894;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen HL Plus RParen
state_4894:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1486;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen HL RParen
state_4895:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1487;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1487;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen IX
state_4896:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4897;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4898; }
	/*if (check_expr())*/ goto state_4898;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen IX RParen
state_4897:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1488;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen IX expr
state_4898:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen IX expr RParen
state_4899:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1489;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1489;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen IY
state_4900:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4901;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4902; }
	/*if (check_expr())*/ goto state_4902;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen IY RParen
state_4901:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1490;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1490;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen IY expr
state_4902:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD AND LParen IY expr RParen
state_4903:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1491;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1491;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT
state_4904:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4905; }
	/*if (check_const_expr())*/ goto state_4905;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr
state_4905:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma
state_4906:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen
state_4907:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4908;
	case Keyword::IX: m_lexer.next(); goto state_4910;
	case Keyword::IY: m_lexer.next(); goto state_4914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen HL
state_4908:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen HL RParen
state_4909:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1492;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1492;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen IX
state_4910:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4911;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4912; }
	/*if (check_expr())*/ goto state_4912;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen IX RParen
state_4911:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1493;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1493;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen IX expr
state_4912:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen IX expr RParen
state_4913:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1494;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1494;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen IY
state_4914:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4915;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4916; }
	/*if (check_expr())*/ goto state_4916;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen IY RParen
state_4915:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1495;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1495;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen IY expr
state_4916:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD BIT const_expr Comma LParen IY expr RParen
state_4917:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1496;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1496;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP
state_4918:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4919;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4936;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A
state_4919:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4920;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma
state_4920:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4921;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen
state_4921:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4922;
	case Keyword::IX: m_lexer.next(); goto state_4928;
	case Keyword::IY: m_lexer.next(); goto state_4932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen HL
state_4922:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4923;
	case TType::Plus: m_lexer.next(); goto state_4925;
	case TType::RParen: m_lexer.next(); goto state_4927;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen HL Minus
state_4923:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen HL Minus RParen
state_4924:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1497;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1497;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen HL Plus
state_4925:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen HL Plus RParen
state_4926:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1498;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1498;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen HL RParen
state_4927:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1499;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1499;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen IX
state_4928:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4929;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4930; }
	/*if (check_expr())*/ goto state_4930;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen IX RParen
state_4929:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1500;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen IX expr
state_4930:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen IX expr RParen
state_4931:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1501;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1501;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen IY
state_4932:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4933;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4934; }
	/*if (check_expr())*/ goto state_4934;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen IY RParen
state_4933:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1502;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1502;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen IY expr
state_4934:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP A Comma LParen IY expr RParen
state_4935:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1503;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1503;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen
state_4936:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4937;
	case Keyword::IX: m_lexer.next(); goto state_4943;
	case Keyword::IY: m_lexer.next(); goto state_4947;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen HL
state_4937:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4938;
	case TType::Plus: m_lexer.next(); goto state_4940;
	case TType::RParen: m_lexer.next(); goto state_4942;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen HL Minus
state_4938:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4939;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen HL Minus RParen
state_4939:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1497;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1497;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen HL Plus
state_4940:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4941;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen HL Plus RParen
state_4941:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1498;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1498;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen HL RParen
state_4942:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1499;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1499;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen IX
state_4943:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4944;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4945; }
	/*if (check_expr())*/ goto state_4945;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen IX RParen
state_4944:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1500;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen IX expr
state_4945:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4946;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen IX expr RParen
state_4946:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1501;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1501;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen IY
state_4947:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4948;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4949; }
	/*if (check_expr())*/ goto state_4949;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen IY RParen
state_4948:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1502;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1502;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen IY expr
state_4949:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4950;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD CP LParen IY expr RParen
state_4950:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1503;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1503;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC
state_4951:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4952;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen
state_4952:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4953;
	case Keyword::IX: m_lexer.next(); goto state_4959;
	case Keyword::IY: m_lexer.next(); goto state_4963;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen HL
state_4953:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4954;
	case TType::Plus: m_lexer.next(); goto state_4956;
	case TType::RParen: m_lexer.next(); goto state_4958;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen HL Minus
state_4954:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4955;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen HL Minus RParen
state_4955:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1504;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1504;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen HL Plus
state_4956:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4957;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen HL Plus RParen
state_4957:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1505;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1505;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen HL RParen
state_4958:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1506;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1506;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen IX
state_4959:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4960;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4961; }
	/*if (check_expr())*/ goto state_4961;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen IX RParen
state_4960:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1507;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1507;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen IX expr
state_4961:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4962;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen IX expr RParen
state_4962:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1508;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1508;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen IY
state_4963:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4964;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4965; }
	/*if (check_expr())*/ goto state_4965;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen IY RParen
state_4964:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1509;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1509;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen IY expr
state_4965:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4966;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD DEC LParen IY expr RParen
state_4966:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1510;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1510;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC
state_4967:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4968;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen
state_4968:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_4969;
	case Keyword::IX: m_lexer.next(); goto state_4975;
	case Keyword::IY: m_lexer.next(); goto state_4979;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen HL
state_4969:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4970;
	case TType::Plus: m_lexer.next(); goto state_4972;
	case TType::RParen: m_lexer.next(); goto state_4974;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen HL Minus
state_4970:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4971;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen HL Minus RParen
state_4971:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1511;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1511;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen HL Plus
state_4972:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4973;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen HL Plus RParen
state_4973:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1512;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1512;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen HL RParen
state_4974:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1513;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1513;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen IX
state_4975:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4976;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4977; }
	/*if (check_expr())*/ goto state_4977;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen IX RParen
state_4976:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1514;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1514;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen IX expr
state_4977:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen IX expr RParen
state_4978:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1515;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1515;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen IY
state_4979:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4980;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_4981; }
	/*if (check_expr())*/ goto state_4981;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen IY RParen
state_4980:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1516;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1516;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen IY expr
state_4981:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4982;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD INC LParen IY expr RParen
state_4982:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1517;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1517;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD
state_4983:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_4984;
	case Keyword::B: m_lexer.next(); goto state_5018;
	case Keyword::BC: m_lexer.next(); goto state_5039;
	case Keyword::C: m_lexer.next(); goto state_5042;
	case Keyword::D: m_lexer.next(); goto state_5063;
	case Keyword::DE: m_lexer.next(); goto state_5084;
	case Keyword::E: m_lexer.next(); goto state_5087;
	case Keyword::H: m_lexer.next(); goto state_5108;
	case Keyword::HL: m_lexer.next(); goto state_5129;
	case Keyword::L: m_lexer.next(); goto state_5145;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A
state_4984:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_4985;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma
state_4985:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_4986;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5017; }
	/*if (check_expr())*/ goto state_5017;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen
state_4986:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_4987;
	case Keyword::DE: m_lexer.next(); goto state_4993;
	case Keyword::HL: m_lexer.next(); goto state_4999;
	case Keyword::HLD: m_lexer.next(); goto state_5005;
	case Keyword::HLI: m_lexer.next(); goto state_5007;
	case Keyword::IX: m_lexer.next(); goto state_5009;
	case Keyword::IY: m_lexer.next(); goto state_5013;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen BC
state_4987:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4988;
	case TType::Plus: m_lexer.next(); goto state_4990;
	case TType::RParen: m_lexer.next(); goto state_4992;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen BC Minus
state_4988:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen BC Minus RParen
state_4989:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1518;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1518;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen BC Plus
state_4990:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4991;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen BC Plus RParen
state_4991:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1519;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1519;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen BC RParen
state_4992:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1520;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1520;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen DE
state_4993:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_4994;
	case TType::Plus: m_lexer.next(); goto state_4996;
	case TType::RParen: m_lexer.next(); goto state_4998;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen DE Minus
state_4994:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4995;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen DE Minus RParen
state_4995:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1521;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1521;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen DE Plus
state_4996:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_4997;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen DE Plus RParen
state_4997:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1522;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1522;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen DE RParen
state_4998:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1523;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HL
state_4999:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5000;
	case TType::Plus: m_lexer.next(); goto state_5002;
	case TType::RParen: m_lexer.next(); goto state_5004;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HL Minus
state_5000:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5001;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HL Minus RParen
state_5001:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1524;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HL Plus
state_5002:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5003;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HL Plus RParen
state_5003:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1525;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HL RParen
state_5004:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1526;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1526;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HLD
state_5005:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5006;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HLD RParen
state_5006:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1524;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HLI
state_5007:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5008;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen HLI RParen
state_5008:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1525;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen IX
state_5009:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5010;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5011; }
	/*if (check_expr())*/ goto state_5011;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen IX RParen
state_5010:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1527;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1527;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen IX expr
state_5011:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5012;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen IX expr RParen
state_5012:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1528;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1528;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen IY
state_5013:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5014;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5015; }
	/*if (check_expr())*/ goto state_5015;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen IY RParen
state_5014:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1529;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1529;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen IY expr
state_5015:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5016;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma LParen IY expr RParen
state_5016:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1530;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1530;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD A Comma expr
state_5017:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1531;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B
state_5018:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5019;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma
state_5019:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5020;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen
state_5020:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5021;
	case Keyword::HLD: m_lexer.next(); goto state_5027;
	case Keyword::HLI: m_lexer.next(); goto state_5029;
	case Keyword::IX: m_lexer.next(); goto state_5031;
	case Keyword::IY: m_lexer.next(); goto state_5035;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HL
state_5021:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5022;
	case TType::Plus: m_lexer.next(); goto state_5024;
	case TType::RParen: m_lexer.next(); goto state_5026;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HL Minus
state_5022:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5023;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HL Minus RParen
state_5023:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1532;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1532;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HL Plus
state_5024:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5025;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HL Plus RParen
state_5025:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1533;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1533;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HL RParen
state_5026:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1534;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HLD
state_5027:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5028;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HLD RParen
state_5028:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1532;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1532;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HLI
state_5029:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5030;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen HLI RParen
state_5030:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1533;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1533;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen IX
state_5031:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5032;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5033; }
	/*if (check_expr())*/ goto state_5033;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen IX RParen
state_5032:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1535;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1535;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen IX expr
state_5033:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5034;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen IX expr RParen
state_5034:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1536;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1536;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen IY
state_5035:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5036;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5037; }
	/*if (check_expr())*/ goto state_5037;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen IY RParen
state_5036:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1537;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1537;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen IY expr
state_5037:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5038;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD B Comma LParen IY expr RParen
state_5038:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1538;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1538;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD BC
state_5039:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5040;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD BC Comma
state_5040:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5041; }
	/*if (check_expr())*/ goto state_5041;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD BC Comma expr
state_5041:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1539;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1539;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C
state_5042:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5043;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma
state_5043:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5044;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen
state_5044:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5045;
	case Keyword::HLD: m_lexer.next(); goto state_5051;
	case Keyword::HLI: m_lexer.next(); goto state_5053;
	case Keyword::IX: m_lexer.next(); goto state_5055;
	case Keyword::IY: m_lexer.next(); goto state_5059;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HL
state_5045:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5046;
	case TType::Plus: m_lexer.next(); goto state_5048;
	case TType::RParen: m_lexer.next(); goto state_5050;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HL Minus
state_5046:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5047;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HL Minus RParen
state_5047:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1540;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HL Plus
state_5048:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5049;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HL Plus RParen
state_5049:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1541;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HL RParen
state_5050:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1542;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1542;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HLD
state_5051:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5052;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HLD RParen
state_5052:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1540;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HLI
state_5053:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5054;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen HLI RParen
state_5054:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1541;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen IX
state_5055:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5056;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5057; }
	/*if (check_expr())*/ goto state_5057;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen IX RParen
state_5056:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1543;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen IX expr
state_5057:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5058;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen IX expr RParen
state_5058:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1544;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1544;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen IY
state_5059:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5060;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5061; }
	/*if (check_expr())*/ goto state_5061;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen IY RParen
state_5060:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1545;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1545;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen IY expr
state_5061:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5062;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD C Comma LParen IY expr RParen
state_5062:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1546;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1546;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D
state_5063:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5064;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma
state_5064:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5065;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen
state_5065:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5066;
	case Keyword::HLD: m_lexer.next(); goto state_5072;
	case Keyword::HLI: m_lexer.next(); goto state_5074;
	case Keyword::IX: m_lexer.next(); goto state_5076;
	case Keyword::IY: m_lexer.next(); goto state_5080;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HL
state_5066:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5067;
	case TType::Plus: m_lexer.next(); goto state_5069;
	case TType::RParen: m_lexer.next(); goto state_5071;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HL Minus
state_5067:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5068;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HL Minus RParen
state_5068:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1547;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1547;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HL Plus
state_5069:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5070;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HL Plus RParen
state_5070:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1548;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1548;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HL RParen
state_5071:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1549;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HLD
state_5072:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5073;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HLD RParen
state_5073:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1547;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1547;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HLI
state_5074:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen HLI RParen
state_5075:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1548;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1548;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen IX
state_5076:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5077;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5078; }
	/*if (check_expr())*/ goto state_5078;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen IX RParen
state_5077:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1550;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1550;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen IX expr
state_5078:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5079;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen IX expr RParen
state_5079:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1551;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1551;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen IY
state_5080:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5081;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5082; }
	/*if (check_expr())*/ goto state_5082;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen IY RParen
state_5081:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1552;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen IY expr
state_5082:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5083;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD D Comma LParen IY expr RParen
state_5083:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1553;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1553;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD DE
state_5084:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD DE Comma
state_5085:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5086; }
	/*if (check_expr())*/ goto state_5086;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD DE Comma expr
state_5086:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1554;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1554;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E
state_5087:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5088;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma
state_5088:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5089;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen
state_5089:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5090;
	case Keyword::HLD: m_lexer.next(); goto state_5096;
	case Keyword::HLI: m_lexer.next(); goto state_5098;
	case Keyword::IX: m_lexer.next(); goto state_5100;
	case Keyword::IY: m_lexer.next(); goto state_5104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HL
state_5090:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5091;
	case TType::Plus: m_lexer.next(); goto state_5093;
	case TType::RParen: m_lexer.next(); goto state_5095;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HL Minus
state_5091:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5092;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HL Minus RParen
state_5092:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1555;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1555;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HL Plus
state_5093:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5094;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HL Plus RParen
state_5094:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1556;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HL RParen
state_5095:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1557;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HLD
state_5096:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5097;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HLD RParen
state_5097:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1555;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1555;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HLI
state_5098:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5099;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen HLI RParen
state_5099:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1556;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen IX
state_5100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5101;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5102; }
	/*if (check_expr())*/ goto state_5102;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen IX RParen
state_5101:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1558;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1558;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen IX expr
state_5102:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5103;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen IX expr RParen
state_5103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1559;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1559;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen IY
state_5104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5105;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5106; }
	/*if (check_expr())*/ goto state_5106;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen IY RParen
state_5105:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1560;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1560;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen IY expr
state_5106:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD E Comma LParen IY expr RParen
state_5107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1561;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1561;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H
state_5108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma
state_5109:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5110;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen
state_5110:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5111;
	case Keyword::HLD: m_lexer.next(); goto state_5117;
	case Keyword::HLI: m_lexer.next(); goto state_5119;
	case Keyword::IX: m_lexer.next(); goto state_5121;
	case Keyword::IY: m_lexer.next(); goto state_5125;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HL
state_5111:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5112;
	case TType::Plus: m_lexer.next(); goto state_5114;
	case TType::RParen: m_lexer.next(); goto state_5116;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HL Minus
state_5112:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5113;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HL Minus RParen
state_5113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1562;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HL Plus
state_5114:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HL Plus RParen
state_5115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1563;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HL RParen
state_5116:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1564;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1564;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HLD
state_5117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5118;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HLD RParen
state_5118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1562;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HLI
state_5119:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5120;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen HLI RParen
state_5120:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1563;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen IX
state_5121:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5122;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5123; }
	/*if (check_expr())*/ goto state_5123;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen IX RParen
state_5122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1565;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1565;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen IX expr
state_5123:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5124;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen IX expr RParen
state_5124:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1566;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1566;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen IY
state_5125:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5126;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5127; }
	/*if (check_expr())*/ goto state_5127;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen IY RParen
state_5126:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1567;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen IY expr
state_5127:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD H Comma LParen IY expr RParen
state_5128:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1568;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1568;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL
state_5129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5130;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma
state_5130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5131;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5144; }
	/*if (check_expr())*/ goto state_5144;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen
state_5131:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5132;
	case Keyword::IX: m_lexer.next(); goto state_5136;
	case Keyword::IY: m_lexer.next(); goto state_5140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen HL
state_5132:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5133;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5134; }
	/*if (check_expr())*/ goto state_5134;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen HL RParen
state_5133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1569;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1569;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen HL expr
state_5134:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen HL expr RParen
state_5135:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1570;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1570;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen IX
state_5136:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5137;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5138; }
	/*if (check_expr())*/ goto state_5138;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen IX RParen
state_5137:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1571;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1571;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen IX expr
state_5138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen IX expr RParen
state_5139:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1572;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1572;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen IY
state_5140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5141;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5142; }
	/*if (check_expr())*/ goto state_5142;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen IY RParen
state_5141:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1573;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1573;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen IY expr
state_5142:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5143;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma LParen IY expr RParen
state_5143:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1574;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD HL Comma expr
state_5144:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1575;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1575;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L
state_5145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma
state_5146:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen
state_5147:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5148;
	case Keyword::HLD: m_lexer.next(); goto state_5154;
	case Keyword::HLI: m_lexer.next(); goto state_5156;
	case Keyword::IX: m_lexer.next(); goto state_5158;
	case Keyword::IY: m_lexer.next(); goto state_5162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HL
state_5148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5149;
	case TType::Plus: m_lexer.next(); goto state_5151;
	case TType::RParen: m_lexer.next(); goto state_5153;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HL Minus
state_5149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5150;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HL Minus RParen
state_5150:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1576;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HL Plus
state_5151:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HL Plus RParen
state_5152:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1577;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HL RParen
state_5153:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1578;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HLD
state_5154:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5155;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HLD RParen
state_5155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1576;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HLI
state_5156:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5157;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen HLI RParen
state_5157:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1577;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen IX
state_5158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5159;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5160; }
	/*if (check_expr())*/ goto state_5160;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen IX RParen
state_5159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1579;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1579;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen IX expr
state_5160:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5161;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen IX expr RParen
state_5161:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1580;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen IY
state_5162:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5163;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5164; }
	/*if (check_expr())*/ goto state_5164;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen IY RParen
state_5163:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1581;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1581;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen IY expr
state_5164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD LD L Comma LParen IY expr RParen
state_5165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1582;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR
state_5166:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5167;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A
state_5167:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma
state_5168:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5169;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen
state_5169:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5170;
	case Keyword::IX: m_lexer.next(); goto state_5176;
	case Keyword::IY: m_lexer.next(); goto state_5180;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen HL
state_5170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5171;
	case TType::Plus: m_lexer.next(); goto state_5173;
	case TType::RParen: m_lexer.next(); goto state_5175;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen HL Minus
state_5171:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5172;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen HL Minus RParen
state_5172:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1583;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1583;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen HL Plus
state_5173:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5174;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen HL Plus RParen
state_5174:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1584;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen HL RParen
state_5175:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1585;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen IX
state_5176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5177;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5178; }
	/*if (check_expr())*/ goto state_5178;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen IX RParen
state_5177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1586;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen IX expr
state_5178:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5179;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen IX expr RParen
state_5179:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1587;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1587;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen IY
state_5180:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5181;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5182; }
	/*if (check_expr())*/ goto state_5182;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen IY RParen
state_5181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1588;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1588;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen IY expr
state_5182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5183;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR A Comma LParen IY expr RParen
state_5183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1589;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen
state_5184:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5185;
	case Keyword::IX: m_lexer.next(); goto state_5191;
	case Keyword::IY: m_lexer.next(); goto state_5195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen HL
state_5185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5186;
	case TType::Plus: m_lexer.next(); goto state_5188;
	case TType::RParen: m_lexer.next(); goto state_5190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen HL Minus
state_5186:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen HL Minus RParen
state_5187:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1583;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1583;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen HL Plus
state_5188:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen HL Plus RParen
state_5189:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1584;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen HL RParen
state_5190:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1585;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen IX
state_5191:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5192;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5193; }
	/*if (check_expr())*/ goto state_5193;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen IX RParen
state_5192:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1586;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen IX expr
state_5193:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen IX expr RParen
state_5194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1587;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1587;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen IY
state_5195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5196;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5197; }
	/*if (check_expr())*/ goto state_5197;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen IY RParen
state_5196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1588;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1588;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen IY expr
state_5197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5198;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD OR LParen IY expr RParen
state_5198:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1589;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL
state_5199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen
state_5200:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5201;
	case Keyword::IX: m_lexer.next(); goto state_5203;
	case Keyword::IY: m_lexer.next(); goto state_5207;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen HL
state_5201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5202;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen HL RParen
state_5202:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1590;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1590;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen IX
state_5203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5204;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5205; }
	/*if (check_expr())*/ goto state_5205;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen IX RParen
state_5204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1591;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1591;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen IX expr
state_5205:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5206;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen IX expr RParen
state_5206:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1592;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1592;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen IY
state_5207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5208;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5209; }
	/*if (check_expr())*/ goto state_5209;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen IY RParen
state_5208:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1593;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1593;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen IY expr
state_5209:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RL LParen IY expr RParen
state_5210:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1594;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1594;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC
state_5211:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen
state_5212:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5213;
	case Keyword::IX: m_lexer.next(); goto state_5215;
	case Keyword::IY: m_lexer.next(); goto state_5219;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen HL
state_5213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen HL RParen
state_5214:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1595;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1595;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen IX
state_5215:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5216;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5217; }
	/*if (check_expr())*/ goto state_5217;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen IX RParen
state_5216:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1596;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1596;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen IX expr
state_5217:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5218;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen IX expr RParen
state_5218:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1597;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1597;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen IY
state_5219:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5220;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5221; }
	/*if (check_expr())*/ goto state_5221;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen IY RParen
state_5220:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1598;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1598;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen IY expr
state_5221:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5222;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RLC LParen IY expr RParen
state_5222:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1599;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1599;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR
state_5223:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5224;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen
state_5224:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5225;
	case Keyword::IX: m_lexer.next(); goto state_5227;
	case Keyword::IY: m_lexer.next(); goto state_5231;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen HL
state_5225:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5226;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen HL RParen
state_5226:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1600;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen IX
state_5227:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5228;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5229; }
	/*if (check_expr())*/ goto state_5229;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen IX RParen
state_5228:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1601;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1601;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen IX expr
state_5229:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5230;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen IX expr RParen
state_5230:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1602;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1602;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen IY
state_5231:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5232;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5233; }
	/*if (check_expr())*/ goto state_5233;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen IY RParen
state_5232:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1603;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1603;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen IY expr
state_5233:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5234;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RR LParen IY expr RParen
state_5234:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1604;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1604;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC
state_5235:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5236;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen
state_5236:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5237;
	case Keyword::IX: m_lexer.next(); goto state_5239;
	case Keyword::IY: m_lexer.next(); goto state_5243;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen HL
state_5237:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5238;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen HL RParen
state_5238:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1605;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1605;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen IX
state_5239:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5240;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5241; }
	/*if (check_expr())*/ goto state_5241;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen IX RParen
state_5240:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1606;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1606;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen IX expr
state_5241:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5242;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen IX expr RParen
state_5242:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1607;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1607;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen IY
state_5243:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5244;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5245; }
	/*if (check_expr())*/ goto state_5245;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen IY RParen
state_5244:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1608;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1608;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen IY expr
state_5245:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD RRC LParen IY expr RParen
state_5246:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1609;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1609;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC
state_5247:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5248;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5265;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A
state_5248:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5249;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma
state_5249:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5250;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen
state_5250:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5251;
	case Keyword::IX: m_lexer.next(); goto state_5257;
	case Keyword::IY: m_lexer.next(); goto state_5261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen HL
state_5251:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5252;
	case TType::Plus: m_lexer.next(); goto state_5254;
	case TType::RParen: m_lexer.next(); goto state_5256;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen HL Minus
state_5252:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5253;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen HL Minus RParen
state_5253:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1610;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1610;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen HL Plus
state_5254:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5255;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen HL Plus RParen
state_5255:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1611;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen HL RParen
state_5256:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1612;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen IX
state_5257:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5258;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5259; }
	/*if (check_expr())*/ goto state_5259;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen IX RParen
state_5258:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1613;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1613;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen IX expr
state_5259:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5260;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen IX expr RParen
state_5260:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1614;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen IY
state_5261:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5262;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5263; }
	/*if (check_expr())*/ goto state_5263;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen IY RParen
state_5262:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1615;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1615;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen IY expr
state_5263:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5264;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC A Comma LParen IY expr RParen
state_5264:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1616;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1616;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen
state_5265:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5266;
	case Keyword::IX: m_lexer.next(); goto state_5272;
	case Keyword::IY: m_lexer.next(); goto state_5276;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen HL
state_5266:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5267;
	case TType::Plus: m_lexer.next(); goto state_5269;
	case TType::RParen: m_lexer.next(); goto state_5271;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen HL Minus
state_5267:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5268;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen HL Minus RParen
state_5268:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1610;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1610;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen HL Plus
state_5269:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen HL Plus RParen
state_5270:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1611;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen HL RParen
state_5271:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1612;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen IX
state_5272:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5273;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5274; }
	/*if (check_expr())*/ goto state_5274;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen IX RParen
state_5273:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1613;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1613;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen IX expr
state_5274:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen IX expr RParen
state_5275:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1614;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen IY
state_5276:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5277;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5278; }
	/*if (check_expr())*/ goto state_5278;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen IY RParen
state_5277:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1615;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1615;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen IY expr
state_5278:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5279;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SBC LParen IY expr RParen
state_5279:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1616;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1616;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA
state_5280:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen
state_5281:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5282;
	case Keyword::IX: m_lexer.next(); goto state_5284;
	case Keyword::IY: m_lexer.next(); goto state_5288;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen HL
state_5282:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5283;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen HL RParen
state_5283:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1617;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen IX
state_5284:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5285;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5286; }
	/*if (check_expr())*/ goto state_5286;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen IX RParen
state_5285:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1618;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen IX expr
state_5286:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5287;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen IX expr RParen
state_5287:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1619;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1619;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen IY
state_5288:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5289;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5290; }
	/*if (check_expr())*/ goto state_5290;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen IY RParen
state_5289:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1620;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1620;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen IY expr
state_5290:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5291;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SLA LParen IY expr RParen
state_5291:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1621;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1621;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA
state_5292:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5293;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen
state_5293:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5294;
	case Keyword::IX: m_lexer.next(); goto state_5296;
	case Keyword::IY: m_lexer.next(); goto state_5300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen HL
state_5294:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5295;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen HL RParen
state_5295:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1622;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1622;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen IX
state_5296:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5297;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5298; }
	/*if (check_expr())*/ goto state_5298;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen IX RParen
state_5297:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1623;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen IX expr
state_5298:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen IX expr RParen
state_5299:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1624;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1624;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen IY
state_5300:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5301;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5302; }
	/*if (check_expr())*/ goto state_5302;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen IY RParen
state_5301:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1625;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1625;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen IY expr
state_5302:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRA LParen IY expr RParen
state_5303:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1626;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1626;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL
state_5304:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5305;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen
state_5305:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5306;
	case Keyword::IX: m_lexer.next(); goto state_5308;
	case Keyword::IY: m_lexer.next(); goto state_5312;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen HL
state_5306:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen HL RParen
state_5307:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1627;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1627;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen IX
state_5308:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5309;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5310; }
	/*if (check_expr())*/ goto state_5310;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen IX RParen
state_5309:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1628;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1628;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen IX expr
state_5310:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen IX expr RParen
state_5311:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1629;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1629;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen IY
state_5312:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5313;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5314; }
	/*if (check_expr())*/ goto state_5314;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen IY RParen
state_5313:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1630;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1630;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen IY expr
state_5314:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SRL LParen IY expr RParen
state_5315:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1631;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1631;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB
state_5316:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5317;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5334;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A
state_5317:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5318;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma
state_5318:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5319;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen
state_5319:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5320;
	case Keyword::IX: m_lexer.next(); goto state_5326;
	case Keyword::IY: m_lexer.next(); goto state_5330;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen HL
state_5320:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5321;
	case TType::Plus: m_lexer.next(); goto state_5323;
	case TType::RParen: m_lexer.next(); goto state_5325;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen HL Minus
state_5321:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5322;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen HL Minus RParen
state_5322:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1632;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen HL Plus
state_5323:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5324;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen HL Plus RParen
state_5324:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1633;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen HL RParen
state_5325:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1634;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1634;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen IX
state_5326:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5327;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5328; }
	/*if (check_expr())*/ goto state_5328;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen IX RParen
state_5327:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1635;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1635;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen IX expr
state_5328:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5329;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen IX expr RParen
state_5329:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1636;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen IY
state_5330:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5331;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5332; }
	/*if (check_expr())*/ goto state_5332;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen IY RParen
state_5331:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1637;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen IY expr
state_5332:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5333;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB A Comma LParen IY expr RParen
state_5333:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1638;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1638;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen
state_5334:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5335;
	case Keyword::IX: m_lexer.next(); goto state_5341;
	case Keyword::IY: m_lexer.next(); goto state_5345;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen HL
state_5335:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5336;
	case TType::Plus: m_lexer.next(); goto state_5338;
	case TType::RParen: m_lexer.next(); goto state_5340;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen HL Minus
state_5336:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5337;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen HL Minus RParen
state_5337:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1632;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen HL Plus
state_5338:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5339;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen HL Plus RParen
state_5339:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1633;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen HL RParen
state_5340:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1634;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1634;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen IX
state_5341:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5342;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5343; }
	/*if (check_expr())*/ goto state_5343;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen IX RParen
state_5342:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1635;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1635;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen IX expr
state_5343:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5344;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen IX expr RParen
state_5344:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1636;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen IY
state_5345:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5346;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5347; }
	/*if (check_expr())*/ goto state_5347;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen IY RParen
state_5346:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1637;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen IY expr
state_5347:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD SUB LParen IY expr RParen
state_5348:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1638;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1638;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR
state_5349:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5350;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5367;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A
state_5350:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma
state_5351:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5352;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen
state_5352:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5353;
	case Keyword::IX: m_lexer.next(); goto state_5359;
	case Keyword::IY: m_lexer.next(); goto state_5363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen HL
state_5353:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5354;
	case TType::Plus: m_lexer.next(); goto state_5356;
	case TType::RParen: m_lexer.next(); goto state_5358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen HL Minus
state_5354:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5355;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen HL Minus RParen
state_5355:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1639;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen HL Plus
state_5356:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen HL Plus RParen
state_5357:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1640;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen HL RParen
state_5358:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1641;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1641;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen IX
state_5359:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5360;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5361; }
	/*if (check_expr())*/ goto state_5361;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen IX RParen
state_5360:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1642;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1642;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen IX expr
state_5361:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5362;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen IX expr RParen
state_5362:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1643;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1643;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen IY
state_5363:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5364;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5365; }
	/*if (check_expr())*/ goto state_5365;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen IY RParen
state_5364:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1644;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen IY expr
state_5365:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5366;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR A Comma LParen IY expr RParen
state_5366:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1645;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1645;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen
state_5367:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5368;
	case Keyword::IX: m_lexer.next(); goto state_5374;
	case Keyword::IY: m_lexer.next(); goto state_5378;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen HL
state_5368:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5369;
	case TType::Plus: m_lexer.next(); goto state_5371;
	case TType::RParen: m_lexer.next(); goto state_5373;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen HL Minus
state_5369:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5370;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen HL Minus RParen
state_5370:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1639;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen HL Plus
state_5371:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5372;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen HL Plus RParen
state_5372:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1640;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen HL RParen
state_5373:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1641;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1641;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen IX
state_5374:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5375;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5376; }
	/*if (check_expr())*/ goto state_5376;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen IX RParen
state_5375:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1642;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1642;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen IX expr
state_5376:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5377;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen IX expr RParen
state_5377:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1643;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1643;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen IY
state_5378:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5379;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5380; }
	/*if (check_expr())*/ goto state_5380;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen IY RParen
state_5379:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1644;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen IY expr
state_5380:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5381;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI ALTD XOR LParen IY expr RParen
state_5381:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1645;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1645;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND
state_5382:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5383;
	case Keyword::A1: m_lexer.next(); goto state_5400;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A
state_5383:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5384;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma
state_5384:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5385;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen
state_5385:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5386;
	case Keyword::IX: m_lexer.next(); goto state_5392;
	case Keyword::IY: m_lexer.next(); goto state_5396;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen HL
state_5386:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5387;
	case TType::Plus: m_lexer.next(); goto state_5389;
	case TType::RParen: m_lexer.next(); goto state_5391;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen HL Minus
state_5387:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5388;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen HL Minus RParen
state_5388:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1646;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen HL Plus
state_5389:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5390;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen HL Plus RParen
state_5390:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1647;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen HL RParen
state_5391:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1648;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1648;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen IX
state_5392:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5393;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5394; }
	/*if (check_expr())*/ goto state_5394;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen IX RParen
state_5393:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1649;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen IX expr
state_5394:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5395;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen IX expr RParen
state_5395:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1650;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen IY
state_5396:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5397;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5398; }
	/*if (check_expr())*/ goto state_5398;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen IY RParen
state_5397:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1651;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1651;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen IY expr
state_5398:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5399;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A Comma LParen IY expr RParen
state_5399:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1652;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1652;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1
state_5400:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5401;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma
state_5401:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5402;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen
state_5402:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5403;
	case Keyword::IX: m_lexer.next(); goto state_5409;
	case Keyword::IY: m_lexer.next(); goto state_5413;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen HL
state_5403:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5404;
	case TType::Plus: m_lexer.next(); goto state_5406;
	case TType::RParen: m_lexer.next(); goto state_5408;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen HL Minus
state_5404:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5405;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen HL Minus RParen
state_5405:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1485;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1485;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen HL Plus
state_5406:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5407;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen HL Plus RParen
state_5407:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1486;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen HL RParen
state_5408:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1487;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1487;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen IX
state_5409:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5410;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5411; }
	/*if (check_expr())*/ goto state_5411;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen IX RParen
state_5410:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1488;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen IX expr
state_5411:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5412;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen IX expr RParen
state_5412:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1489;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1489;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen IY
state_5413:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5414;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5415; }
	/*if (check_expr())*/ goto state_5415;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen IY RParen
state_5414:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1490;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1490;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen IY expr
state_5415:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5416;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND A1 Comma LParen IY expr RParen
state_5416:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1491;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1491;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen
state_5417:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5418;
	case Keyword::IX: m_lexer.next(); goto state_5424;
	case Keyword::IY: m_lexer.next(); goto state_5428;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen HL
state_5418:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5419;
	case TType::Plus: m_lexer.next(); goto state_5421;
	case TType::RParen: m_lexer.next(); goto state_5423;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen HL Minus
state_5419:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5420;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen HL Minus RParen
state_5420:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1646;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen HL Plus
state_5421:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5422;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen HL Plus RParen
state_5422:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1647;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen HL RParen
state_5423:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1648;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1648;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen IX
state_5424:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5425;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5426; }
	/*if (check_expr())*/ goto state_5426;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen IX RParen
state_5425:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1649;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen IX expr
state_5426:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5427;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen IX expr RParen
state_5427:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1650;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen IY
state_5428:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5429;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5430; }
	/*if (check_expr())*/ goto state_5430;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen IY RParen
state_5429:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1651;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1651;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen IY expr
state_5430:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5431;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI AND LParen IY expr RParen
state_5431:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1652;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1652;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT
state_5432:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5433; }
	/*if (check_const_expr())*/ goto state_5433;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr
state_5433:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5434;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma
state_5434:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5435;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen
state_5435:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5436;
	case Keyword::IX: m_lexer.next(); goto state_5438;
	case Keyword::IY: m_lexer.next(); goto state_5442;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen HL
state_5436:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5437;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen HL RParen
state_5437:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1653;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1653;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen IX
state_5438:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5439;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5440; }
	/*if (check_expr())*/ goto state_5440;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen IX RParen
state_5439:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1654;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1654;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen IX expr
state_5440:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5441;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen IX expr RParen
state_5441:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1655;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1655;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen IY
state_5442:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5443;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5444; }
	/*if (check_expr())*/ goto state_5444;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen IY RParen
state_5443:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1656;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen IY expr
state_5444:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5445;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI BIT const_expr Comma LParen IY expr RParen
state_5445:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1657;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1657;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP
state_5446:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5447;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A
state_5447:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5448;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma
state_5448:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5449;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen
state_5449:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5450;
	case Keyword::IX: m_lexer.next(); goto state_5456;
	case Keyword::IY: m_lexer.next(); goto state_5460;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen HL
state_5450:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5451;
	case TType::Plus: m_lexer.next(); goto state_5453;
	case TType::RParen: m_lexer.next(); goto state_5455;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen HL Minus
state_5451:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5452;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen HL Minus RParen
state_5452:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1658;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen HL Plus
state_5453:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen HL Plus RParen
state_5454:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1659;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen HL RParen
state_5455:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen IX
state_5456:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5457;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5458; }
	/*if (check_expr())*/ goto state_5458;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen IX RParen
state_5457:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen IX expr
state_5458:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5459;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen IX expr RParen
state_5459:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1662;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen IY
state_5460:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5461;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5462; }
	/*if (check_expr())*/ goto state_5462;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen IY RParen
state_5461:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1663;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1663;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen IY expr
state_5462:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP A Comma LParen IY expr RParen
state_5463:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1664;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen
state_5464:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5465;
	case Keyword::IX: m_lexer.next(); goto state_5471;
	case Keyword::IY: m_lexer.next(); goto state_5475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen HL
state_5465:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5466;
	case TType::Plus: m_lexer.next(); goto state_5468;
	case TType::RParen: m_lexer.next(); goto state_5470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen HL Minus
state_5466:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen HL Minus RParen
state_5467:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1658;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen HL Plus
state_5468:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen HL Plus RParen
state_5469:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1659;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen HL RParen
state_5470:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen IX
state_5471:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5472;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5473; }
	/*if (check_expr())*/ goto state_5473;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen IX RParen
state_5472:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen IX expr
state_5473:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5474;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen IX expr RParen
state_5474:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1662;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen IY
state_5475:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5476;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5477; }
	/*if (check_expr())*/ goto state_5477;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen IY RParen
state_5476:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1663;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1663;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen IY expr
state_5477:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CMP LParen IY expr RParen
state_5478:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1664;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP
state_5479:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5480;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5497;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A
state_5480:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5481;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma
state_5481:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen
state_5482:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5483;
	case Keyword::IX: m_lexer.next(); goto state_5489;
	case Keyword::IY: m_lexer.next(); goto state_5493;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen HL
state_5483:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5484;
	case TType::Plus: m_lexer.next(); goto state_5486;
	case TType::RParen: m_lexer.next(); goto state_5488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen HL Minus
state_5484:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5485;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen HL Minus RParen
state_5485:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1658;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen HL Plus
state_5486:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5487;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen HL Plus RParen
state_5487:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1659;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen HL RParen
state_5488:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen IX
state_5489:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5490;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5491; }
	/*if (check_expr())*/ goto state_5491;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen IX RParen
state_5490:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen IX expr
state_5491:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5492;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen IX expr RParen
state_5492:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1662;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen IY
state_5493:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5494;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5495; }
	/*if (check_expr())*/ goto state_5495;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen IY RParen
state_5494:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1663;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1663;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen IY expr
state_5495:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5496;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP A Comma LParen IY expr RParen
state_5496:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1664;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen
state_5497:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5498;
	case Keyword::IX: m_lexer.next(); goto state_5504;
	case Keyword::IY: m_lexer.next(); goto state_5508;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen HL
state_5498:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5499;
	case TType::Plus: m_lexer.next(); goto state_5501;
	case TType::RParen: m_lexer.next(); goto state_5503;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen HL Minus
state_5499:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen HL Minus RParen
state_5500:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1658;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen HL Plus
state_5501:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5502;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen HL Plus RParen
state_5502:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1659;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen HL RParen
state_5503:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen IX
state_5504:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5505;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5506; }
	/*if (check_expr())*/ goto state_5506;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen IX RParen
state_5505:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen IX expr
state_5506:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5507;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen IX expr RParen
state_5507:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1662;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen IY
state_5508:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5509;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5510; }
	/*if (check_expr())*/ goto state_5510;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen IY RParen
state_5509:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1663;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1663;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen IY expr
state_5510:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5511;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI CP LParen IY expr RParen
state_5511:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1664;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC
state_5512:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5513;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen
state_5513:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5514;
	case Keyword::IX: m_lexer.next(); goto state_5520;
	case Keyword::IY: m_lexer.next(); goto state_5524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen HL
state_5514:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5515;
	case TType::Plus: m_lexer.next(); goto state_5517;
	case TType::RParen: m_lexer.next(); goto state_5519;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen HL Minus
state_5515:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5516;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen HL Minus RParen
state_5516:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1665;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1665;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen HL Plus
state_5517:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5518;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen HL Plus RParen
state_5518:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1666;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1666;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen HL RParen
state_5519:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1667;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1667;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen IX
state_5520:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5521;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5522; }
	/*if (check_expr())*/ goto state_5522;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen IX RParen
state_5521:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1668;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1668;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen IX expr
state_5522:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen IX expr RParen
state_5523:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1669;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1669;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen IY
state_5524:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5525;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5526; }
	/*if (check_expr())*/ goto state_5526;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen IY RParen
state_5525:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1670;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1670;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen IY expr
state_5526:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5527;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI DEC LParen IY expr RParen
state_5527:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1671;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1671;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC
state_5528:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5529;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen
state_5529:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5530;
	case Keyword::IX: m_lexer.next(); goto state_5536;
	case Keyword::IY: m_lexer.next(); goto state_5540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen HL
state_5530:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5531;
	case TType::Plus: m_lexer.next(); goto state_5533;
	case TType::RParen: m_lexer.next(); goto state_5535;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen HL Minus
state_5531:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5532;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen HL Minus RParen
state_5532:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1672;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1672;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen HL Plus
state_5533:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen HL Plus RParen
state_5534:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1673;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen HL RParen
state_5535:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1674;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1674;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen IX
state_5536:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5537;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5538; }
	/*if (check_expr())*/ goto state_5538;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen IX RParen
state_5537:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1675;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1675;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen IX expr
state_5538:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5539;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen IX expr RParen
state_5539:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1676;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1676;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen IY
state_5540:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5541;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5542; }
	/*if (check_expr())*/ goto state_5542;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen IY RParen
state_5541:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1677;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1677;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen IY expr
state_5542:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI INC LParen IY expr RParen
state_5543:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1678;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD
state_5544:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5545;
	case Keyword::A1: m_lexer.next(); goto state_5579;
	case Keyword::B: m_lexer.next(); goto state_5613;
	case Keyword::B1: m_lexer.next(); goto state_5634;
	case Keyword::BC: m_lexer.next(); goto state_5655;
	case Keyword::BC1: m_lexer.next(); goto state_5658;
	case Keyword::C: m_lexer.next(); goto state_5661;
	case Keyword::C1: m_lexer.next(); goto state_5682;
	case Keyword::D: m_lexer.next(); goto state_5703;
	case Keyword::D1: m_lexer.next(); goto state_5724;
	case Keyword::DE: m_lexer.next(); goto state_5745;
	case Keyword::DE1: m_lexer.next(); goto state_5748;
	case Keyword::E: m_lexer.next(); goto state_5751;
	case Keyword::E1: m_lexer.next(); goto state_5772;
	case Keyword::H: m_lexer.next(); goto state_5793;
	case Keyword::H1: m_lexer.next(); goto state_5814;
	case Keyword::HL: m_lexer.next(); goto state_5835;
	case Keyword::HL1: m_lexer.next(); goto state_5851;
	case Keyword::IX: m_lexer.next(); goto state_5867;
	case Keyword::IY: m_lexer.next(); goto state_5870;
	case Keyword::L: m_lexer.next(); goto state_5873;
	case Keyword::L1: m_lexer.next(); goto state_5894;
	case Keyword::SP: m_lexer.next(); goto state_5915;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5918;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6049; }
	/*if (check_expr())*/ goto state_6049;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A
state_5545:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5546;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma
state_5546:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5547;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5578; }
	/*if (check_expr())*/ goto state_5578;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen
state_5547:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_5548;
	case Keyword::DE: m_lexer.next(); goto state_5554;
	case Keyword::HL: m_lexer.next(); goto state_5560;
	case Keyword::HLD: m_lexer.next(); goto state_5566;
	case Keyword::HLI: m_lexer.next(); goto state_5568;
	case Keyword::IX: m_lexer.next(); goto state_5570;
	case Keyword::IY: m_lexer.next(); goto state_5574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen BC
state_5548:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5549;
	case TType::Plus: m_lexer.next(); goto state_5551;
	case TType::RParen: m_lexer.next(); goto state_5553;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen BC Minus
state_5549:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5550;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen BC Minus RParen
state_5550:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1679;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen BC Plus
state_5551:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen BC Plus RParen
state_5552:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1680;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1680;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen BC RParen
state_5553:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1681;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1681;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen DE
state_5554:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5555;
	case TType::Plus: m_lexer.next(); goto state_5557;
	case TType::RParen: m_lexer.next(); goto state_5559;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen DE Minus
state_5555:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen DE Minus RParen
state_5556:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1682;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen DE Plus
state_5557:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5558;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen DE Plus RParen
state_5558:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1683;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1683;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen DE RParen
state_5559:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1684;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1684;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HL
state_5560:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5561;
	case TType::Plus: m_lexer.next(); goto state_5563;
	case TType::RParen: m_lexer.next(); goto state_5565;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HL Minus
state_5561:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HL Minus RParen
state_5562:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1685;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HL Plus
state_5563:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5564;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HL Plus RParen
state_5564:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1686;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1686;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HL RParen
state_5565:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1687;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1687;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HLD
state_5566:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HLD RParen
state_5567:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1685;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HLI
state_5568:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5569;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen HLI RParen
state_5569:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1686;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1686;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen IX
state_5570:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5571;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5572; }
	/*if (check_expr())*/ goto state_5572;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen IX RParen
state_5571:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1688;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1688;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen IX expr
state_5572:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5573;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen IX expr RParen
state_5573:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1689;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1689;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen IY
state_5574:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5575;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5576; }
	/*if (check_expr())*/ goto state_5576;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen IY RParen
state_5575:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1690;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1690;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen IY expr
state_5576:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma LParen IY expr RParen
state_5577:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1691;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1691;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A Comma expr
state_5578:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1692;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1692;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1
state_5579:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma
state_5580:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5581;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5612; }
	/*if (check_expr())*/ goto state_5612;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen
state_5581:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_5582;
	case Keyword::DE: m_lexer.next(); goto state_5588;
	case Keyword::HL: m_lexer.next(); goto state_5594;
	case Keyword::HLD: m_lexer.next(); goto state_5600;
	case Keyword::HLI: m_lexer.next(); goto state_5602;
	case Keyword::IX: m_lexer.next(); goto state_5604;
	case Keyword::IY: m_lexer.next(); goto state_5608;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen BC
state_5582:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5583;
	case TType::Plus: m_lexer.next(); goto state_5585;
	case TType::RParen: m_lexer.next(); goto state_5587;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen BC Minus
state_5583:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen BC Minus RParen
state_5584:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1518;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1518;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen BC Plus
state_5585:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen BC Plus RParen
state_5586:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1519;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1519;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen BC RParen
state_5587:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1520;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1520;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen DE
state_5588:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5589;
	case TType::Plus: m_lexer.next(); goto state_5591;
	case TType::RParen: m_lexer.next(); goto state_5593;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen DE Minus
state_5589:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5590;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen DE Minus RParen
state_5590:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1521;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1521;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen DE Plus
state_5591:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5592;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen DE Plus RParen
state_5592:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1522;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1522;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen DE RParen
state_5593:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1523;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HL
state_5594:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5595;
	case TType::Plus: m_lexer.next(); goto state_5597;
	case TType::RParen: m_lexer.next(); goto state_5599;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HL Minus
state_5595:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5596;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HL Minus RParen
state_5596:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1524;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HL Plus
state_5597:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5598;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HL Plus RParen
state_5598:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1525;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HL RParen
state_5599:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1526;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1526;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HLD
state_5600:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5601;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HLD RParen
state_5601:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1524;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HLI
state_5602:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5603;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen HLI RParen
state_5603:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1525;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen IX
state_5604:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5605;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5606; }
	/*if (check_expr())*/ goto state_5606;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen IX RParen
state_5605:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1527;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1527;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen IX expr
state_5606:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5607;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen IX expr RParen
state_5607:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1528;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1528;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen IY
state_5608:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5609;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5610; }
	/*if (check_expr())*/ goto state_5610;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen IY RParen
state_5609:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1529;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1529;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen IY expr
state_5610:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma LParen IY expr RParen
state_5611:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1530;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1530;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD A1 Comma expr
state_5612:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1531;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B
state_5613:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma
state_5614:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5615;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen
state_5615:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5616;
	case Keyword::HLD: m_lexer.next(); goto state_5622;
	case Keyword::HLI: m_lexer.next(); goto state_5624;
	case Keyword::IX: m_lexer.next(); goto state_5626;
	case Keyword::IY: m_lexer.next(); goto state_5630;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HL
state_5616:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5617;
	case TType::Plus: m_lexer.next(); goto state_5619;
	case TType::RParen: m_lexer.next(); goto state_5621;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HL Minus
state_5617:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HL Minus RParen
state_5618:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1693;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1693;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HL Plus
state_5619:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5620;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HL Plus RParen
state_5620:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1694;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HL RParen
state_5621:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1695;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1695;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HLD
state_5622:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HLD RParen
state_5623:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1693;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1693;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HLI
state_5624:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5625;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen HLI RParen
state_5625:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1694;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen IX
state_5626:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5627;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5628; }
	/*if (check_expr())*/ goto state_5628;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen IX RParen
state_5627:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1696;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1696;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen IX expr
state_5628:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5629;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen IX expr RParen
state_5629:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1697;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1697;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen IY
state_5630:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5631;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5632; }
	/*if (check_expr())*/ goto state_5632;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen IY RParen
state_5631:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1698;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1698;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen IY expr
state_5632:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B Comma LParen IY expr RParen
state_5633:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1699;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1699;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1
state_5634:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5635;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma
state_5635:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen
state_5636:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5637;
	case Keyword::HLD: m_lexer.next(); goto state_5643;
	case Keyword::HLI: m_lexer.next(); goto state_5645;
	case Keyword::IX: m_lexer.next(); goto state_5647;
	case Keyword::IY: m_lexer.next(); goto state_5651;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HL
state_5637:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5638;
	case TType::Plus: m_lexer.next(); goto state_5640;
	case TType::RParen: m_lexer.next(); goto state_5642;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HL Minus
state_5638:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HL Minus RParen
state_5639:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1532;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1532;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HL Plus
state_5640:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5641;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HL Plus RParen
state_5641:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1533;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1533;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HL RParen
state_5642:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1534;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HLD
state_5643:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HLD RParen
state_5644:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1532;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1532;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HLI
state_5645:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen HLI RParen
state_5646:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1533;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1533;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen IX
state_5647:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5648;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5649; }
	/*if (check_expr())*/ goto state_5649;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen IX RParen
state_5648:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1535;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1535;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen IX expr
state_5649:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen IX expr RParen
state_5650:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1536;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1536;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen IY
state_5651:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5652;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5653; }
	/*if (check_expr())*/ goto state_5653;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen IY RParen
state_5652:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1537;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1537;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen IY expr
state_5653:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5654;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD B1 Comma LParen IY expr RParen
state_5654:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1538;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1538;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD BC
state_5655:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD BC Comma
state_5656:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5657; }
	/*if (check_expr())*/ goto state_5657;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD BC Comma expr
state_5657:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1700;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1700;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD BC1
state_5658:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD BC1 Comma
state_5659:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5660; }
	/*if (check_expr())*/ goto state_5660;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD BC1 Comma expr
state_5660:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1539;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1539;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C
state_5661:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma
state_5662:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5663;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen
state_5663:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5664;
	case Keyword::HLD: m_lexer.next(); goto state_5670;
	case Keyword::HLI: m_lexer.next(); goto state_5672;
	case Keyword::IX: m_lexer.next(); goto state_5674;
	case Keyword::IY: m_lexer.next(); goto state_5678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HL
state_5664:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5665;
	case TType::Plus: m_lexer.next(); goto state_5667;
	case TType::RParen: m_lexer.next(); goto state_5669;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HL Minus
state_5665:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5666;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HL Minus RParen
state_5666:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1701;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HL Plus
state_5667:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5668;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HL Plus RParen
state_5668:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1702;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HL RParen
state_5669:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1703;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1703;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HLD
state_5670:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5671;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HLD RParen
state_5671:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1701;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HLI
state_5672:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen HLI RParen
state_5673:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1702;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen IX
state_5674:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5675;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5676; }
	/*if (check_expr())*/ goto state_5676;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen IX RParen
state_5675:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1704;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1704;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen IX expr
state_5676:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5677;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen IX expr RParen
state_5677:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1705;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1705;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen IY
state_5678:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5679;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5680; }
	/*if (check_expr())*/ goto state_5680;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen IY RParen
state_5679:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1706;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1706;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen IY expr
state_5680:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5681;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C Comma LParen IY expr RParen
state_5681:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1707;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1707;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1
state_5682:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5683;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma
state_5683:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5684;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen
state_5684:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5685;
	case Keyword::HLD: m_lexer.next(); goto state_5691;
	case Keyword::HLI: m_lexer.next(); goto state_5693;
	case Keyword::IX: m_lexer.next(); goto state_5695;
	case Keyword::IY: m_lexer.next(); goto state_5699;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HL
state_5685:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5686;
	case TType::Plus: m_lexer.next(); goto state_5688;
	case TType::RParen: m_lexer.next(); goto state_5690;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HL Minus
state_5686:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5687;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HL Minus RParen
state_5687:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1540;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HL Plus
state_5688:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5689;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HL Plus RParen
state_5689:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1541;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HL RParen
state_5690:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1542;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1542;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HLD
state_5691:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5692;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HLD RParen
state_5692:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1540;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HLI
state_5693:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen HLI RParen
state_5694:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1541;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen IX
state_5695:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5696;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5697; }
	/*if (check_expr())*/ goto state_5697;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen IX RParen
state_5696:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1543;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen IX expr
state_5697:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5698;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen IX expr RParen
state_5698:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1544;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1544;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen IY
state_5699:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5700;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5701; }
	/*if (check_expr())*/ goto state_5701;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen IY RParen
state_5700:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1545;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1545;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen IY expr
state_5701:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD C1 Comma LParen IY expr RParen
state_5702:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1546;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1546;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D
state_5703:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5704;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma
state_5704:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5705;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen
state_5705:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5706;
	case Keyword::HLD: m_lexer.next(); goto state_5712;
	case Keyword::HLI: m_lexer.next(); goto state_5714;
	case Keyword::IX: m_lexer.next(); goto state_5716;
	case Keyword::IY: m_lexer.next(); goto state_5720;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HL
state_5706:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5707;
	case TType::Plus: m_lexer.next(); goto state_5709;
	case TType::RParen: m_lexer.next(); goto state_5711;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HL Minus
state_5707:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HL Minus RParen
state_5708:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1708;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HL Plus
state_5709:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5710;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HL Plus RParen
state_5710:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1709;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1709;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HL RParen
state_5711:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1710;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1710;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HLD
state_5712:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5713;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HLD RParen
state_5713:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1708;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HLI
state_5714:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5715;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen HLI RParen
state_5715:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1709;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1709;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen IX
state_5716:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5717;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5718; }
	/*if (check_expr())*/ goto state_5718;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen IX RParen
state_5717:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1711;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1711;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen IX expr
state_5718:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5719;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen IX expr RParen
state_5719:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1712;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1712;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen IY
state_5720:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5721;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5722; }
	/*if (check_expr())*/ goto state_5722;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen IY RParen
state_5721:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1713;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1713;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen IY expr
state_5722:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D Comma LParen IY expr RParen
state_5723:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1714;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1714;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1
state_5724:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5725;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma
state_5725:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5726;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen
state_5726:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5727;
	case Keyword::HLD: m_lexer.next(); goto state_5733;
	case Keyword::HLI: m_lexer.next(); goto state_5735;
	case Keyword::IX: m_lexer.next(); goto state_5737;
	case Keyword::IY: m_lexer.next(); goto state_5741;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HL
state_5727:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5728;
	case TType::Plus: m_lexer.next(); goto state_5730;
	case TType::RParen: m_lexer.next(); goto state_5732;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HL Minus
state_5728:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HL Minus RParen
state_5729:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1547;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1547;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HL Plus
state_5730:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5731;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HL Plus RParen
state_5731:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1548;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1548;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HL RParen
state_5732:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1549;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HLD
state_5733:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5734;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HLD RParen
state_5734:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1547;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1547;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HLI
state_5735:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5736;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen HLI RParen
state_5736:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1548;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1548;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen IX
state_5737:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5738;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5739; }
	/*if (check_expr())*/ goto state_5739;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen IX RParen
state_5738:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1550;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1550;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen IX expr
state_5739:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen IX expr RParen
state_5740:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1551;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1551;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen IY
state_5741:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5742;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5743; }
	/*if (check_expr())*/ goto state_5743;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen IY RParen
state_5742:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1552;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen IY expr
state_5743:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5744;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD D1 Comma LParen IY expr RParen
state_5744:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1553;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1553;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD DE
state_5745:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5746;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD DE Comma
state_5746:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5747; }
	/*if (check_expr())*/ goto state_5747;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD DE Comma expr
state_5747:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1715;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1715;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD DE1
state_5748:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5749;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD DE1 Comma
state_5749:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5750; }
	/*if (check_expr())*/ goto state_5750;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD DE1 Comma expr
state_5750:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1554;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1554;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E
state_5751:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5752;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma
state_5752:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen
state_5753:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5754;
	case Keyword::HLD: m_lexer.next(); goto state_5760;
	case Keyword::HLI: m_lexer.next(); goto state_5762;
	case Keyword::IX: m_lexer.next(); goto state_5764;
	case Keyword::IY: m_lexer.next(); goto state_5768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HL
state_5754:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5755;
	case TType::Plus: m_lexer.next(); goto state_5757;
	case TType::RParen: m_lexer.next(); goto state_5759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HL Minus
state_5755:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HL Minus RParen
state_5756:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1716;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1716;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HL Plus
state_5757:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HL Plus RParen
state_5758:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1717;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1717;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HL RParen
state_5759:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1718;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1718;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HLD
state_5760:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HLD RParen
state_5761:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1716;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1716;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HLI
state_5762:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen HLI RParen
state_5763:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1717;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1717;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen IX
state_5764:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5765;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5766; }
	/*if (check_expr())*/ goto state_5766;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen IX RParen
state_5765:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1719;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1719;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen IX expr
state_5766:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen IX expr RParen
state_5767:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1720;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1720;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen IY
state_5768:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5769;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5770; }
	/*if (check_expr())*/ goto state_5770;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen IY RParen
state_5769:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1721;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1721;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen IY expr
state_5770:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E Comma LParen IY expr RParen
state_5771:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1722;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1722;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1
state_5772:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma
state_5773:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen
state_5774:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5775;
	case Keyword::HLD: m_lexer.next(); goto state_5781;
	case Keyword::HLI: m_lexer.next(); goto state_5783;
	case Keyword::IX: m_lexer.next(); goto state_5785;
	case Keyword::IY: m_lexer.next(); goto state_5789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HL
state_5775:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5776;
	case TType::Plus: m_lexer.next(); goto state_5778;
	case TType::RParen: m_lexer.next(); goto state_5780;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HL Minus
state_5776:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HL Minus RParen
state_5777:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1555;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1555;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HL Plus
state_5778:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HL Plus RParen
state_5779:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1556;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HL RParen
state_5780:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1557;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HLD
state_5781:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HLD RParen
state_5782:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1555;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1555;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HLI
state_5783:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5784;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen HLI RParen
state_5784:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1556;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen IX
state_5785:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5786;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5787; }
	/*if (check_expr())*/ goto state_5787;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen IX RParen
state_5786:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1558;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1558;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen IX expr
state_5787:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5788;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen IX expr RParen
state_5788:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1559;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1559;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen IY
state_5789:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5790;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5791; }
	/*if (check_expr())*/ goto state_5791;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen IY RParen
state_5790:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1560;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1560;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen IY expr
state_5791:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5792;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD E1 Comma LParen IY expr RParen
state_5792:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1561;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1561;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H
state_5793:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5794;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma
state_5794:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5795;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen
state_5795:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5796;
	case Keyword::HLD: m_lexer.next(); goto state_5802;
	case Keyword::HLI: m_lexer.next(); goto state_5804;
	case Keyword::IX: m_lexer.next(); goto state_5806;
	case Keyword::IY: m_lexer.next(); goto state_5810;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HL
state_5796:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5797;
	case TType::Plus: m_lexer.next(); goto state_5799;
	case TType::RParen: m_lexer.next(); goto state_5801;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HL Minus
state_5797:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5798;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HL Minus RParen
state_5798:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1723;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HL Plus
state_5799:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5800;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HL Plus RParen
state_5800:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1724;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HL RParen
state_5801:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1725;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1725;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HLD
state_5802:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HLD RParen
state_5803:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1723;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HLI
state_5804:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5805;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen HLI RParen
state_5805:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1724;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen IX
state_5806:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5807;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5808; }
	/*if (check_expr())*/ goto state_5808;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen IX RParen
state_5807:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1726;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1726;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen IX expr
state_5808:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5809;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen IX expr RParen
state_5809:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1727;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1727;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen IY
state_5810:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5811;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5812; }
	/*if (check_expr())*/ goto state_5812;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen IY RParen
state_5811:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1728;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1728;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen IY expr
state_5812:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5813;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H Comma LParen IY expr RParen
state_5813:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1729;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1
state_5814:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma
state_5815:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5816;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen
state_5816:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5817;
	case Keyword::HLD: m_lexer.next(); goto state_5823;
	case Keyword::HLI: m_lexer.next(); goto state_5825;
	case Keyword::IX: m_lexer.next(); goto state_5827;
	case Keyword::IY: m_lexer.next(); goto state_5831;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HL
state_5817:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5818;
	case TType::Plus: m_lexer.next(); goto state_5820;
	case TType::RParen: m_lexer.next(); goto state_5822;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HL Minus
state_5818:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5819;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HL Minus RParen
state_5819:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1562;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HL Plus
state_5820:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5821;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HL Plus RParen
state_5821:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1563;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HL RParen
state_5822:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1564;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1564;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HLD
state_5823:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5824;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HLD RParen
state_5824:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1562;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HLI
state_5825:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen HLI RParen
state_5826:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1563;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen IX
state_5827:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5828;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5829; }
	/*if (check_expr())*/ goto state_5829;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen IX RParen
state_5828:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1565;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1565;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen IX expr
state_5829:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5830;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen IX expr RParen
state_5830:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1566;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1566;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen IY
state_5831:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5832;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5833; }
	/*if (check_expr())*/ goto state_5833;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen IY RParen
state_5832:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1567;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen IY expr
state_5833:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5834;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD H1 Comma LParen IY expr RParen
state_5834:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1568;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1568;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL
state_5835:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5836;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma
state_5836:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5837;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5850; }
	/*if (check_expr())*/ goto state_5850;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen
state_5837:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5838;
	case Keyword::IX: m_lexer.next(); goto state_5842;
	case Keyword::IY: m_lexer.next(); goto state_5846;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen HL
state_5838:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5839;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5840; }
	/*if (check_expr())*/ goto state_5840;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen HL RParen
state_5839:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1730;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1730;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen HL expr
state_5840:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen HL expr RParen
state_5841:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1731;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1731;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen IX
state_5842:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5843;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5844; }
	/*if (check_expr())*/ goto state_5844;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen IX RParen
state_5843:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1732;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1732;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen IX expr
state_5844:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5845;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen IX expr RParen
state_5845:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1733;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1733;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen IY
state_5846:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5847;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5848; }
	/*if (check_expr())*/ goto state_5848;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen IY RParen
state_5847:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1734;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1734;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen IY expr
state_5848:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5849;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma LParen IY expr RParen
state_5849:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1735;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1735;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL Comma expr
state_5850:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1736;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1736;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1
state_5851:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5852;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma
state_5852:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5853;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5866; }
	/*if (check_expr())*/ goto state_5866;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen
state_5853:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5854;
	case Keyword::IX: m_lexer.next(); goto state_5858;
	case Keyword::IY: m_lexer.next(); goto state_5862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen HL
state_5854:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5855;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5856; }
	/*if (check_expr())*/ goto state_5856;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen HL RParen
state_5855:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1569;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1569;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen HL expr
state_5856:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5857;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen HL expr RParen
state_5857:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1570;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1570;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen IX
state_5858:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5859;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5860; }
	/*if (check_expr())*/ goto state_5860;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen IX RParen
state_5859:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1571;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1571;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen IX expr
state_5860:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5861;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen IX expr RParen
state_5861:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1572;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1572;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen IY
state_5862:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5863;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5864; }
	/*if (check_expr())*/ goto state_5864;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen IY RParen
state_5863:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1573;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1573;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen IY expr
state_5864:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5865;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma LParen IY expr RParen
state_5865:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1574;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD HL1 Comma expr
state_5866:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1575;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1575;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD IX
state_5867:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5868;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD IX Comma
state_5868:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5869; }
	/*if (check_expr())*/ goto state_5869;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD IX Comma expr
state_5869:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1737;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1737;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD IY
state_5870:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5871;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD IY Comma
state_5871:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5872; }
	/*if (check_expr())*/ goto state_5872;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD IY Comma expr
state_5872:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1738;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1738;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L
state_5873:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5874;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma
state_5874:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5875;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen
state_5875:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5876;
	case Keyword::HLD: m_lexer.next(); goto state_5882;
	case Keyword::HLI: m_lexer.next(); goto state_5884;
	case Keyword::IX: m_lexer.next(); goto state_5886;
	case Keyword::IY: m_lexer.next(); goto state_5890;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HL
state_5876:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5877;
	case TType::Plus: m_lexer.next(); goto state_5879;
	case TType::RParen: m_lexer.next(); goto state_5881;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HL Minus
state_5877:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5878;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HL Minus RParen
state_5878:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1739;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HL Plus
state_5879:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5880;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HL Plus RParen
state_5880:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1740;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HL RParen
state_5881:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1741;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1741;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HLD
state_5882:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5883;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HLD RParen
state_5883:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1739;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HLI
state_5884:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5885;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen HLI RParen
state_5885:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1740;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen IX
state_5886:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5887;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5888; }
	/*if (check_expr())*/ goto state_5888;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen IX RParen
state_5887:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1742;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1742;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen IX expr
state_5888:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5889;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen IX expr RParen
state_5889:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1743;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1743;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen IY
state_5890:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5891;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5892; }
	/*if (check_expr())*/ goto state_5892;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen IY RParen
state_5891:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1744;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1744;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen IY expr
state_5892:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5893;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L Comma LParen IY expr RParen
state_5893:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1745;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1745;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1
state_5894:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma
state_5895:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_5896;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen
state_5896:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5897;
	case Keyword::HLD: m_lexer.next(); goto state_5903;
	case Keyword::HLI: m_lexer.next(); goto state_5905;
	case Keyword::IX: m_lexer.next(); goto state_5907;
	case Keyword::IY: m_lexer.next(); goto state_5911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HL
state_5897:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5898;
	case TType::Plus: m_lexer.next(); goto state_5900;
	case TType::RParen: m_lexer.next(); goto state_5902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HL Minus
state_5898:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HL Minus RParen
state_5899:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1576;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HL Plus
state_5900:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HL Plus RParen
state_5901:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1577;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HL RParen
state_5902:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1578;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HLD
state_5903:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HLD RParen
state_5904:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1576;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HLI
state_5905:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen HLI RParen
state_5906:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1577;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen IX
state_5907:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5908;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5909; }
	/*if (check_expr())*/ goto state_5909;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen IX RParen
state_5908:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1579;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1579;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen IX expr
state_5909:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen IX expr RParen
state_5910:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1580;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen IY
state_5911:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5912;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5913; }
	/*if (check_expr())*/ goto state_5913;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen IY RParen
state_5912:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1581;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1581;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen IY expr
state_5913:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD L1 Comma LParen IY expr RParen
state_5914:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1582;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD SP
state_5915:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD SP Comma
state_5916:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5917; }
	/*if (check_expr())*/ goto state_5917;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD SP Comma expr
state_5917:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1746;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1746;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen
state_5918:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_5919;
	case Keyword::DE: m_lexer.next(); goto state_5931;
	case Keyword::HL: m_lexer.next(); goto state_5943;
	case Keyword::HLD: m_lexer.next(); goto state_5981;
	case Keyword::HLI: m_lexer.next(); goto state_5991;
	case Keyword::IX: m_lexer.next(); goto state_6001;
	case Keyword::IY: m_lexer.next(); goto state_6025;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC
state_5919:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5920;
	case TType::Plus: m_lexer.next(); goto state_5924;
	case TType::RParen: m_lexer.next(); goto state_5928;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC Minus
state_5920:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5921;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC Minus RParen
state_5921:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5922;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC Minus RParen Comma
state_5922:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC Minus RParen Comma A
state_5923:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1747;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1747;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC Plus
state_5924:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC Plus RParen
state_5925:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC Plus RParen Comma
state_5926:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5927;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC Plus RParen Comma A
state_5927:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1748;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1748;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC RParen
state_5928:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5929;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC RParen Comma
state_5929:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen BC RParen Comma A
state_5930:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1749;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1749;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE
state_5931:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5932;
	case TType::Plus: m_lexer.next(); goto state_5936;
	case TType::RParen: m_lexer.next(); goto state_5940;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE Minus
state_5932:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE Minus RParen
state_5933:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE Minus RParen Comma
state_5934:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE Minus RParen Comma A
state_5935:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1750;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1750;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE Plus
state_5936:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5937;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE Plus RParen
state_5937:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5938;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE Plus RParen Comma
state_5938:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5939;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE Plus RParen Comma A
state_5939:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1751;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE RParen
state_5940:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5941;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE RParen Comma
state_5941:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5942;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen DE RParen Comma A
state_5942:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1752;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1752;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL
state_5943:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_5944;
	case TType::Plus: m_lexer.next(); goto state_5955;
	case TType::RParen: m_lexer.next(); goto state_5966;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5977; }
	/*if (check_expr())*/ goto state_5977;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus
state_5944:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5945;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen
state_5945:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5946;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen Comma
state_5946:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5947;
	case Keyword::B: m_lexer.next(); goto state_5948;
	case Keyword::C: m_lexer.next(); goto state_5949;
	case Keyword::D: m_lexer.next(); goto state_5950;
	case Keyword::E: m_lexer.next(); goto state_5951;
	case Keyword::H: m_lexer.next(); goto state_5952;
	case Keyword::L: m_lexer.next(); goto state_5953;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5954; }
	/*if (check_expr())*/ goto state_5954;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen Comma A
state_5947:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1753;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen Comma B
state_5948:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1754;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1754;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen Comma C
state_5949:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1755;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen Comma D
state_5950:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1756;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen Comma E
state_5951:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1757;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen Comma H
state_5952:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1758;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen Comma L
state_5953:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1759;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Minus RParen Comma expr
state_5954:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1760;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus
state_5955:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5956;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen
state_5956:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5957;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen Comma
state_5957:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5958;
	case Keyword::B: m_lexer.next(); goto state_5959;
	case Keyword::C: m_lexer.next(); goto state_5960;
	case Keyword::D: m_lexer.next(); goto state_5961;
	case Keyword::E: m_lexer.next(); goto state_5962;
	case Keyword::H: m_lexer.next(); goto state_5963;
	case Keyword::L: m_lexer.next(); goto state_5964;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5965; }
	/*if (check_expr())*/ goto state_5965;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen Comma A
state_5958:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1761;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen Comma B
state_5959:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1762;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen Comma C
state_5960:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1763;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen Comma D
state_5961:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1764;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen Comma E
state_5962:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1765;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen Comma H
state_5963:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1766;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1766;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen Comma L
state_5964:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1767;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL Plus RParen Comma expr
state_5965:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1768;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen
state_5966:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5967;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma
state_5967:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5968;
	case Keyword::B: m_lexer.next(); goto state_5969;
	case Keyword::C: m_lexer.next(); goto state_5970;
	case Keyword::D: m_lexer.next(); goto state_5971;
	case Keyword::E: m_lexer.next(); goto state_5972;
	case Keyword::H: m_lexer.next(); goto state_5973;
	case Keyword::HL: m_lexer.next(); goto state_5974;
	case Keyword::L: m_lexer.next(); goto state_5975;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_5976; }
	/*if (check_expr())*/ goto state_5976;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma A
state_5968:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1769;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1769;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma B
state_5969:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1770;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1770;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma C
state_5970:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1771;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma D
state_5971:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1772;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1772;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma E
state_5972:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1773;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma H
state_5973:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1774;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma HL
state_5974:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1775;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1775;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma L
state_5975:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1776;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1776;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL RParen Comma expr
state_5976:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1777;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL expr
state_5977:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL expr RParen
state_5978:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5979;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL expr RParen Comma
state_5979:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_5980;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HL expr RParen Comma HL
state_5980:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1778;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1778;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD
state_5981:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5982;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD RParen
state_5982:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5983;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD RParen Comma
state_5983:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5984;
	case Keyword::B: m_lexer.next(); goto state_5985;
	case Keyword::C: m_lexer.next(); goto state_5986;
	case Keyword::D: m_lexer.next(); goto state_5987;
	case Keyword::E: m_lexer.next(); goto state_5988;
	case Keyword::H: m_lexer.next(); goto state_5989;
	case Keyword::L: m_lexer.next(); goto state_5990;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD RParen Comma A
state_5984:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1753;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD RParen Comma B
state_5985:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1754;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1754;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD RParen Comma C
state_5986:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1755;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD RParen Comma D
state_5987:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1756;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD RParen Comma E
state_5988:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1757;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD RParen Comma H
state_5989:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1758;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLD RParen Comma L
state_5990:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1759;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI
state_5991:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_5992;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI RParen
state_5992:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_5993;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI RParen Comma
state_5993:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_5994;
	case Keyword::B: m_lexer.next(); goto state_5995;
	case Keyword::C: m_lexer.next(); goto state_5996;
	case Keyword::D: m_lexer.next(); goto state_5997;
	case Keyword::E: m_lexer.next(); goto state_5998;
	case Keyword::H: m_lexer.next(); goto state_5999;
	case Keyword::L: m_lexer.next(); goto state_6000;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI RParen Comma A
state_5994:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1761;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI RParen Comma B
state_5995:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1762;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI RParen Comma C
state_5996:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1763;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI RParen Comma D
state_5997:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1764;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI RParen Comma E
state_5998:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1765;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI RParen Comma H
state_5999:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1766;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1766;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen HLI RParen Comma L
state_6000:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1767;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX
state_6001:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6002;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6013; }
	/*if (check_expr())*/ goto state_6013;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen
state_6002:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6003;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma
state_6003:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6004;
	case Keyword::B: m_lexer.next(); goto state_6005;
	case Keyword::C: m_lexer.next(); goto state_6006;
	case Keyword::D: m_lexer.next(); goto state_6007;
	case Keyword::E: m_lexer.next(); goto state_6008;
	case Keyword::H: m_lexer.next(); goto state_6009;
	case Keyword::HL: m_lexer.next(); goto state_6010;
	case Keyword::L: m_lexer.next(); goto state_6011;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6012; }
	/*if (check_expr())*/ goto state_6012;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma A
state_6004:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1779;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma B
state_6005:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1780;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1780;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma C
state_6006:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1781;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma D
state_6007:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1782;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma E
state_6008:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1783;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1783;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma H
state_6009:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1784;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1784;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma HL
state_6010:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1785;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma L
state_6011:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1786;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1786;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX RParen Comma expr
state_6012:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1787;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1787;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr
state_6013:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6014;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen
state_6014:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6015;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma
state_6015:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6016;
	case Keyword::B: m_lexer.next(); goto state_6017;
	case Keyword::C: m_lexer.next(); goto state_6018;
	case Keyword::D: m_lexer.next(); goto state_6019;
	case Keyword::E: m_lexer.next(); goto state_6020;
	case Keyword::H: m_lexer.next(); goto state_6021;
	case Keyword::HL: m_lexer.next(); goto state_6022;
	case Keyword::L: m_lexer.next(); goto state_6023;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6024; }
	/*if (check_expr())*/ goto state_6024;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma A
state_6016:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1788;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1788;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma B
state_6017:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1789;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma C
state_6018:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1790;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1790;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma D
state_6019:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1791;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma E
state_6020:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1792;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1792;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma H
state_6021:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1793;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1793;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma HL
state_6022:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1794;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1794;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma L
state_6023:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1795;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1795;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IX expr RParen Comma expr
state_6024:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1796;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1796;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY
state_6025:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6026;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6037; }
	/*if (check_expr())*/ goto state_6037;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen
state_6026:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6027;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma
state_6027:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6028;
	case Keyword::B: m_lexer.next(); goto state_6029;
	case Keyword::C: m_lexer.next(); goto state_6030;
	case Keyword::D: m_lexer.next(); goto state_6031;
	case Keyword::E: m_lexer.next(); goto state_6032;
	case Keyword::H: m_lexer.next(); goto state_6033;
	case Keyword::HL: m_lexer.next(); goto state_6034;
	case Keyword::L: m_lexer.next(); goto state_6035;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6036; }
	/*if (check_expr())*/ goto state_6036;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma A
state_6028:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1797;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1797;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma B
state_6029:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1798;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1798;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma C
state_6030:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1799;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1799;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma D
state_6031:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1800;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1800;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma E
state_6032:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1801;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1801;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma H
state_6033:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1802;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1802;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma HL
state_6034:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1803;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma L
state_6035:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1804;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1804;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY RParen Comma expr
state_6036:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1805;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1805;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr
state_6037:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6038;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen
state_6038:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma
state_6039:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6040;
	case Keyword::B: m_lexer.next(); goto state_6041;
	case Keyword::C: m_lexer.next(); goto state_6042;
	case Keyword::D: m_lexer.next(); goto state_6043;
	case Keyword::E: m_lexer.next(); goto state_6044;
	case Keyword::H: m_lexer.next(); goto state_6045;
	case Keyword::HL: m_lexer.next(); goto state_6046;
	case Keyword::L: m_lexer.next(); goto state_6047;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6048; }
	/*if (check_expr())*/ goto state_6048;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma A
state_6040:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1806;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1806;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma B
state_6041:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1807;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1807;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma C
state_6042:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1808;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1808;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma D
state_6043:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1809;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1809;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma E
state_6044:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1810;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1810;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma H
state_6045:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1811;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1811;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma HL
state_6046:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1812;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1812;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma L
state_6047:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1813;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1813;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD LParen IY expr RParen Comma expr
state_6048:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1814;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1814;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD expr
state_6049:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6050;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD expr Comma
state_6050:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6051;
	case Keyword::BC: m_lexer.next(); goto state_6052;
	case Keyword::DE: m_lexer.next(); goto state_6053;
	case Keyword::HL: m_lexer.next(); goto state_6054;
	case Keyword::IX: m_lexer.next(); goto state_6055;
	case Keyword::IY: m_lexer.next(); goto state_6056;
	case Keyword::SP: m_lexer.next(); goto state_6057;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD expr Comma A
state_6051:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1815;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD expr Comma BC
state_6052:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1816;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1816;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD expr Comma DE
state_6053:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1817;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1817;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD expr Comma HL
state_6054:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1818;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1818;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD expr Comma IX
state_6055:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1819;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1819;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD expr Comma IY
state_6056:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1820;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1820;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LD expr Comma SP
state_6057:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1821;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1821;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD
state_6058:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6059;
	case Keyword::B: m_lexer.next(); goto state_6068;
	case Keyword::C: m_lexer.next(); goto state_6073;
	case Keyword::D: m_lexer.next(); goto state_6078;
	case Keyword::E: m_lexer.next(); goto state_6083;
	case Keyword::H: m_lexer.next(); goto state_6088;
	case Keyword::L: m_lexer.next(); goto state_6093;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1822;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1822;
	case TType::LParen: m_lexer.next(); goto state_6098;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD A
state_6059:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6060;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD A Comma
state_6060:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6061;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD A Comma LParen
state_6061:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6062;
	case Keyword::DE: m_lexer.next(); goto state_6064;
	case Keyword::HL: m_lexer.next(); goto state_6066;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD A Comma LParen BC
state_6062:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6063;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD A Comma LParen BC RParen
state_6063:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1679;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD A Comma LParen DE
state_6064:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6065;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD A Comma LParen DE RParen
state_6065:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1682;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD A Comma LParen HL
state_6066:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6067;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD A Comma LParen HL RParen
state_6067:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1685;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD B
state_6068:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6069;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD B Comma
state_6069:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6070;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD B Comma LParen
state_6070:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6071;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD B Comma LParen HL
state_6071:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6072;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD B Comma LParen HL RParen
state_6072:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1693;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1693;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD C
state_6073:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6074;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD C Comma
state_6074:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD C Comma LParen
state_6075:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6076;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD C Comma LParen HL
state_6076:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6077;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD C Comma LParen HL RParen
state_6077:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1701;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD D
state_6078:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6079;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD D Comma
state_6079:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6080;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD D Comma LParen
state_6080:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6081;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD D Comma LParen HL
state_6081:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6082;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD D Comma LParen HL RParen
state_6082:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1708;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD E
state_6083:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6084;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD E Comma
state_6084:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD E Comma LParen
state_6085:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6086;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD E Comma LParen HL
state_6086:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6087;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD E Comma LParen HL RParen
state_6087:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1716;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1716;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD H
state_6088:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6089;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD H Comma
state_6089:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6090;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD H Comma LParen
state_6090:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6091;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD H Comma LParen HL
state_6091:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6092;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD H Comma LParen HL RParen
state_6092:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1723;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD L
state_6093:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6094;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD L Comma
state_6094:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6095;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD L Comma LParen
state_6095:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6096;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD L Comma LParen HL
state_6096:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6097;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD L Comma LParen HL RParen
state_6097:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1739;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen
state_6098:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6099;
	case Keyword::DE: m_lexer.next(); goto state_6103;
	case Keyword::HL: m_lexer.next(); goto state_6107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen BC
state_6099:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen BC RParen
state_6100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6101;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen BC RParen Comma
state_6101:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6102;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen BC RParen Comma A
state_6102:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1747;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1747;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen DE
state_6103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen DE RParen
state_6104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6105;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen DE RParen Comma
state_6105:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6106;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen DE RParen Comma A
state_6106:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1750;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1750;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL
state_6107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen
state_6108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen Comma
state_6109:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6110;
	case Keyword::B: m_lexer.next(); goto state_6111;
	case Keyword::C: m_lexer.next(); goto state_6112;
	case Keyword::D: m_lexer.next(); goto state_6113;
	case Keyword::E: m_lexer.next(); goto state_6114;
	case Keyword::H: m_lexer.next(); goto state_6115;
	case Keyword::L: m_lexer.next(); goto state_6116;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6117; }
	/*if (check_expr())*/ goto state_6117;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen Comma A
state_6110:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1753;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen Comma B
state_6111:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1754;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1754;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen Comma C
state_6112:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1755;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen Comma D
state_6113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1756;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen Comma E
state_6114:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1757;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen Comma H
state_6115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1758;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen Comma L
state_6116:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1759;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDD LParen HL RParen Comma expr
state_6117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1760;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDDR
state_6118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1823;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDDSR
state_6119:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1824;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1824;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI
state_6120:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6121;
	case Keyword::B: m_lexer.next(); goto state_6130;
	case Keyword::C: m_lexer.next(); goto state_6135;
	case Keyword::D: m_lexer.next(); goto state_6140;
	case Keyword::E: m_lexer.next(); goto state_6145;
	case Keyword::H: m_lexer.next(); goto state_6150;
	case Keyword::L: m_lexer.next(); goto state_6155;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1825;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1825;
	case TType::LParen: m_lexer.next(); goto state_6160;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI A
state_6121:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6122;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI A Comma
state_6122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6123;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI A Comma LParen
state_6123:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6124;
	case Keyword::DE: m_lexer.next(); goto state_6126;
	case Keyword::HL: m_lexer.next(); goto state_6128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI A Comma LParen BC
state_6124:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6125;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI A Comma LParen BC RParen
state_6125:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1680;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1680;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI A Comma LParen DE
state_6126:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6127;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI A Comma LParen DE RParen
state_6127:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1683;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1683;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI A Comma LParen HL
state_6128:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI A Comma LParen HL RParen
state_6129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1686;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1686;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI B
state_6130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI B Comma
state_6131:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6132;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI B Comma LParen
state_6132:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6133;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI B Comma LParen HL
state_6133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6134;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI B Comma LParen HL RParen
state_6134:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1694;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI C
state_6135:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6136;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI C Comma
state_6136:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6137;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI C Comma LParen
state_6137:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI C Comma LParen HL
state_6138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI C Comma LParen HL RParen
state_6139:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1702;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI D
state_6140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI D Comma
state_6141:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6142;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI D Comma LParen
state_6142:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6143;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI D Comma LParen HL
state_6143:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6144;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI D Comma LParen HL RParen
state_6144:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1709;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1709;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI E
state_6145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI E Comma
state_6146:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI E Comma LParen
state_6147:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6148;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI E Comma LParen HL
state_6148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6149;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI E Comma LParen HL RParen
state_6149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1717;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1717;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI H
state_6150:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI H Comma
state_6151:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI H Comma LParen
state_6152:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6153;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI H Comma LParen HL
state_6153:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6154;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI H Comma LParen HL RParen
state_6154:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1724;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI L
state_6155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6156;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI L Comma
state_6156:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6157;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI L Comma LParen
state_6157:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6158;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI L Comma LParen HL
state_6158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6159;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI L Comma LParen HL RParen
state_6159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1740;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen
state_6160:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6161;
	case Keyword::DE: m_lexer.next(); goto state_6165;
	case Keyword::HL: m_lexer.next(); goto state_6169;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen BC
state_6161:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen BC RParen
state_6162:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen BC RParen Comma
state_6163:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6164;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen BC RParen Comma A
state_6164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1748;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1748;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen DE
state_6165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen DE RParen
state_6166:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen DE RParen Comma
state_6167:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen DE RParen Comma A
state_6168:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1751;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL
state_6169:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6170;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen
state_6170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6171;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen Comma
state_6171:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6172;
	case Keyword::B: m_lexer.next(); goto state_6173;
	case Keyword::C: m_lexer.next(); goto state_6174;
	case Keyword::D: m_lexer.next(); goto state_6175;
	case Keyword::E: m_lexer.next(); goto state_6176;
	case Keyword::H: m_lexer.next(); goto state_6177;
	case Keyword::L: m_lexer.next(); goto state_6178;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6179; }
	/*if (check_expr())*/ goto state_6179;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen Comma A
state_6172:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1761;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen Comma B
state_6173:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1762;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen Comma C
state_6174:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1763;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen Comma D
state_6175:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1764;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen Comma E
state_6176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1765;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen Comma H
state_6177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1766;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1766;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen Comma L
state_6178:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1767;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDI LParen HL RParen Comma expr
state_6179:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1768;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDIR
state_6180:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1826;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LDISR
state_6181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1827;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1827;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LSDDR
state_6182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1828;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1828;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LSDR
state_6183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1829;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1829;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LSIDR
state_6184:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1830;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1830;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI LSIR
state_6185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1831;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1831;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR
state_6186:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6187;
	case Keyword::A1: m_lexer.next(); goto state_6204;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6221;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A
state_6187:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma
state_6188:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen
state_6189:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6190;
	case Keyword::IX: m_lexer.next(); goto state_6196;
	case Keyword::IY: m_lexer.next(); goto state_6200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen HL
state_6190:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6191;
	case TType::Plus: m_lexer.next(); goto state_6193;
	case TType::RParen: m_lexer.next(); goto state_6195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen HL Minus
state_6191:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6192;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen HL Minus RParen
state_6192:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1832;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1832;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen HL Plus
state_6193:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen HL Plus RParen
state_6194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1833;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen HL RParen
state_6195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1834;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1834;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen IX
state_6196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6197;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6198; }
	/*if (check_expr())*/ goto state_6198;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen IX RParen
state_6197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1835;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen IX expr
state_6198:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6199;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen IX expr RParen
state_6199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1836;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1836;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen IY
state_6200:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6201;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6202; }
	/*if (check_expr())*/ goto state_6202;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen IY RParen
state_6201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1837;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1837;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen IY expr
state_6202:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A Comma LParen IY expr RParen
state_6203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1838;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1
state_6204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma
state_6205:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6206;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen
state_6206:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6207;
	case Keyword::IX: m_lexer.next(); goto state_6213;
	case Keyword::IY: m_lexer.next(); goto state_6217;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen HL
state_6207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6208;
	case TType::Plus: m_lexer.next(); goto state_6210;
	case TType::RParen: m_lexer.next(); goto state_6212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen HL Minus
state_6208:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6209;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen HL Minus RParen
state_6209:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1583;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1583;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen HL Plus
state_6210:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen HL Plus RParen
state_6211:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1584;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen HL RParen
state_6212:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1585;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen IX
state_6213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6214;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6215; }
	/*if (check_expr())*/ goto state_6215;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen IX RParen
state_6214:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1586;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen IX expr
state_6215:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6216;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen IX expr RParen
state_6216:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1587;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1587;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen IY
state_6217:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6218;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6219; }
	/*if (check_expr())*/ goto state_6219;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen IY RParen
state_6218:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1588;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1588;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen IY expr
state_6219:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6220;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR A1 Comma LParen IY expr RParen
state_6220:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1589;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen
state_6221:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6222;
	case Keyword::IX: m_lexer.next(); goto state_6228;
	case Keyword::IY: m_lexer.next(); goto state_6232;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen HL
state_6222:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6223;
	case TType::Plus: m_lexer.next(); goto state_6225;
	case TType::RParen: m_lexer.next(); goto state_6227;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen HL Minus
state_6223:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6224;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen HL Minus RParen
state_6224:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1832;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1832;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen HL Plus
state_6225:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6226;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen HL Plus RParen
state_6226:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1833;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen HL RParen
state_6227:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1834;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1834;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen IX
state_6228:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6229;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6230; }
	/*if (check_expr())*/ goto state_6230;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen IX RParen
state_6229:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1835;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen IX expr
state_6230:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6231;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen IX expr RParen
state_6231:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1836;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1836;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen IY
state_6232:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6233;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6234; }
	/*if (check_expr())*/ goto state_6234;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen IY RParen
state_6233:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1837;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1837;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen IY expr
state_6234:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6235;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI OR LParen IY expr RParen
state_6235:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1838;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES
state_6236:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6237; }
	/*if (check_const_expr())*/ goto state_6237;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr
state_6237:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6238;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma
state_6238:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6239;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen
state_6239:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6240;
	case Keyword::IX: m_lexer.next(); goto state_6242;
	case Keyword::IY: m_lexer.next(); goto state_6246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen HL
state_6240:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6241;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen HL RParen
state_6241:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1839;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1839;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen IX
state_6242:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6243;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6244; }
	/*if (check_expr())*/ goto state_6244;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen IX RParen
state_6243:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1840;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1840;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen IX expr
state_6244:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6245;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen IX expr RParen
state_6245:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1841;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen IY
state_6246:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6247;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6248; }
	/*if (check_expr())*/ goto state_6248;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen IY RParen
state_6247:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1842;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1842;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen IY expr
state_6248:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6249;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RES const_expr Comma LParen IY expr RParen
state_6249:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1843;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1843;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL
state_6250:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6251;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen
state_6251:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6252;
	case Keyword::IX: m_lexer.next(); goto state_6254;
	case Keyword::IY: m_lexer.next(); goto state_6258;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen HL
state_6252:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6253;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen HL RParen
state_6253:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1844;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1844;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen IX
state_6254:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6255;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6256; }
	/*if (check_expr())*/ goto state_6256;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen IX RParen
state_6255:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1845;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1845;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen IX expr
state_6256:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6257;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen IX expr RParen
state_6257:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1846;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1846;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen IY
state_6258:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6259;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6260; }
	/*if (check_expr())*/ goto state_6260;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen IY RParen
state_6259:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1847;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1847;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen IY expr
state_6260:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RL LParen IY expr RParen
state_6261:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1848;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1848;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC
state_6262:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6263;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen
state_6263:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6264;
	case Keyword::IX: m_lexer.next(); goto state_6266;
	case Keyword::IY: m_lexer.next(); goto state_6270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen HL
state_6264:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6265;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen HL RParen
state_6265:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1849;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1849;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen IX
state_6266:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6267;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6268; }
	/*if (check_expr())*/ goto state_6268;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen IX RParen
state_6267:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1850;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1850;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen IX expr
state_6268:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen IX expr RParen
state_6269:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1851;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1851;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen IY
state_6270:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6271;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6272; }
	/*if (check_expr())*/ goto state_6272;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen IY RParen
state_6271:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1852;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1852;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen IY expr
state_6272:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6273;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RLC LParen IY expr RParen
state_6273:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1853;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1853;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR
state_6274:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen
state_6275:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6276;
	case Keyword::IX: m_lexer.next(); goto state_6278;
	case Keyword::IY: m_lexer.next(); goto state_6282;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen HL
state_6276:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6277;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen HL RParen
state_6277:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1854;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1854;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen IX
state_6278:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6279;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6280; }
	/*if (check_expr())*/ goto state_6280;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen IX RParen
state_6279:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1855;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1855;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen IX expr
state_6280:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen IX expr RParen
state_6281:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1856;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1856;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen IY
state_6282:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6283;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6284; }
	/*if (check_expr())*/ goto state_6284;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen IY RParen
state_6283:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1857;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1857;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen IY expr
state_6284:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6285;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RR LParen IY expr RParen
state_6285:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1858;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1858;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC
state_6286:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6287;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen
state_6287:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6288;
	case Keyword::IX: m_lexer.next(); goto state_6290;
	case Keyword::IY: m_lexer.next(); goto state_6294;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen HL
state_6288:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6289;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen HL RParen
state_6289:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1859;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1859;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen IX
state_6290:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6291;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6292; }
	/*if (check_expr())*/ goto state_6292;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen IX RParen
state_6291:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1860;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1860;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen IX expr
state_6292:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6293;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen IX expr RParen
state_6293:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1861;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1861;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen IY
state_6294:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6295;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6296; }
	/*if (check_expr())*/ goto state_6296;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen IY RParen
state_6295:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1862;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen IY expr
state_6296:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6297;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI RRC LParen IY expr RParen
state_6297:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1863;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1863;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC
state_6298:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6299;
	case Keyword::A1: m_lexer.next(); goto state_6316;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6333;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A
state_6299:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma
state_6300:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6301;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen
state_6301:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6302;
	case Keyword::IX: m_lexer.next(); goto state_6308;
	case Keyword::IY: m_lexer.next(); goto state_6312;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen HL
state_6302:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6303;
	case TType::Plus: m_lexer.next(); goto state_6305;
	case TType::RParen: m_lexer.next(); goto state_6307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen HL Minus
state_6303:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6304;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen HL Minus RParen
state_6304:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1864;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1864;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen HL Plus
state_6305:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6306;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen HL Plus RParen
state_6306:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1865;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1865;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen HL RParen
state_6307:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1866;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen IX
state_6308:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6309;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6310; }
	/*if (check_expr())*/ goto state_6310;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen IX RParen
state_6309:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1867;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1867;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen IX expr
state_6310:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen IX expr RParen
state_6311:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1868;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1868;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen IY
state_6312:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6313;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6314; }
	/*if (check_expr())*/ goto state_6314;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen IY RParen
state_6313:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1869;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1869;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen IY expr
state_6314:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A Comma LParen IY expr RParen
state_6315:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1870;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1870;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1
state_6316:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6317;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma
state_6317:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6318;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen
state_6318:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6319;
	case Keyword::IX: m_lexer.next(); goto state_6325;
	case Keyword::IY: m_lexer.next(); goto state_6329;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen HL
state_6319:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6320;
	case TType::Plus: m_lexer.next(); goto state_6322;
	case TType::RParen: m_lexer.next(); goto state_6324;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen HL Minus
state_6320:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6321;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen HL Minus RParen
state_6321:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1610;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1610;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen HL Plus
state_6322:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6323;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen HL Plus RParen
state_6323:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1611;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen HL RParen
state_6324:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1612;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen IX
state_6325:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6326;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6327; }
	/*if (check_expr())*/ goto state_6327;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen IX RParen
state_6326:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1613;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1613;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen IX expr
state_6327:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6328;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen IX expr RParen
state_6328:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1614;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen IY
state_6329:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6330;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6331; }
	/*if (check_expr())*/ goto state_6331;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen IY RParen
state_6330:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1615;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1615;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen IY expr
state_6331:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6332;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC A1 Comma LParen IY expr RParen
state_6332:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1616;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1616;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen
state_6333:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6334;
	case Keyword::IX: m_lexer.next(); goto state_6340;
	case Keyword::IY: m_lexer.next(); goto state_6344;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen HL
state_6334:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6335;
	case TType::Plus: m_lexer.next(); goto state_6337;
	case TType::RParen: m_lexer.next(); goto state_6339;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen HL Minus
state_6335:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6336;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen HL Minus RParen
state_6336:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1864;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1864;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen HL Plus
state_6337:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6338;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen HL Plus RParen
state_6338:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1865;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1865;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen HL RParen
state_6339:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1866;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen IX
state_6340:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6341;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6342; }
	/*if (check_expr())*/ goto state_6342;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen IX RParen
state_6341:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1867;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1867;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen IX expr
state_6342:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6343;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen IX expr RParen
state_6343:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1868;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1868;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen IY
state_6344:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6345;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6346; }
	/*if (check_expr())*/ goto state_6346;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen IY RParen
state_6345:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1869;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1869;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen IY expr
state_6346:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6347;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SBC LParen IY expr RParen
state_6347:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1870;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1870;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET
state_6348:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6349; }
	/*if (check_const_expr())*/ goto state_6349;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr
state_6349:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6350;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma
state_6350:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen
state_6351:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6352;
	case Keyword::IX: m_lexer.next(); goto state_6354;
	case Keyword::IY: m_lexer.next(); goto state_6358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen HL
state_6352:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6353;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen HL RParen
state_6353:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1871;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1871;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen IX
state_6354:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6355;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6356; }
	/*if (check_expr())*/ goto state_6356;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen IX RParen
state_6355:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1872;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1872;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen IX expr
state_6356:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen IX expr RParen
state_6357:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1873;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1873;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen IY
state_6358:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6359;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6360; }
	/*if (check_expr())*/ goto state_6360;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen IY RParen
state_6359:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1874;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1874;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen IY expr
state_6360:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6361;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SET const_expr Comma LParen IY expr RParen
state_6361:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1875;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1875;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA
state_6362:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen
state_6363:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6364;
	case Keyword::IX: m_lexer.next(); goto state_6366;
	case Keyword::IY: m_lexer.next(); goto state_6370;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen HL
state_6364:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6365;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen HL RParen
state_6365:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1876;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1876;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen IX
state_6366:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6367;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6368; }
	/*if (check_expr())*/ goto state_6368;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen IX RParen
state_6367:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1877;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1877;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen IX expr
state_6368:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6369;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen IX expr RParen
state_6369:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1878;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1878;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen IY
state_6370:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6371;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6372; }
	/*if (check_expr())*/ goto state_6372;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen IY RParen
state_6371:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1879;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1879;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen IY expr
state_6372:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6373;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SLA LParen IY expr RParen
state_6373:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1880;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1880;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA
state_6374:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6375;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen
state_6375:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6376;
	case Keyword::IX: m_lexer.next(); goto state_6378;
	case Keyword::IY: m_lexer.next(); goto state_6382;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen HL
state_6376:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6377;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen HL RParen
state_6377:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1881;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1881;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen IX
state_6378:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6379;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6380; }
	/*if (check_expr())*/ goto state_6380;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen IX RParen
state_6379:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1882;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1882;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen IX expr
state_6380:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6381;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen IX expr RParen
state_6381:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1883;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1883;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen IY
state_6382:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6383;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6384; }
	/*if (check_expr())*/ goto state_6384;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen IY RParen
state_6383:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1884;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1884;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen IY expr
state_6384:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6385;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRA LParen IY expr RParen
state_6385:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1885;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1885;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL
state_6386:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6387;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen
state_6387:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6388;
	case Keyword::IX: m_lexer.next(); goto state_6390;
	case Keyword::IY: m_lexer.next(); goto state_6394;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen HL
state_6388:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6389;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen HL RParen
state_6389:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1886;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1886;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen IX
state_6390:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6391;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6392; }
	/*if (check_expr())*/ goto state_6392;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen IX RParen
state_6391:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1887;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1887;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen IX expr
state_6392:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6393;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen IX expr RParen
state_6393:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1888;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen IY
state_6394:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6395;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6396; }
	/*if (check_expr())*/ goto state_6396;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen IY RParen
state_6395:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1889;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1889;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen IY expr
state_6396:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6397;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SRL LParen IY expr RParen
state_6397:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1890;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1890;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB
state_6398:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6399;
	case Keyword::A1: m_lexer.next(); goto state_6416;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6433;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A
state_6399:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma
state_6400:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6401;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen
state_6401:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6402;
	case Keyword::IX: m_lexer.next(); goto state_6408;
	case Keyword::IY: m_lexer.next(); goto state_6412;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen HL
state_6402:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6403;
	case TType::Plus: m_lexer.next(); goto state_6405;
	case TType::RParen: m_lexer.next(); goto state_6407;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen HL Minus
state_6403:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6404;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen HL Minus RParen
state_6404:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1891;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1891;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen HL Plus
state_6405:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6406;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen HL Plus RParen
state_6406:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen HL RParen
state_6407:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1893;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1893;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen IX
state_6408:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6409;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6410; }
	/*if (check_expr())*/ goto state_6410;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen IX RParen
state_6409:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1894;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1894;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen IX expr
state_6410:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6411;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen IX expr RParen
state_6411:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen IY
state_6412:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6413;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6414; }
	/*if (check_expr())*/ goto state_6414;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen IY RParen
state_6413:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1896;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1896;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen IY expr
state_6414:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6415;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A Comma LParen IY expr RParen
state_6415:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1897;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1897;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1
state_6416:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma
state_6417:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6418;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen
state_6418:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6419;
	case Keyword::IX: m_lexer.next(); goto state_6425;
	case Keyword::IY: m_lexer.next(); goto state_6429;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen HL
state_6419:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6420;
	case TType::Plus: m_lexer.next(); goto state_6422;
	case TType::RParen: m_lexer.next(); goto state_6424;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen HL Minus
state_6420:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen HL Minus RParen
state_6421:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1632;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen HL Plus
state_6422:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6423;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen HL Plus RParen
state_6423:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1633;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen HL RParen
state_6424:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1634;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1634;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen IX
state_6425:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6426;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6427; }
	/*if (check_expr())*/ goto state_6427;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen IX RParen
state_6426:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1635;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1635;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen IX expr
state_6427:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6428;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen IX expr RParen
state_6428:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1636;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen IY
state_6429:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6430;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6431; }
	/*if (check_expr())*/ goto state_6431;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen IY RParen
state_6430:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1637;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen IY expr
state_6431:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6432;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB A1 Comma LParen IY expr RParen
state_6432:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1638;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1638;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen
state_6433:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6434;
	case Keyword::IX: m_lexer.next(); goto state_6440;
	case Keyword::IY: m_lexer.next(); goto state_6444;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen HL
state_6434:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6435;
	case TType::Plus: m_lexer.next(); goto state_6437;
	case TType::RParen: m_lexer.next(); goto state_6439;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen HL Minus
state_6435:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6436;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen HL Minus RParen
state_6436:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1891;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1891;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen HL Plus
state_6437:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6438;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen HL Plus RParen
state_6438:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen HL RParen
state_6439:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1893;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1893;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen IX
state_6440:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6441;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6442; }
	/*if (check_expr())*/ goto state_6442;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen IX RParen
state_6441:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1894;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1894;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen IX expr
state_6442:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6443;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen IX expr RParen
state_6443:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen IY
state_6444:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6445;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6446; }
	/*if (check_expr())*/ goto state_6446;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen IY RParen
state_6445:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1896;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1896;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen IY expr
state_6446:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6447;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI SUB LParen IY expr RParen
state_6447:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1897;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1897;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR
state_6448:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6449;
	case Keyword::A1: m_lexer.next(); goto state_6466;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6483;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A
state_6449:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6450;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma
state_6450:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen
state_6451:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6452;
	case Keyword::IX: m_lexer.next(); goto state_6458;
	case Keyword::IY: m_lexer.next(); goto state_6462;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen HL
state_6452:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6453;
	case TType::Plus: m_lexer.next(); goto state_6455;
	case TType::RParen: m_lexer.next(); goto state_6457;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen HL Minus
state_6453:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen HL Minus RParen
state_6454:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1898;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1898;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen HL Plus
state_6455:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6456;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen HL Plus RParen
state_6456:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1899;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen HL RParen
state_6457:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1900;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1900;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen IX
state_6458:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6459;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6460; }
	/*if (check_expr())*/ goto state_6460;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen IX RParen
state_6459:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1901;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen IX expr
state_6460:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen IX expr RParen
state_6461:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1902;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen IY
state_6462:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6463;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6464; }
	/*if (check_expr())*/ goto state_6464;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen IY RParen
state_6463:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1903;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen IY expr
state_6464:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A Comma LParen IY expr RParen
state_6465:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1904;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1
state_6466:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma
state_6467:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6468;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen
state_6468:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6469;
	case Keyword::IX: m_lexer.next(); goto state_6475;
	case Keyword::IY: m_lexer.next(); goto state_6479;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen HL
state_6469:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6470;
	case TType::Plus: m_lexer.next(); goto state_6472;
	case TType::RParen: m_lexer.next(); goto state_6474;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen HL Minus
state_6470:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6471;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen HL Minus RParen
state_6471:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1639;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen HL Plus
state_6472:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6473;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen HL Plus RParen
state_6473:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1640;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen HL RParen
state_6474:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1641;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1641;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen IX
state_6475:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6476;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6477; }
	/*if (check_expr())*/ goto state_6477;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen IX RParen
state_6476:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1642;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1642;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen IX expr
state_6477:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen IX expr RParen
state_6478:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1643;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1643;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen IY
state_6479:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6480;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6481; }
	/*if (check_expr())*/ goto state_6481;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen IY RParen
state_6480:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1644;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen IY expr
state_6481:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR A1 Comma LParen IY expr RParen
state_6482:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1645;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1645;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen
state_6483:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6484;
	case Keyword::IX: m_lexer.next(); goto state_6490;
	case Keyword::IY: m_lexer.next(); goto state_6494;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen HL
state_6484:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6485;
	case TType::Plus: m_lexer.next(); goto state_6487;
	case TType::RParen: m_lexer.next(); goto state_6489;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen HL Minus
state_6485:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen HL Minus RParen
state_6486:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1898;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1898;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen HL Plus
state_6487:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen HL Plus RParen
state_6488:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1899;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen HL RParen
state_6489:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1900;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1900;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen IX
state_6490:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6491;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6492; }
	/*if (check_expr())*/ goto state_6492;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen IX RParen
state_6491:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1901;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen IX expr
state_6492:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6493;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen IX expr RParen
state_6493:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1902;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen IY
state_6494:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6495;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6496; }
	/*if (check_expr())*/ goto state_6496;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen IY RParen
state_6495:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1903;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen IY expr
state_6496:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6497;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IOI XOR LParen IY expr RParen
state_6497:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1904;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IPRES
state_6498:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1905;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1905;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: IPSET
state_6499:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6500; }
	/*if (check_const_expr())*/ goto state_6500;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: IPSET const_expr
state_6500:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1906;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JC
state_6501:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6502; }
	/*if (check_expr())*/ goto state_6502;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JC expr
state_6502:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1907;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JK
state_6503:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6504; }
	/*if (check_expr())*/ goto state_6504;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JK expr
state_6504:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1908;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JLO
state_6505:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6506; }
	/*if (check_expr())*/ goto state_6506;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JLO expr
state_6506:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1909;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JLZ
state_6507:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6508; }
	/*if (check_expr())*/ goto state_6508;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JLZ expr
state_6508:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JM
state_6509:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6510; }
	/*if (check_expr())*/ goto state_6510;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JM expr
state_6510:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JMP
state_6511:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6512; }
	/*if (check_expr())*/ goto state_6512;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JMP expr
state_6512:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNC
state_6513:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6514; }
	/*if (check_expr())*/ goto state_6514;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNC expr
state_6514:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNK
state_6515:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6516; }
	/*if (check_expr())*/ goto state_6516;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNK expr
state_6516:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNV
state_6517:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6518; }
	/*if (check_expr())*/ goto state_6518;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNV expr
state_6518:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNX5
state_6519:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6520; }
	/*if (check_expr())*/ goto state_6520;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNX5 expr
state_6520:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNZ
state_6521:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6522; }
	/*if (check_expr())*/ goto state_6522;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JNZ expr
state_6522:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP
state_6523:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_6524;
	case Keyword::K: m_lexer.next(); goto state_6527;
	case Keyword::LO: m_lexer.next(); goto state_6530;
	case Keyword::LZ: m_lexer.next(); goto state_6533;
	case Keyword::M: m_lexer.next(); goto state_6536;
	case Keyword::NC: m_lexer.next(); goto state_6539;
	case Keyword::NK: m_lexer.next(); goto state_6542;
	case Keyword::NV: m_lexer.next(); goto state_6545;
	case Keyword::NX5: m_lexer.next(); goto state_6548;
	case Keyword::NZ: m_lexer.next(); goto state_6551;
	case Keyword::P: m_lexer.next(); goto state_6554;
	case Keyword::PE: m_lexer.next(); goto state_6557;
	case Keyword::PO: m_lexer.next(); goto state_6560;
	case Keyword::V: m_lexer.next(); goto state_6563;
	case Keyword::X5: m_lexer.next(); goto state_6566;
	case Keyword::Z: m_lexer.next(); goto state_6569;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6572;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6585; }
	/*if (check_expr())*/ goto state_6585;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP C
state_6524:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP C Comma
state_6525:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6526; }
	/*if (check_expr())*/ goto state_6526;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP C Comma expr
state_6526:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1907;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP K
state_6527:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6528;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP K Comma
state_6528:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6529; }
	/*if (check_expr())*/ goto state_6529;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP K Comma expr
state_6529:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1908;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LO
state_6530:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LO Comma
state_6531:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6532; }
	/*if (check_expr())*/ goto state_6532;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LO Comma expr
state_6532:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1909;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LZ
state_6533:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LZ Comma
state_6534:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6535; }
	/*if (check_expr())*/ goto state_6535;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LZ Comma expr
state_6535:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP M
state_6536:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6537;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP M Comma
state_6537:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6538; }
	/*if (check_expr())*/ goto state_6538;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP M Comma expr
state_6538:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NC
state_6539:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NC Comma
state_6540:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6541; }
	/*if (check_expr())*/ goto state_6541;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NC Comma expr
state_6541:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NK
state_6542:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NK Comma
state_6543:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6544; }
	/*if (check_expr())*/ goto state_6544;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NK Comma expr
state_6544:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NV
state_6545:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6546;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NV Comma
state_6546:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6547; }
	/*if (check_expr())*/ goto state_6547;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NV Comma expr
state_6547:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NX5
state_6548:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NX5 Comma
state_6549:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6550; }
	/*if (check_expr())*/ goto state_6550;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NX5 Comma expr
state_6550:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NZ
state_6551:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NZ Comma
state_6552:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6553; }
	/*if (check_expr())*/ goto state_6553;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP NZ Comma expr
state_6553:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP P
state_6554:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6555;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP P Comma
state_6555:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6556; }
	/*if (check_expr())*/ goto state_6556;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP P Comma expr
state_6556:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP PE
state_6557:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6558;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP PE Comma
state_6558:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6559; }
	/*if (check_expr())*/ goto state_6559;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP PE Comma expr
state_6559:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP PO
state_6560:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6561;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP PO Comma
state_6561:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6562; }
	/*if (check_expr())*/ goto state_6562;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP PO Comma expr
state_6562:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP V
state_6563:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6564;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP V Comma
state_6564:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6565; }
	/*if (check_expr())*/ goto state_6565;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP V Comma expr
state_6565:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP X5
state_6566:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP X5 Comma
state_6567:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6568; }
	/*if (check_expr())*/ goto state_6568;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP X5 Comma expr
state_6568:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1908;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP Z
state_6569:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6570;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP Z Comma
state_6570:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6571; }
	/*if (check_expr())*/ goto state_6571;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP Z Comma expr
state_6571:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1919;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1919;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen
state_6572:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6573;
	case Keyword::C: m_lexer.next(); goto state_6575;
	case Keyword::DE: m_lexer.next(); goto state_6577;
	case Keyword::HL: m_lexer.next(); goto state_6579;
	case Keyword::IX: m_lexer.next(); goto state_6581;
	case Keyword::IY: m_lexer.next(); goto state_6583;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen BC
state_6573:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen BC RParen
state_6574:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1920;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1920;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen C
state_6575:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen C RParen
state_6576:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1921;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1921;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen DE
state_6577:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen DE RParen
state_6578:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1922;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1922;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen HL
state_6579:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen HL RParen
state_6580:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1923;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen IX
state_6581:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen IX RParen
state_6582:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1924;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen IY
state_6583:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP LParen IY RParen
state_6584:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1925;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JP expr
state_6585:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JPE
state_6586:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6587; }
	/*if (check_expr())*/ goto state_6587;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JPE expr
state_6587:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JPO
state_6588:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6589; }
	/*if (check_expr())*/ goto state_6589;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JPO expr
state_6589:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR
state_6590:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_6591;
	case Keyword::NC: m_lexer.next(); goto state_6594;
	case Keyword::NZ: m_lexer.next(); goto state_6597;
	case Keyword::Z: m_lexer.next(); goto state_6600;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6603; }
	/*if (check_expr())*/ goto state_6603;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR C
state_6591:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6592;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR C Comma
state_6592:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6593; }
	/*if (check_expr())*/ goto state_6593;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR C Comma expr
state_6593:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1926;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR NC
state_6594:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6595;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR NC Comma
state_6595:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6596; }
	/*if (check_expr())*/ goto state_6596;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR NC Comma expr
state_6596:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1927;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1927;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR NZ
state_6597:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6598;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR NZ Comma
state_6598:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6599; }
	/*if (check_expr())*/ goto state_6599;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR NZ Comma expr
state_6599:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1928;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1928;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR Z
state_6600:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6601;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR Z Comma
state_6601:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6602; }
	/*if (check_expr())*/ goto state_6602;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR Z Comma expr
state_6602:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1929;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1929;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JR expr
state_6603:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1930;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JV
state_6604:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6605; }
	/*if (check_expr())*/ goto state_6605;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JV expr
state_6605:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JX5
state_6606:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6607; }
	/*if (check_expr())*/ goto state_6607;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JX5 expr
state_6607:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1908;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: JZ
state_6608:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6609; }
	/*if (check_expr())*/ goto state_6609;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: JZ expr
state_6609:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1919;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1919;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_C
state_6610:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6611; }
	/*if (check_expr())*/ goto state_6611;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_C expr
state_6611:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1907;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_LO
state_6612:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6613; }
	/*if (check_expr())*/ goto state_6613;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_LO expr
state_6613:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1909;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_LZ
state_6614:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6615; }
	/*if (check_expr())*/ goto state_6615;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_LZ expr
state_6615:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_M
state_6616:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6617; }
	/*if (check_expr())*/ goto state_6617;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_M expr
state_6617:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_NC
state_6618:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6619; }
	/*if (check_expr())*/ goto state_6619;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_NC expr
state_6619:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_NV
state_6620:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6621; }
	/*if (check_expr())*/ goto state_6621;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_NV expr
state_6621:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_NZ
state_6622:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6623; }
	/*if (check_expr())*/ goto state_6623;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_NZ expr
state_6623:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_P
state_6624:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6625; }
	/*if (check_expr())*/ goto state_6625;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_P expr
state_6625:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_PE
state_6626:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6627; }
	/*if (check_expr())*/ goto state_6627;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_PE expr
state_6627:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_PO
state_6628:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6629; }
	/*if (check_expr())*/ goto state_6629;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_PO expr
state_6629:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_V
state_6630:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6631; }
	/*if (check_expr())*/ goto state_6631;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_V expr
state_6631:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_Z
state_6632:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6633; }
	/*if (check_expr())*/ goto state_6633;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: J_Z expr
state_6633:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1919;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1919;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD
state_6634:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6635;
	case Keyword::A1: m_lexer.next(); goto state_6687;
	case Keyword::B: m_lexer.next(); goto state_6731;
	case Keyword::B1: m_lexer.next(); goto state_6770;
	case Keyword::BC: m_lexer.next(); goto state_6799;
	case Keyword::BC1: m_lexer.next(); goto state_6806;
	case Keyword::C: m_lexer.next(); goto state_6811;
	case Keyword::C1: m_lexer.next(); goto state_6850;
	case Keyword::D: m_lexer.next(); goto state_6879;
	case Keyword::D1: m_lexer.next(); goto state_6918;
	case Keyword::DE: m_lexer.next(); goto state_6947;
	case Keyword::DE1: m_lexer.next(); goto state_6957;
	case Keyword::E: m_lexer.next(); goto state_6962;
	case Keyword::E1: m_lexer.next(); goto state_7001;
	case Keyword::EIR: m_lexer.next(); goto state_7030;
	case Keyword::H: m_lexer.next(); goto state_7033;
	case Keyword::H1: m_lexer.next(); goto state_7068;
	case Keyword::HL: m_lexer.next(); goto state_7097;
	case Keyword::HL1: m_lexer.next(); goto state_7125;
	case Keyword::I: m_lexer.next(); goto state_7149;
	case Keyword::IIR: m_lexer.next(); goto state_7152;
	case Keyword::IX: m_lexer.next(); goto state_7155;
	case Keyword::IXH: m_lexer.next(); goto state_7167;
	case Keyword::IXL: m_lexer.next(); goto state_7177;
	case Keyword::IY: m_lexer.next(); goto state_7187;
	case Keyword::IYH: m_lexer.next(); goto state_7199;
	case Keyword::IYL: m_lexer.next(); goto state_7209;
	case Keyword::L: m_lexer.next(); goto state_7219;
	case Keyword::L1: m_lexer.next(); goto state_7254;
	case Keyword::R: m_lexer.next(); goto state_7283;
	case Keyword::SP: m_lexer.next(); goto state_7286;
	case Keyword::XPC: m_lexer.next(); goto state_7292;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7295;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7468; }
	/*if (check_expr())*/ goto state_7468;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A
state_6635:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma
state_6636:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6637;
	case Keyword::B: m_lexer.next(); goto state_6638;
	case Keyword::C: m_lexer.next(); goto state_6639;
	case Keyword::D: m_lexer.next(); goto state_6640;
	case Keyword::E: m_lexer.next(); goto state_6641;
	case Keyword::EIR: m_lexer.next(); goto state_6642;
	case Keyword::H: m_lexer.next(); goto state_6643;
	case Keyword::I: m_lexer.next(); goto state_6644;
	case Keyword::IIR: m_lexer.next(); goto state_6645;
	case Keyword::IXH: m_lexer.next(); goto state_6646;
	case Keyword::IXL: m_lexer.next(); goto state_6647;
	case Keyword::IYH: m_lexer.next(); goto state_6648;
	case Keyword::IYL: m_lexer.next(); goto state_6649;
	case Keyword::L: m_lexer.next(); goto state_6650;
	case Keyword::R: m_lexer.next(); goto state_6651;
	case Keyword::XPC: m_lexer.next(); goto state_6652;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6653;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6686; }
	/*if (check_expr())*/ goto state_6686;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma A
state_6637:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1931;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma B
state_6638:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1932;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma C
state_6639:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1933;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma D
state_6640:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1934;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma E
state_6641:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1935;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma EIR
state_6642:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1936;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1936;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma H
state_6643:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1937;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1937;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma I
state_6644:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1938;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1938;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma IIR
state_6645:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1939;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1939;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma IXH
state_6646:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1940;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1940;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma IXL
state_6647:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1941;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1941;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma IYH
state_6648:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1942;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1942;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma IYL
state_6649:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1943;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1943;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma L
state_6650:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1944;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1944;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma R
state_6651:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1945;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1945;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma XPC
state_6652:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1946;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1946;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen
state_6653:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6654;
	case Keyword::C: m_lexer.next(); goto state_6660;
	case Keyword::DE: m_lexer.next(); goto state_6662;
	case Keyword::HL: m_lexer.next(); goto state_6668;
	case Keyword::HLD: m_lexer.next(); goto state_6674;
	case Keyword::HLI: m_lexer.next(); goto state_6676;
	case Keyword::IX: m_lexer.next(); goto state_6678;
	case Keyword::IY: m_lexer.next(); goto state_6682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen BC
state_6654:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6655;
	case TType::Plus: m_lexer.next(); goto state_6657;
	case TType::RParen: m_lexer.next(); goto state_6659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen BC Minus
state_6655:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen BC Minus RParen
state_6656:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1947;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1947;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen BC Plus
state_6657:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen BC Plus RParen
state_6658:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1948;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1948;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen BC RParen
state_6659:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1949;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1949;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen C
state_6660:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen C RParen
state_6661:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1950;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1950;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen DE
state_6662:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6663;
	case TType::Plus: m_lexer.next(); goto state_6665;
	case TType::RParen: m_lexer.next(); goto state_6667;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen DE Minus
state_6663:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen DE Minus RParen
state_6664:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1951;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1951;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen DE Plus
state_6665:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6666;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen DE Plus RParen
state_6666:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1952;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1952;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen DE RParen
state_6667:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1953;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1953;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HL
state_6668:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6669;
	case TType::Plus: m_lexer.next(); goto state_6671;
	case TType::RParen: m_lexer.next(); goto state_6673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HL Minus
state_6669:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6670;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HL Minus RParen
state_6670:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1954;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1954;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HL Plus
state_6671:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6672;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HL Plus RParen
state_6672:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1955;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1955;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HL RParen
state_6673:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1956;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1956;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HLD
state_6674:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6675;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HLD RParen
state_6675:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1954;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1954;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HLI
state_6676:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6677;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen HLI RParen
state_6677:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1955;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1955;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen IX
state_6678:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6679;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6680; }
	/*if (check_expr())*/ goto state_6680;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen IX RParen
state_6679:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1957;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1957;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen IX expr
state_6680:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6681;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen IX expr RParen
state_6681:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1958;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1958;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen IY
state_6682:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6683;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6684; }
	/*if (check_expr())*/ goto state_6684;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen IY RParen
state_6683:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1959;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1959;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen IY expr
state_6684:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma LParen IY expr RParen
state_6685:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1960;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1960;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A Comma expr
state_6686:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1961;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1961;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1
state_6687:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6688;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma
state_6688:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6689;
	case Keyword::B: m_lexer.next(); goto state_6690;
	case Keyword::C: m_lexer.next(); goto state_6691;
	case Keyword::D: m_lexer.next(); goto state_6692;
	case Keyword::E: m_lexer.next(); goto state_6693;
	case Keyword::EIR: m_lexer.next(); goto state_6694;
	case Keyword::H: m_lexer.next(); goto state_6695;
	case Keyword::IIR: m_lexer.next(); goto state_6696;
	case Keyword::L: m_lexer.next(); goto state_6697;
	case Keyword::XPC: m_lexer.next(); goto state_6698;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6699;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6730; }
	/*if (check_expr())*/ goto state_6730;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma A
state_6689:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_535;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_535;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma B
state_6690:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_536;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_536;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma C
state_6691:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_537;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_537;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma D
state_6692:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_538;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_538;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma E
state_6693:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_539;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_539;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma EIR
state_6694:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_540;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma H
state_6695:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_541;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma IIR
state_6696:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_542;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_542;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma L
state_6697:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_543;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma XPC
state_6698:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_544;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_544;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen
state_6699:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6700;
	case Keyword::DE: m_lexer.next(); goto state_6706;
	case Keyword::HL: m_lexer.next(); goto state_6712;
	case Keyword::HLD: m_lexer.next(); goto state_6718;
	case Keyword::HLI: m_lexer.next(); goto state_6720;
	case Keyword::IX: m_lexer.next(); goto state_6722;
	case Keyword::IY: m_lexer.next(); goto state_6726;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen BC
state_6700:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6701;
	case TType::Plus: m_lexer.next(); goto state_6703;
	case TType::RParen: m_lexer.next(); goto state_6705;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen BC Minus
state_6701:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen BC Minus RParen
state_6702:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_545;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_545;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen BC Plus
state_6703:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6704;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen BC Plus RParen
state_6704:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_546;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_546;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen BC RParen
state_6705:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_547;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_547;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen DE
state_6706:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6707;
	case TType::Plus: m_lexer.next(); goto state_6709;
	case TType::RParen: m_lexer.next(); goto state_6711;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen DE Minus
state_6707:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen DE Minus RParen
state_6708:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_548;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_548;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen DE Plus
state_6709:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6710;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen DE Plus RParen
state_6710:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_549;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen DE RParen
state_6711:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_550;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_550;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HL
state_6712:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6713;
	case TType::Plus: m_lexer.next(); goto state_6715;
	case TType::RParen: m_lexer.next(); goto state_6717;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HL Minus
state_6713:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6714;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HL Minus RParen
state_6714:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_551;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_551;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HL Plus
state_6715:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6716;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HL Plus RParen
state_6716:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_552;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HL RParen
state_6717:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_553;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_553;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HLD
state_6718:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6719;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HLD RParen
state_6719:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_551;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_551;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HLI
state_6720:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6721;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen HLI RParen
state_6721:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_552;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen IX
state_6722:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6723;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6724; }
	/*if (check_expr())*/ goto state_6724;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen IX RParen
state_6723:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_554;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_554;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen IX expr
state_6724:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6725;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen IX expr RParen
state_6725:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_555;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_555;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen IY
state_6726:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6727;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6728; }
	/*if (check_expr())*/ goto state_6728;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen IY RParen
state_6727:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_556;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen IY expr
state_6728:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma LParen IY expr RParen
state_6729:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_557;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD A1 Comma expr
state_6730:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_558;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_558;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B
state_6731:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6732;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma
state_6732:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6733;
	case Keyword::B: m_lexer.next(); goto state_6734;
	case Keyword::C: m_lexer.next(); goto state_6735;
	case Keyword::D: m_lexer.next(); goto state_6736;
	case Keyword::E: m_lexer.next(); goto state_6737;
	case Keyword::H: m_lexer.next(); goto state_6738;
	case Keyword::IXH: m_lexer.next(); goto state_6739;
	case Keyword::IXL: m_lexer.next(); goto state_6740;
	case Keyword::IYH: m_lexer.next(); goto state_6741;
	case Keyword::IYL: m_lexer.next(); goto state_6742;
	case Keyword::L: m_lexer.next(); goto state_6743;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6744;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6769; }
	/*if (check_expr())*/ goto state_6769;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma A
state_6733:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1962;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1962;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma B
state_6734:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1963;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1963;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma C
state_6735:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1964;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1964;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma D
state_6736:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1965;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1965;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma E
state_6737:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1966;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1966;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma H
state_6738:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1967;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1967;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma IXH
state_6739:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1968;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1968;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma IXL
state_6740:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1969;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1969;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma IYH
state_6741:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1970;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1970;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma IYL
state_6742:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1971;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1971;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma L
state_6743:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1972;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1972;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen
state_6744:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_6745;
	case Keyword::HL: m_lexer.next(); goto state_6751;
	case Keyword::HLD: m_lexer.next(); goto state_6757;
	case Keyword::HLI: m_lexer.next(); goto state_6759;
	case Keyword::IX: m_lexer.next(); goto state_6761;
	case Keyword::IY: m_lexer.next(); goto state_6765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen DE
state_6745:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6746;
	case TType::Plus: m_lexer.next(); goto state_6748;
	case TType::RParen: m_lexer.next(); goto state_6750;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen DE Minus
state_6746:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6747;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen DE Minus RParen
state_6747:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1973;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1973;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen DE Plus
state_6748:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6749;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen DE Plus RParen
state_6749:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1974;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1974;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen DE RParen
state_6750:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1975;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1975;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HL
state_6751:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6752;
	case TType::Plus: m_lexer.next(); goto state_6754;
	case TType::RParen: m_lexer.next(); goto state_6756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HL Minus
state_6752:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HL Minus RParen
state_6753:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1976;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1976;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HL Plus
state_6754:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HL Plus RParen
state_6755:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1977;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1977;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HL RParen
state_6756:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1978;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HLD
state_6757:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HLD RParen
state_6758:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1976;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1976;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HLI
state_6759:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen HLI RParen
state_6760:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1977;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1977;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen IX
state_6761:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6762;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6763; }
	/*if (check_expr())*/ goto state_6763;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen IX RParen
state_6762:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1979;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1979;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen IX expr
state_6763:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen IX expr RParen
state_6764:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1980;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1980;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen IY
state_6765:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6766;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6767; }
	/*if (check_expr())*/ goto state_6767;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen IY RParen
state_6766:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1981;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1981;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen IY expr
state_6767:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma LParen IY expr RParen
state_6768:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1982;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1982;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B Comma expr
state_6769:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1983;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1983;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1
state_6770:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma
state_6771:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6772;
	case Keyword::B: m_lexer.next(); goto state_6773;
	case Keyword::C: m_lexer.next(); goto state_6774;
	case Keyword::D: m_lexer.next(); goto state_6775;
	case Keyword::E: m_lexer.next(); goto state_6776;
	case Keyword::H: m_lexer.next(); goto state_6777;
	case Keyword::L: m_lexer.next(); goto state_6778;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6779;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6798; }
	/*if (check_expr())*/ goto state_6798;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma A
state_6772:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_559;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_559;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma B
state_6773:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_560;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_560;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma C
state_6774:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_561;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_561;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma D
state_6775:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_562;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma E
state_6776:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_563;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma H
state_6777:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_564;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_564;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma L
state_6778:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_565;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_565;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen
state_6779:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6780;
	case Keyword::HLD: m_lexer.next(); goto state_6786;
	case Keyword::HLI: m_lexer.next(); goto state_6788;
	case Keyword::IX: m_lexer.next(); goto state_6790;
	case Keyword::IY: m_lexer.next(); goto state_6794;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HL
state_6780:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6781;
	case TType::Plus: m_lexer.next(); goto state_6783;
	case TType::RParen: m_lexer.next(); goto state_6785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HL Minus
state_6781:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HL Minus RParen
state_6782:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_566;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_566;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HL Plus
state_6783:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6784;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HL Plus RParen
state_6784:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_567;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HL RParen
state_6785:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_568;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_568;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HLD
state_6786:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6787;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HLD RParen
state_6787:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_566;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_566;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HLI
state_6788:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen HLI RParen
state_6789:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_567;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen IX
state_6790:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6791;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6792; }
	/*if (check_expr())*/ goto state_6792;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen IX RParen
state_6791:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_569;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_569;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen IX expr
state_6792:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6793;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen IX expr RParen
state_6793:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_570;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_570;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen IY
state_6794:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6795;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6796; }
	/*if (check_expr())*/ goto state_6796;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen IY RParen
state_6795:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_571;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_571;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen IY expr
state_6796:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6797;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma LParen IY expr RParen
state_6797:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_572;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_572;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD B1 Comma expr
state_6798:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_573;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_573;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC
state_6799:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6800;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC Comma
state_6800:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_6801;
	case Keyword::HL: m_lexer.next(); goto state_6802;
	case Keyword::IX: m_lexer.next(); goto state_6803;
	case Keyword::IY: m_lexer.next(); goto state_6804;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6805; }
	/*if (check_expr())*/ goto state_6805;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC Comma DE
state_6801:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1984;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1984;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC Comma HL
state_6802:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1985;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1985;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC Comma IX
state_6803:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1986;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1986;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC Comma IY
state_6804:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1987;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1987;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC Comma expr
state_6805:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1988;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1988;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC1
state_6806:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6807;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC1 Comma
state_6807:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6808;
	case Keyword::DE: m_lexer.next(); goto state_6809;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6810; }
	/*if (check_expr())*/ goto state_6810;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC1 Comma BC
state_6808:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_574;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC1 Comma DE
state_6809:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_575;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_575;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD BC1 Comma expr
state_6810:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_576;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C
state_6811:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6812;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma
state_6812:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6813;
	case Keyword::B: m_lexer.next(); goto state_6814;
	case Keyword::C: m_lexer.next(); goto state_6815;
	case Keyword::D: m_lexer.next(); goto state_6816;
	case Keyword::E: m_lexer.next(); goto state_6817;
	case Keyword::H: m_lexer.next(); goto state_6818;
	case Keyword::IXH: m_lexer.next(); goto state_6819;
	case Keyword::IXL: m_lexer.next(); goto state_6820;
	case Keyword::IYH: m_lexer.next(); goto state_6821;
	case Keyword::IYL: m_lexer.next(); goto state_6822;
	case Keyword::L: m_lexer.next(); goto state_6823;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6824;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6849; }
	/*if (check_expr())*/ goto state_6849;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma A
state_6813:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1989;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma B
state_6814:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1990;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1990;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma C
state_6815:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1991;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1991;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma D
state_6816:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1992;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1992;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma E
state_6817:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1993;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1993;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma H
state_6818:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1994;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1994;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma IXH
state_6819:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1995;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1995;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma IXL
state_6820:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1996;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1996;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma IYH
state_6821:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1997;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1997;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma IYL
state_6822:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1998;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1998;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma L
state_6823:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1999;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1999;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen
state_6824:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_6825;
	case Keyword::HL: m_lexer.next(); goto state_6831;
	case Keyword::HLD: m_lexer.next(); goto state_6837;
	case Keyword::HLI: m_lexer.next(); goto state_6839;
	case Keyword::IX: m_lexer.next(); goto state_6841;
	case Keyword::IY: m_lexer.next(); goto state_6845;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen DE
state_6825:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6826;
	case TType::Plus: m_lexer.next(); goto state_6828;
	case TType::RParen: m_lexer.next(); goto state_6830;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen DE Minus
state_6826:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6827;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen DE Minus RParen
state_6827:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2000;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2000;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen DE Plus
state_6828:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6829;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen DE Plus RParen
state_6829:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2001;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2001;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen DE RParen
state_6830:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2002;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2002;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HL
state_6831:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6832;
	case TType::Plus: m_lexer.next(); goto state_6834;
	case TType::RParen: m_lexer.next(); goto state_6836;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HL Minus
state_6832:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HL Minus RParen
state_6833:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2003;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2003;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HL Plus
state_6834:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HL Plus RParen
state_6835:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2004;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2004;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HL RParen
state_6836:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2005;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2005;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HLD
state_6837:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HLD RParen
state_6838:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2003;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2003;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HLI
state_6839:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6840;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen HLI RParen
state_6840:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2004;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2004;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen IX
state_6841:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6842;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6843; }
	/*if (check_expr())*/ goto state_6843;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen IX RParen
state_6842:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2006;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2006;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen IX expr
state_6843:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6844;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen IX expr RParen
state_6844:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2007;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2007;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen IY
state_6845:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6846;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6847; }
	/*if (check_expr())*/ goto state_6847;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen IY RParen
state_6846:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2008;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2008;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen IY expr
state_6847:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6848;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma LParen IY expr RParen
state_6848:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2009;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2009;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C Comma expr
state_6849:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2010;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2010;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1
state_6850:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6851;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma
state_6851:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6852;
	case Keyword::B: m_lexer.next(); goto state_6853;
	case Keyword::C: m_lexer.next(); goto state_6854;
	case Keyword::D: m_lexer.next(); goto state_6855;
	case Keyword::E: m_lexer.next(); goto state_6856;
	case Keyword::H: m_lexer.next(); goto state_6857;
	case Keyword::L: m_lexer.next(); goto state_6858;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6859;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6878; }
	/*if (check_expr())*/ goto state_6878;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma A
state_6852:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_577;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma B
state_6853:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_578;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma C
state_6854:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_579;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_579;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma D
state_6855:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_580;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma E
state_6856:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_581;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_581;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma H
state_6857:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_582;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma L
state_6858:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_583;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_583;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen
state_6859:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6860;
	case Keyword::HLD: m_lexer.next(); goto state_6866;
	case Keyword::HLI: m_lexer.next(); goto state_6868;
	case Keyword::IX: m_lexer.next(); goto state_6870;
	case Keyword::IY: m_lexer.next(); goto state_6874;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HL
state_6860:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6861;
	case TType::Plus: m_lexer.next(); goto state_6863;
	case TType::RParen: m_lexer.next(); goto state_6865;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HL Minus
state_6861:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HL Minus RParen
state_6862:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_584;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HL Plus
state_6863:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6864;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HL Plus RParen
state_6864:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_585;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HL RParen
state_6865:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_586;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HLD
state_6866:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6867;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HLD RParen
state_6867:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_584;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HLI
state_6868:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6869;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen HLI RParen
state_6869:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_585;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen IX
state_6870:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6871;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6872; }
	/*if (check_expr())*/ goto state_6872;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen IX RParen
state_6871:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_587;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_587;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen IX expr
state_6872:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6873;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen IX expr RParen
state_6873:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_588;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_588;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen IY
state_6874:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6875;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6876; }
	/*if (check_expr())*/ goto state_6876;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen IY RParen
state_6875:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_589;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen IY expr
state_6876:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6877;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma LParen IY expr RParen
state_6877:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_590;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_590;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD C1 Comma expr
state_6878:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_591;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_591;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D
state_6879:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6880;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma
state_6880:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6881;
	case Keyword::B: m_lexer.next(); goto state_6882;
	case Keyword::C: m_lexer.next(); goto state_6883;
	case Keyword::D: m_lexer.next(); goto state_6884;
	case Keyword::E: m_lexer.next(); goto state_6885;
	case Keyword::H: m_lexer.next(); goto state_6886;
	case Keyword::IXH: m_lexer.next(); goto state_6887;
	case Keyword::IXL: m_lexer.next(); goto state_6888;
	case Keyword::IYH: m_lexer.next(); goto state_6889;
	case Keyword::IYL: m_lexer.next(); goto state_6890;
	case Keyword::L: m_lexer.next(); goto state_6891;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6892;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6917; }
	/*if (check_expr())*/ goto state_6917;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma A
state_6881:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2011;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2011;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma B
state_6882:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2012;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2012;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma C
state_6883:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2013;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2013;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma D
state_6884:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2014;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2014;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma E
state_6885:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2015;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2015;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma H
state_6886:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2016;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2016;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma IXH
state_6887:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2017;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2017;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma IXL
state_6888:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2018;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2018;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma IYH
state_6889:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2019;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2019;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma IYL
state_6890:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2020;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2020;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma L
state_6891:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2021;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2021;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen
state_6892:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_6893;
	case Keyword::HL: m_lexer.next(); goto state_6899;
	case Keyword::HLD: m_lexer.next(); goto state_6905;
	case Keyword::HLI: m_lexer.next(); goto state_6907;
	case Keyword::IX: m_lexer.next(); goto state_6909;
	case Keyword::IY: m_lexer.next(); goto state_6913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen DE
state_6893:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6894;
	case TType::Plus: m_lexer.next(); goto state_6896;
	case TType::RParen: m_lexer.next(); goto state_6898;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen DE Minus
state_6894:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen DE Minus RParen
state_6895:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2022;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2022;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen DE Plus
state_6896:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6897;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen DE Plus RParen
state_6897:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2023;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2023;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen DE RParen
state_6898:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2024;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2024;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HL
state_6899:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6900;
	case TType::Plus: m_lexer.next(); goto state_6902;
	case TType::RParen: m_lexer.next(); goto state_6904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HL Minus
state_6900:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HL Minus RParen
state_6901:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2025;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2025;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HL Plus
state_6902:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HL Plus RParen
state_6903:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2026;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2026;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HL RParen
state_6904:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2027;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2027;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HLD
state_6905:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HLD RParen
state_6906:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2025;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2025;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HLI
state_6907:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen HLI RParen
state_6908:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2026;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2026;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen IX
state_6909:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6910;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6911; }
	/*if (check_expr())*/ goto state_6911;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen IX RParen
state_6910:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2028;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2028;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen IX expr
state_6911:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen IX expr RParen
state_6912:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2029;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2029;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen IY
state_6913:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6914;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6915; }
	/*if (check_expr())*/ goto state_6915;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen IY RParen
state_6914:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2030;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2030;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen IY expr
state_6915:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma LParen IY expr RParen
state_6916:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2031;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2031;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D Comma expr
state_6917:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2032;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2032;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1
state_6918:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6919;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma
state_6919:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6920;
	case Keyword::B: m_lexer.next(); goto state_6921;
	case Keyword::C: m_lexer.next(); goto state_6922;
	case Keyword::D: m_lexer.next(); goto state_6923;
	case Keyword::E: m_lexer.next(); goto state_6924;
	case Keyword::H: m_lexer.next(); goto state_6925;
	case Keyword::L: m_lexer.next(); goto state_6926;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6927;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6946; }
	/*if (check_expr())*/ goto state_6946;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma A
state_6920:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_592;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_592;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma B
state_6921:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_593;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_593;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma C
state_6922:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_594;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_594;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma D
state_6923:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_595;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_595;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma E
state_6924:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_596;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_596;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma H
state_6925:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_597;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_597;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma L
state_6926:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_598;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_598;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen
state_6927:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_6928;
	case Keyword::HLD: m_lexer.next(); goto state_6934;
	case Keyword::HLI: m_lexer.next(); goto state_6936;
	case Keyword::IX: m_lexer.next(); goto state_6938;
	case Keyword::IY: m_lexer.next(); goto state_6942;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HL
state_6928:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6929;
	case TType::Plus: m_lexer.next(); goto state_6931;
	case TType::RParen: m_lexer.next(); goto state_6933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HL Minus
state_6929:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HL Minus RParen
state_6930:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_599;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_599;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HL Plus
state_6931:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HL Plus RParen
state_6932:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_600;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HL RParen
state_6933:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_601;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_601;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HLD
state_6934:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HLD RParen
state_6935:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_599;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_599;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HLI
state_6936:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6937;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen HLI RParen
state_6937:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_600;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen IX
state_6938:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6939;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6940; }
	/*if (check_expr())*/ goto state_6940;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen IX RParen
state_6939:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_602;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_602;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen IX expr
state_6940:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6941;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen IX expr RParen
state_6941:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_603;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_603;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen IY
state_6942:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6943;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6944; }
	/*if (check_expr())*/ goto state_6944;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen IY RParen
state_6943:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_604;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_604;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen IY expr
state_6944:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6945;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma LParen IY expr RParen
state_6945:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_605;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_605;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD D1 Comma expr
state_6946:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_606;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_606;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE
state_6947:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6948;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE Comma
state_6948:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6949;
	case Keyword::HL: m_lexer.next(); goto state_6950;
	case Keyword::IX: m_lexer.next(); goto state_6952;
	case Keyword::IY: m_lexer.next(); goto state_6953;
	case Keyword::SP: m_lexer.next(); goto state_6954;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6956; }
	/*if (check_expr())*/ goto state_6956;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE Comma BC
state_6949:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2033;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2033;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE Comma HL
state_6950:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2034;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2034;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6951; }
	/*if (check_expr())*/ goto state_6951;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE Comma HL expr
state_6951:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2035;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2035;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE Comma IX
state_6952:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2036;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2036;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE Comma IY
state_6953:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2037;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2037;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE Comma SP
state_6954:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2038;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2038;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6955; }
	/*if (check_expr())*/ goto state_6955;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE Comma SP expr
state_6955:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2039;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE Comma expr
state_6956:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2040;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2040;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE1
state_6957:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6958;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE1 Comma
state_6958:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_6959;
	case Keyword::DE: m_lexer.next(); goto state_6960;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6961; }
	/*if (check_expr())*/ goto state_6961;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE1 Comma BC
state_6959:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_607;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_607;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE1 Comma DE
state_6960:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_608;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_608;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD DE1 Comma expr
state_6961:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_609;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_609;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E
state_6962:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_6963;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma
state_6963:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_6964;
	case Keyword::B: m_lexer.next(); goto state_6965;
	case Keyword::C: m_lexer.next(); goto state_6966;
	case Keyword::D: m_lexer.next(); goto state_6967;
	case Keyword::E: m_lexer.next(); goto state_6968;
	case Keyword::H: m_lexer.next(); goto state_6969;
	case Keyword::IXH: m_lexer.next(); goto state_6970;
	case Keyword::IXL: m_lexer.next(); goto state_6971;
	case Keyword::IYH: m_lexer.next(); goto state_6972;
	case Keyword::IYL: m_lexer.next(); goto state_6973;
	case Keyword::L: m_lexer.next(); goto state_6974;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_6975;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7000; }
	/*if (check_expr())*/ goto state_7000;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma A
state_6964:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2041;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2041;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma B
state_6965:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2042;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2042;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma C
state_6966:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2043;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2043;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma D
state_6967:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2044;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2044;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma E
state_6968:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2045;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2045;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma H
state_6969:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2046;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2046;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma IXH
state_6970:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2047;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2047;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma IXL
state_6971:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2048;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2048;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma IYH
state_6972:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2049;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2049;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma IYL
state_6973:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2050;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2050;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma L
state_6974:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2051;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2051;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen
state_6975:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_6976;
	case Keyword::HL: m_lexer.next(); goto state_6982;
	case Keyword::HLD: m_lexer.next(); goto state_6988;
	case Keyword::HLI: m_lexer.next(); goto state_6990;
	case Keyword::IX: m_lexer.next(); goto state_6992;
	case Keyword::IY: m_lexer.next(); goto state_6996;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen DE
state_6976:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6977;
	case TType::Plus: m_lexer.next(); goto state_6979;
	case TType::RParen: m_lexer.next(); goto state_6981;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen DE Minus
state_6977:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen DE Minus RParen
state_6978:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2052;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2052;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen DE Plus
state_6979:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6980;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen DE Plus RParen
state_6980:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2053;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2053;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen DE RParen
state_6981:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2054;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2054;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HL
state_6982:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_6983;
	case TType::Plus: m_lexer.next(); goto state_6985;
	case TType::RParen: m_lexer.next(); goto state_6987;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HL Minus
state_6983:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6984;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HL Minus RParen
state_6984:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2055;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2055;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HL Plus
state_6985:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6986;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HL Plus RParen
state_6986:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2056;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2056;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HL RParen
state_6987:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2057;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2057;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HLD
state_6988:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HLD RParen
state_6989:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2055;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2055;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HLI
state_6990:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6991;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen HLI RParen
state_6991:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2056;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2056;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen IX
state_6992:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6993;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6994; }
	/*if (check_expr())*/ goto state_6994;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen IX RParen
state_6993:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2058;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2058;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen IX expr
state_6994:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6995;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen IX expr RParen
state_6995:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2059;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2059;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen IY
state_6996:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6997;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_6998; }
	/*if (check_expr())*/ goto state_6998;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen IY RParen
state_6997:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2060;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2060;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen IY expr
state_6998:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_6999;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma LParen IY expr RParen
state_6999:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2061;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2061;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E Comma expr
state_7000:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2062;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2062;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1
state_7001:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7002;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma
state_7002:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7003;
	case Keyword::B: m_lexer.next(); goto state_7004;
	case Keyword::C: m_lexer.next(); goto state_7005;
	case Keyword::D: m_lexer.next(); goto state_7006;
	case Keyword::E: m_lexer.next(); goto state_7007;
	case Keyword::H: m_lexer.next(); goto state_7008;
	case Keyword::L: m_lexer.next(); goto state_7009;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7010;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7029; }
	/*if (check_expr())*/ goto state_7029;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma A
state_7003:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_610;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_610;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma B
state_7004:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_611;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma C
state_7005:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_612;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma D
state_7006:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_613;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_613;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma E
state_7007:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_614;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma H
state_7008:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_615;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_615;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma L
state_7009:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_616;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_616;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen
state_7010:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7011;
	case Keyword::HLD: m_lexer.next(); goto state_7017;
	case Keyword::HLI: m_lexer.next(); goto state_7019;
	case Keyword::IX: m_lexer.next(); goto state_7021;
	case Keyword::IY: m_lexer.next(); goto state_7025;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HL
state_7011:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7012;
	case TType::Plus: m_lexer.next(); goto state_7014;
	case TType::RParen: m_lexer.next(); goto state_7016;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HL Minus
state_7012:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7013;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HL Minus RParen
state_7013:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_617;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HL Plus
state_7014:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7015;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HL Plus RParen
state_7015:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_618;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HL RParen
state_7016:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_619;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_619;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HLD
state_7017:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7018;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HLD RParen
state_7018:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_617;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HLI
state_7019:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7020;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen HLI RParen
state_7020:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_618;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen IX
state_7021:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7022;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7023; }
	/*if (check_expr())*/ goto state_7023;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen IX RParen
state_7022:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_620;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_620;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen IX expr
state_7023:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7024;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen IX expr RParen
state_7024:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_621;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_621;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen IY
state_7025:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7026;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7027; }
	/*if (check_expr())*/ goto state_7027;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen IY RParen
state_7026:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_622;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_622;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen IY expr
state_7027:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7028;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma LParen IY expr RParen
state_7028:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_623;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD E1 Comma expr
state_7029:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_624;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_624;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD EIR
state_7030:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7031;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD EIR Comma
state_7031:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7032;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD EIR Comma A
state_7032:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2063;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2063;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H
state_7033:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7034;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma
state_7034:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7035;
	case Keyword::B: m_lexer.next(); goto state_7036;
	case Keyword::C: m_lexer.next(); goto state_7037;
	case Keyword::D: m_lexer.next(); goto state_7038;
	case Keyword::E: m_lexer.next(); goto state_7039;
	case Keyword::H: m_lexer.next(); goto state_7040;
	case Keyword::L: m_lexer.next(); goto state_7041;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7042;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7067; }
	/*if (check_expr())*/ goto state_7067;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma A
state_7035:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2064;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2064;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma B
state_7036:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2065;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2065;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma C
state_7037:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2066;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2066;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma D
state_7038:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2067;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2067;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma E
state_7039:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2068;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2068;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma H
state_7040:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2069;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2069;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma L
state_7041:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2070;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2070;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen
state_7042:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7043;
	case Keyword::HL: m_lexer.next(); goto state_7049;
	case Keyword::HLD: m_lexer.next(); goto state_7055;
	case Keyword::HLI: m_lexer.next(); goto state_7057;
	case Keyword::IX: m_lexer.next(); goto state_7059;
	case Keyword::IY: m_lexer.next(); goto state_7063;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen DE
state_7043:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7044;
	case TType::Plus: m_lexer.next(); goto state_7046;
	case TType::RParen: m_lexer.next(); goto state_7048;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen DE Minus
state_7044:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7045;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen DE Minus RParen
state_7045:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2071;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2071;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen DE Plus
state_7046:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7047;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen DE Plus RParen
state_7047:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2072;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2072;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen DE RParen
state_7048:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2073;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2073;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HL
state_7049:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7050;
	case TType::Plus: m_lexer.next(); goto state_7052;
	case TType::RParen: m_lexer.next(); goto state_7054;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HL Minus
state_7050:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7051;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HL Minus RParen
state_7051:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2074;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2074;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HL Plus
state_7052:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7053;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HL Plus RParen
state_7053:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2075;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HL RParen
state_7054:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2076;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2076;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HLD
state_7055:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7056;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HLD RParen
state_7056:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2074;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2074;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HLI
state_7057:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7058;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen HLI RParen
state_7058:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2075;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen IX
state_7059:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7060;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7061; }
	/*if (check_expr())*/ goto state_7061;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen IX RParen
state_7060:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2077;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2077;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen IX expr
state_7061:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7062;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen IX expr RParen
state_7062:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2078;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2078;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen IY
state_7063:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7064;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7065; }
	/*if (check_expr())*/ goto state_7065;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen IY RParen
state_7064:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2079;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2079;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen IY expr
state_7065:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7066;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma LParen IY expr RParen
state_7066:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2080;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2080;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H Comma expr
state_7067:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2081;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2081;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1
state_7068:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7069;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma
state_7069:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7070;
	case Keyword::B: m_lexer.next(); goto state_7071;
	case Keyword::C: m_lexer.next(); goto state_7072;
	case Keyword::D: m_lexer.next(); goto state_7073;
	case Keyword::E: m_lexer.next(); goto state_7074;
	case Keyword::H: m_lexer.next(); goto state_7075;
	case Keyword::L: m_lexer.next(); goto state_7076;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7077;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7096; }
	/*if (check_expr())*/ goto state_7096;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma A
state_7070:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_625;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_625;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma B
state_7071:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_626;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_626;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma C
state_7072:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_627;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_627;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma D
state_7073:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_628;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_628;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma E
state_7074:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_629;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_629;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma H
state_7075:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_630;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_630;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma L
state_7076:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_631;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_631;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen
state_7077:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7078;
	case Keyword::HLD: m_lexer.next(); goto state_7084;
	case Keyword::HLI: m_lexer.next(); goto state_7086;
	case Keyword::IX: m_lexer.next(); goto state_7088;
	case Keyword::IY: m_lexer.next(); goto state_7092;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HL
state_7078:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7079;
	case TType::Plus: m_lexer.next(); goto state_7081;
	case TType::RParen: m_lexer.next(); goto state_7083;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HL Minus
state_7079:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7080;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HL Minus RParen
state_7080:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_632;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HL Plus
state_7081:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7082;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HL Plus RParen
state_7082:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_633;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HL RParen
state_7083:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_634;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_634;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HLD
state_7084:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HLD RParen
state_7085:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_632;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HLI
state_7086:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7087;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen HLI RParen
state_7087:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_633;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen IX
state_7088:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7089;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7090; }
	/*if (check_expr())*/ goto state_7090;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen IX RParen
state_7089:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_635;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_635;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen IX expr
state_7090:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7091;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen IX expr RParen
state_7091:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_636;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen IY
state_7092:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7093;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7094; }
	/*if (check_expr())*/ goto state_7094;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen IY RParen
state_7093:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_637;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen IY expr
state_7094:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7095;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma LParen IY expr RParen
state_7095:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_638;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_638;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD H1 Comma expr
state_7096:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_639;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL
state_7097:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7098;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma
state_7098:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7099;
	case Keyword::DE: m_lexer.next(); goto state_7100;
	case Keyword::IX: m_lexer.next(); goto state_7101;
	case Keyword::IY: m_lexer.next(); goto state_7102;
	case Keyword::SP: m_lexer.next(); goto state_7103;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7105;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7124; }
	/*if (check_expr())*/ goto state_7124;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma BC
state_7099:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2082;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2082;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma DE
state_7100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2083;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2083;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma IX
state_7101:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2084;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2084;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma IY
state_7102:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2085;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2085;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma SP
state_7103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2086;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2086;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7104; }
	/*if (check_expr())*/ goto state_7104;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma SP expr
state_7104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2087;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2087;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen
state_7105:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7106;
	case Keyword::HL: m_lexer.next(); goto state_7108;
	case Keyword::IX: m_lexer.next(); goto state_7112;
	case Keyword::IY: m_lexer.next(); goto state_7116;
	case Keyword::SP: m_lexer.next(); goto state_7120;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen DE
state_7106:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen DE RParen
state_7107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2088;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2088;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen HL
state_7108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7109;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7110; }
	/*if (check_expr())*/ goto state_7110;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen HL RParen
state_7109:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2089;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2089;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen HL expr
state_7110:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen HL expr RParen
state_7111:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2090;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2090;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen IX
state_7112:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7113;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7114; }
	/*if (check_expr())*/ goto state_7114;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen IX RParen
state_7113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2091;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2091;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen IX expr
state_7114:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen IX expr RParen
state_7115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2092;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2092;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen IY
state_7116:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7117;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7118; }
	/*if (check_expr())*/ goto state_7118;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen IY RParen
state_7117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2093;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2093;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen IY expr
state_7118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7119;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen IY expr RParen
state_7119:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2094;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2094;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen SP
state_7120:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7121;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7122; }
	/*if (check_expr())*/ goto state_7122;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen SP RParen
state_7121:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2095;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2095;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen SP expr
state_7122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7123;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma LParen SP expr RParen
state_7123:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2096;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2096;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL Comma expr
state_7124:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2097;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2097;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1
state_7125:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7126;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma
state_7126:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7127;
	case Keyword::DE: m_lexer.next(); goto state_7128;
	case Keyword::IX: m_lexer.next(); goto state_7129;
	case Keyword::IY: m_lexer.next(); goto state_7130;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7131;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7148; }
	/*if (check_expr())*/ goto state_7148;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma BC
state_7127:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_640;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma DE
state_7128:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_641;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_641;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma IX
state_7129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_642;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_642;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma IY
state_7130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_643;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_643;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen
state_7131:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7132;
	case Keyword::IX: m_lexer.next(); goto state_7136;
	case Keyword::IY: m_lexer.next(); goto state_7140;
	case Keyword::SP: m_lexer.next(); goto state_7144;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen HL
state_7132:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7133;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7134; }
	/*if (check_expr())*/ goto state_7134;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen HL RParen
state_7133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_644;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen HL expr
state_7134:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen HL expr RParen
state_7135:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_645;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_645;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen IX
state_7136:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7137;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7138; }
	/*if (check_expr())*/ goto state_7138;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen IX RParen
state_7137:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_646;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen IX expr
state_7138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen IX expr RParen
state_7139:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_647;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen IY
state_7140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7141;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7142; }
	/*if (check_expr())*/ goto state_7142;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen IY RParen
state_7141:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_648;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_648;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen IY expr
state_7142:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7143;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen IY expr RParen
state_7143:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_649;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen SP
state_7144:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7145;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7146; }
	/*if (check_expr())*/ goto state_7146;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen SP RParen
state_7145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_650;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen SP expr
state_7146:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma LParen SP expr RParen
state_7147:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_651;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_651;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD HL1 Comma expr
state_7148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_652;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_652;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD I
state_7149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7150;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD I Comma
state_7150:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD I Comma A
state_7151:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2098;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2098;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IIR
state_7152:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7153;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IIR Comma
state_7153:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7154;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IIR Comma A
state_7154:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2099;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2099;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX
state_7155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7156;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma
state_7156:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7157;
	case Keyword::DE: m_lexer.next(); goto state_7158;
	case Keyword::HL: m_lexer.next(); goto state_7159;
	case Keyword::IY: m_lexer.next(); goto state_7160;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7161;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7166; }
	/*if (check_expr())*/ goto state_7166;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma BC
state_7157:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2100;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma DE
state_7158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2101;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2101;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma HL
state_7159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2102;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2102;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma IY
state_7160:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2103;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2103;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma LParen
state_7161:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::SP: m_lexer.next(); goto state_7162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma LParen SP
state_7162:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7163;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7164; }
	/*if (check_expr())*/ goto state_7164;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma LParen SP RParen
state_7163:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2104;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma LParen SP expr
state_7164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma LParen SP expr RParen
state_7165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2105;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2105;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IX Comma expr
state_7166:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2106;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2106;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH
state_7167:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH Comma
state_7168:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7169;
	case Keyword::B: m_lexer.next(); goto state_7170;
	case Keyword::C: m_lexer.next(); goto state_7171;
	case Keyword::D: m_lexer.next(); goto state_7172;
	case Keyword::E: m_lexer.next(); goto state_7173;
	case Keyword::IXH: m_lexer.next(); goto state_7174;
	case Keyword::IXL: m_lexer.next(); goto state_7175;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7176; }
	/*if (check_expr())*/ goto state_7176;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH Comma A
state_7169:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2107;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2107;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH Comma B
state_7170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2108;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2108;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH Comma C
state_7171:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2109;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH Comma D
state_7172:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2110;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2110;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH Comma E
state_7173:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2111;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH Comma IXH
state_7174:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2112;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2112;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH Comma IXL
state_7175:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2113;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2113;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXH Comma expr
state_7176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2114;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL
state_7177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7178;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL Comma
state_7178:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7179;
	case Keyword::B: m_lexer.next(); goto state_7180;
	case Keyword::C: m_lexer.next(); goto state_7181;
	case Keyword::D: m_lexer.next(); goto state_7182;
	case Keyword::E: m_lexer.next(); goto state_7183;
	case Keyword::IXH: m_lexer.next(); goto state_7184;
	case Keyword::IXL: m_lexer.next(); goto state_7185;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7186; }
	/*if (check_expr())*/ goto state_7186;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL Comma A
state_7179:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2115;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2115;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL Comma B
state_7180:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2116;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2116;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL Comma C
state_7181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2117;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2117;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL Comma D
state_7182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2118;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2118;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL Comma E
state_7183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2119;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2119;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL Comma IXH
state_7184:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2120;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2120;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL Comma IXL
state_7185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2121;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2121;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IXL Comma expr
state_7186:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2122;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2122;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY
state_7187:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma
state_7188:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7189;
	case Keyword::DE: m_lexer.next(); goto state_7190;
	case Keyword::HL: m_lexer.next(); goto state_7191;
	case Keyword::IX: m_lexer.next(); goto state_7192;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7193;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7198; }
	/*if (check_expr())*/ goto state_7198;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma BC
state_7189:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2123;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2123;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma DE
state_7190:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2124;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2124;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma HL
state_7191:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2125;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2125;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma IX
state_7192:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2126;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2126;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma LParen
state_7193:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::SP: m_lexer.next(); goto state_7194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma LParen SP
state_7194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7195;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7196; }
	/*if (check_expr())*/ goto state_7196;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma LParen SP RParen
state_7195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2127;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2127;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma LParen SP expr
state_7196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma LParen SP expr RParen
state_7197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2128;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2128;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IY Comma expr
state_7198:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2129;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2129;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH
state_7199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH Comma
state_7200:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7201;
	case Keyword::B: m_lexer.next(); goto state_7202;
	case Keyword::C: m_lexer.next(); goto state_7203;
	case Keyword::D: m_lexer.next(); goto state_7204;
	case Keyword::E: m_lexer.next(); goto state_7205;
	case Keyword::IYH: m_lexer.next(); goto state_7206;
	case Keyword::IYL: m_lexer.next(); goto state_7207;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7208; }
	/*if (check_expr())*/ goto state_7208;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH Comma A
state_7201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2130;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2130;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH Comma B
state_7202:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2131;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH Comma C
state_7203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2132;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2132;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH Comma D
state_7204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2133;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2133;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH Comma E
state_7205:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2134;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2134;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH Comma IYH
state_7206:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2135;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2135;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH Comma IYL
state_7207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2136;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2136;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYH Comma expr
state_7208:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2137;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2137;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL
state_7209:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL Comma
state_7210:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7211;
	case Keyword::B: m_lexer.next(); goto state_7212;
	case Keyword::C: m_lexer.next(); goto state_7213;
	case Keyword::D: m_lexer.next(); goto state_7214;
	case Keyword::E: m_lexer.next(); goto state_7215;
	case Keyword::IYH: m_lexer.next(); goto state_7216;
	case Keyword::IYL: m_lexer.next(); goto state_7217;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7218; }
	/*if (check_expr())*/ goto state_7218;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL Comma A
state_7211:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2138;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL Comma B
state_7212:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2139;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2139;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL Comma C
state_7213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2140;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL Comma D
state_7214:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2141;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL Comma E
state_7215:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2142;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2142;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL Comma IYH
state_7216:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2143;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2143;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL Comma IYL
state_7217:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2144;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2144;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD IYL Comma expr
state_7218:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2145;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2145;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L
state_7219:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7220;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma
state_7220:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7221;
	case Keyword::B: m_lexer.next(); goto state_7222;
	case Keyword::C: m_lexer.next(); goto state_7223;
	case Keyword::D: m_lexer.next(); goto state_7224;
	case Keyword::E: m_lexer.next(); goto state_7225;
	case Keyword::H: m_lexer.next(); goto state_7226;
	case Keyword::L: m_lexer.next(); goto state_7227;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7228;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7253; }
	/*if (check_expr())*/ goto state_7253;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma A
state_7221:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2146;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma B
state_7222:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2147;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma C
state_7223:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2148;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2148;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma D
state_7224:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2149;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2149;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma E
state_7225:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2150;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2150;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma H
state_7226:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2151;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma L
state_7227:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2152;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen
state_7228:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7229;
	case Keyword::HL: m_lexer.next(); goto state_7235;
	case Keyword::HLD: m_lexer.next(); goto state_7241;
	case Keyword::HLI: m_lexer.next(); goto state_7243;
	case Keyword::IX: m_lexer.next(); goto state_7245;
	case Keyword::IY: m_lexer.next(); goto state_7249;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen DE
state_7229:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7230;
	case TType::Plus: m_lexer.next(); goto state_7232;
	case TType::RParen: m_lexer.next(); goto state_7234;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen DE Minus
state_7230:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7231;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen DE Minus RParen
state_7231:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2153;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2153;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen DE Plus
state_7232:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7233;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen DE Plus RParen
state_7233:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2154;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2154;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen DE RParen
state_7234:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2155;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2155;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HL
state_7235:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7236;
	case TType::Plus: m_lexer.next(); goto state_7238;
	case TType::RParen: m_lexer.next(); goto state_7240;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HL Minus
state_7236:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7237;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HL Minus RParen
state_7237:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2156;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2156;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HL Plus
state_7238:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7239;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HL Plus RParen
state_7239:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2157;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2157;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HL RParen
state_7240:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2158;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2158;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HLD
state_7241:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7242;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HLD RParen
state_7242:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2156;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2156;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HLI
state_7243:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7244;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen HLI RParen
state_7244:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2157;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2157;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen IX
state_7245:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7246;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7247; }
	/*if (check_expr())*/ goto state_7247;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen IX RParen
state_7246:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2159;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2159;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen IX expr
state_7247:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7248;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen IX expr RParen
state_7248:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2160;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2160;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen IY
state_7249:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7250;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7251; }
	/*if (check_expr())*/ goto state_7251;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen IY RParen
state_7250:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2161;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2161;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen IY expr
state_7251:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7252;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma LParen IY expr RParen
state_7252:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2162;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2162;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L Comma expr
state_7253:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2163;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1
state_7254:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7255;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma
state_7255:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7256;
	case Keyword::B: m_lexer.next(); goto state_7257;
	case Keyword::C: m_lexer.next(); goto state_7258;
	case Keyword::D: m_lexer.next(); goto state_7259;
	case Keyword::E: m_lexer.next(); goto state_7260;
	case Keyword::H: m_lexer.next(); goto state_7261;
	case Keyword::L: m_lexer.next(); goto state_7262;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7263;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7282; }
	/*if (check_expr())*/ goto state_7282;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma A
state_7256:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_653;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_653;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma B
state_7257:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_654;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_654;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma C
state_7258:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_655;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_655;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma D
state_7259:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_656;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma E
state_7260:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_657;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_657;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma H
state_7261:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_658;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma L
state_7262:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_659;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen
state_7263:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7264;
	case Keyword::HLD: m_lexer.next(); goto state_7270;
	case Keyword::HLI: m_lexer.next(); goto state_7272;
	case Keyword::IX: m_lexer.next(); goto state_7274;
	case Keyword::IY: m_lexer.next(); goto state_7278;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HL
state_7264:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7265;
	case TType::Plus: m_lexer.next(); goto state_7267;
	case TType::RParen: m_lexer.next(); goto state_7269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HL Minus
state_7265:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7266;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HL Minus RParen
state_7266:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HL Plus
state_7267:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7268;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HL Plus RParen
state_7268:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HL RParen
state_7269:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_662;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HLD
state_7270:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7271;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HLD RParen
state_7271:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HLI
state_7272:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7273;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen HLI RParen
state_7273:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen IX
state_7274:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7275;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7276; }
	/*if (check_expr())*/ goto state_7276;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen IX RParen
state_7275:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_663;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_663;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen IX expr
state_7276:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7277;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen IX expr RParen
state_7277:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_664;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen IY
state_7278:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7279;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7280; }
	/*if (check_expr())*/ goto state_7280;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen IY RParen
state_7279:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_665;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_665;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen IY expr
state_7280:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma LParen IY expr RParen
state_7281:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_666;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_666;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD L1 Comma expr
state_7282:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_667;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_667;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD R
state_7283:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7284;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD R Comma
state_7284:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7285;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD R Comma A
state_7285:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2164;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2164;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD SP
state_7286:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7287;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD SP Comma
state_7287:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7288;
	case Keyword::IX: m_lexer.next(); goto state_7289;
	case Keyword::IY: m_lexer.next(); goto state_7290;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7291; }
	/*if (check_expr())*/ goto state_7291;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD SP Comma HL
state_7288:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2165;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD SP Comma IX
state_7289:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2166;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD SP Comma IY
state_7290:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2167;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2167;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD SP Comma expr
state_7291:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2168;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2168;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD XPC
state_7292:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7293;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD XPC Comma
state_7293:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7294;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD XPC Comma A
state_7294:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2169;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2169;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen
state_7295:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7296;
	case Keyword::C: m_lexer.next(); goto state_7308;
	case Keyword::DE: m_lexer.next(); goto state_7312;
	case Keyword::HL: m_lexer.next(); goto state_7346;
	case Keyword::HLD: m_lexer.next(); goto state_7388;
	case Keyword::HLI: m_lexer.next(); goto state_7398;
	case Keyword::IX: m_lexer.next(); goto state_7408;
	case Keyword::IY: m_lexer.next(); goto state_7432;
	case Keyword::SP: m_lexer.next(); goto state_7456;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC
state_7296:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7297;
	case TType::Plus: m_lexer.next(); goto state_7301;
	case TType::RParen: m_lexer.next(); goto state_7305;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC Minus
state_7297:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7298;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC Minus RParen
state_7298:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC Minus RParen Comma
state_7299:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC Minus RParen Comma A
state_7300:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2170;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2170;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC Plus
state_7301:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7302;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC Plus RParen
state_7302:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC Plus RParen Comma
state_7303:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7304;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC Plus RParen Comma A
state_7304:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2171;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2171;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC RParen
state_7305:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7306;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC RParen Comma
state_7306:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen BC RParen Comma A
state_7307:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2172;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2172;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen C
state_7308:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7309;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen C RParen
state_7309:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7310;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen C RParen Comma
state_7310:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen C RParen Comma A
state_7311:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2173;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2173;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE
state_7312:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7313;
	case TType::Plus: m_lexer.next(); goto state_7324;
	case TType::RParen: m_lexer.next(); goto state_7335;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus
state_7313:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7314;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen
state_7314:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen Comma
state_7315:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7316;
	case Keyword::B: m_lexer.next(); goto state_7317;
	case Keyword::C: m_lexer.next(); goto state_7318;
	case Keyword::D: m_lexer.next(); goto state_7319;
	case Keyword::E: m_lexer.next(); goto state_7320;
	case Keyword::H: m_lexer.next(); goto state_7321;
	case Keyword::L: m_lexer.next(); goto state_7322;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7323; }
	/*if (check_expr())*/ goto state_7323;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen Comma A
state_7316:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2174;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2174;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen Comma B
state_7317:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2175;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2175;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen Comma C
state_7318:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2176;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2176;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen Comma D
state_7319:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2177;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2177;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen Comma E
state_7320:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2178;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2178;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen Comma H
state_7321:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2179;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2179;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen Comma L
state_7322:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2180;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2180;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Minus RParen Comma expr
state_7323:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2181;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2181;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus
state_7324:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7325;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen
state_7325:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7326;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen Comma
state_7326:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7327;
	case Keyword::B: m_lexer.next(); goto state_7328;
	case Keyword::C: m_lexer.next(); goto state_7329;
	case Keyword::D: m_lexer.next(); goto state_7330;
	case Keyword::E: m_lexer.next(); goto state_7331;
	case Keyword::H: m_lexer.next(); goto state_7332;
	case Keyword::L: m_lexer.next(); goto state_7333;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7334; }
	/*if (check_expr())*/ goto state_7334;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen Comma A
state_7327:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2182;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2182;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen Comma B
state_7328:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2183;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2183;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen Comma C
state_7329:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2184;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen Comma D
state_7330:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2185;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen Comma E
state_7331:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2186;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2186;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen Comma H
state_7332:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2187;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen Comma L
state_7333:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2188;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE Plus RParen Comma expr
state_7334:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2189;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen
state_7335:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7336;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma
state_7336:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7337;
	case Keyword::B: m_lexer.next(); goto state_7338;
	case Keyword::C: m_lexer.next(); goto state_7339;
	case Keyword::D: m_lexer.next(); goto state_7340;
	case Keyword::E: m_lexer.next(); goto state_7341;
	case Keyword::H: m_lexer.next(); goto state_7342;
	case Keyword::HL: m_lexer.next(); goto state_7343;
	case Keyword::L: m_lexer.next(); goto state_7344;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7345; }
	/*if (check_expr())*/ goto state_7345;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma A
state_7337:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2190;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma B
state_7338:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2191;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2191;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma C
state_7339:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2192;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2192;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma D
state_7340:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2193;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2193;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma E
state_7341:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2194;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2194;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma H
state_7342:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2195;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2195;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma HL
state_7343:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2196;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma L
state_7344:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2197;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen DE RParen Comma expr
state_7345:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2198;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2198;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL
state_7346:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7347;
	case TType::Plus: m_lexer.next(); goto state_7358;
	case TType::RParen: m_lexer.next(); goto state_7371;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7384; }
	/*if (check_expr())*/ goto state_7384;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus
state_7347:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen
state_7348:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen Comma
state_7349:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7350;
	case Keyword::B: m_lexer.next(); goto state_7351;
	case Keyword::C: m_lexer.next(); goto state_7352;
	case Keyword::D: m_lexer.next(); goto state_7353;
	case Keyword::E: m_lexer.next(); goto state_7354;
	case Keyword::H: m_lexer.next(); goto state_7355;
	case Keyword::L: m_lexer.next(); goto state_7356;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7357; }
	/*if (check_expr())*/ goto state_7357;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen Comma A
state_7350:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2199;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2199;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen Comma B
state_7351:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2200;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen Comma C
state_7352:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2201;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2201;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen Comma D
state_7353:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2202;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2202;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen Comma E
state_7354:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2203;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen Comma H
state_7355:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2204;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2204;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen Comma L
state_7356:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2205;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Minus RParen Comma expr
state_7357:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2206;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2206;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus
state_7358:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen
state_7359:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7360;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma
state_7360:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7361;
	case Keyword::B: m_lexer.next(); goto state_7362;
	case Keyword::BC: m_lexer.next(); goto state_7363;
	case Keyword::C: m_lexer.next(); goto state_7364;
	case Keyword::D: m_lexer.next(); goto state_7365;
	case Keyword::DE: m_lexer.next(); goto state_7366;
	case Keyword::E: m_lexer.next(); goto state_7367;
	case Keyword::H: m_lexer.next(); goto state_7368;
	case Keyword::L: m_lexer.next(); goto state_7369;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7370; }
	/*if (check_expr())*/ goto state_7370;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma A
state_7361:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2207;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2207;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma B
state_7362:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2208;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2208;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma BC
state_7363:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2209;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2209;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma C
state_7364:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2210;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma D
state_7365:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2211;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma DE
state_7366:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2212;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma E
state_7367:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2213;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma H
state_7368:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2214;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma L
state_7369:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2215;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL Plus RParen Comma expr
state_7370:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2216;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2216;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen
state_7371:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7372;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma
state_7372:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7373;
	case Keyword::B: m_lexer.next(); goto state_7374;
	case Keyword::BC: m_lexer.next(); goto state_7375;
	case Keyword::C: m_lexer.next(); goto state_7376;
	case Keyword::D: m_lexer.next(); goto state_7377;
	case Keyword::DE: m_lexer.next(); goto state_7378;
	case Keyword::E: m_lexer.next(); goto state_7379;
	case Keyword::H: m_lexer.next(); goto state_7380;
	case Keyword::HL: m_lexer.next(); goto state_7381;
	case Keyword::L: m_lexer.next(); goto state_7382;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7383; }
	/*if (check_expr())*/ goto state_7383;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma A
state_7373:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2217;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2217;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma B
state_7374:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2218;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2218;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma BC
state_7375:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2219;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2219;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma C
state_7376:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2220;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2220;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma D
state_7377:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2221;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2221;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma DE
state_7378:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2222;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2222;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma E
state_7379:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2223;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2223;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma H
state_7380:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2224;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2224;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma HL
state_7381:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2225;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2225;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma L
state_7382:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2226;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2226;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL RParen Comma expr
state_7383:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2227;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2227;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL expr
state_7384:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7385;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL expr RParen
state_7385:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7386;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL expr RParen Comma
state_7386:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7387;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HL expr RParen Comma HL
state_7387:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2228;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2228;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD
state_7388:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7389;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD RParen
state_7389:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7390;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD RParen Comma
state_7390:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7391;
	case Keyword::B: m_lexer.next(); goto state_7392;
	case Keyword::C: m_lexer.next(); goto state_7393;
	case Keyword::D: m_lexer.next(); goto state_7394;
	case Keyword::E: m_lexer.next(); goto state_7395;
	case Keyword::H: m_lexer.next(); goto state_7396;
	case Keyword::L: m_lexer.next(); goto state_7397;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD RParen Comma A
state_7391:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2199;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2199;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD RParen Comma B
state_7392:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2200;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD RParen Comma C
state_7393:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2201;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2201;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD RParen Comma D
state_7394:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2202;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2202;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD RParen Comma E
state_7395:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2203;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD RParen Comma H
state_7396:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2204;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2204;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLD RParen Comma L
state_7397:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2205;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI
state_7398:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7399;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI RParen
state_7399:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI RParen Comma
state_7400:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7401;
	case Keyword::B: m_lexer.next(); goto state_7402;
	case Keyword::C: m_lexer.next(); goto state_7403;
	case Keyword::D: m_lexer.next(); goto state_7404;
	case Keyword::E: m_lexer.next(); goto state_7405;
	case Keyword::H: m_lexer.next(); goto state_7406;
	case Keyword::L: m_lexer.next(); goto state_7407;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI RParen Comma A
state_7401:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2207;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2207;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI RParen Comma B
state_7402:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2208;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2208;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI RParen Comma C
state_7403:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2210;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI RParen Comma D
state_7404:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2211;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI RParen Comma E
state_7405:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2213;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI RParen Comma H
state_7406:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2214;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen HLI RParen Comma L
state_7407:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2215;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX
state_7408:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7409;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7420; }
	/*if (check_expr())*/ goto state_7420;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen
state_7409:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7410;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma
state_7410:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7411;
	case Keyword::B: m_lexer.next(); goto state_7412;
	case Keyword::C: m_lexer.next(); goto state_7413;
	case Keyword::D: m_lexer.next(); goto state_7414;
	case Keyword::E: m_lexer.next(); goto state_7415;
	case Keyword::H: m_lexer.next(); goto state_7416;
	case Keyword::HL: m_lexer.next(); goto state_7417;
	case Keyword::L: m_lexer.next(); goto state_7418;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7419; }
	/*if (check_expr())*/ goto state_7419;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma A
state_7411:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2229;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2229;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma B
state_7412:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2230;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2230;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma C
state_7413:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2231;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2231;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma D
state_7414:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2232;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2232;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma E
state_7415:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2233;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2233;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma H
state_7416:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2234;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2234;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma HL
state_7417:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2235;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2235;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma L
state_7418:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2236;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2236;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX RParen Comma expr
state_7419:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2237;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2237;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr
state_7420:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen
state_7421:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7422;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma
state_7422:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7423;
	case Keyword::B: m_lexer.next(); goto state_7424;
	case Keyword::C: m_lexer.next(); goto state_7425;
	case Keyword::D: m_lexer.next(); goto state_7426;
	case Keyword::E: m_lexer.next(); goto state_7427;
	case Keyword::H: m_lexer.next(); goto state_7428;
	case Keyword::HL: m_lexer.next(); goto state_7429;
	case Keyword::L: m_lexer.next(); goto state_7430;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7431; }
	/*if (check_expr())*/ goto state_7431;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma A
state_7423:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2238;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2238;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma B
state_7424:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2239;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2239;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma C
state_7425:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2240;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2240;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma D
state_7426:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2241;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2241;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma E
state_7427:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2242;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2242;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma H
state_7428:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2243;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2243;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma HL
state_7429:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2244;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2244;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma L
state_7430:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2245;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2245;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IX expr RParen Comma expr
state_7431:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2246;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2246;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY
state_7432:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7433;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7444; }
	/*if (check_expr())*/ goto state_7444;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen
state_7433:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7434;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma
state_7434:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7435;
	case Keyword::B: m_lexer.next(); goto state_7436;
	case Keyword::C: m_lexer.next(); goto state_7437;
	case Keyword::D: m_lexer.next(); goto state_7438;
	case Keyword::E: m_lexer.next(); goto state_7439;
	case Keyword::H: m_lexer.next(); goto state_7440;
	case Keyword::HL: m_lexer.next(); goto state_7441;
	case Keyword::L: m_lexer.next(); goto state_7442;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7443; }
	/*if (check_expr())*/ goto state_7443;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma A
state_7435:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2247;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2247;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma B
state_7436:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2248;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2248;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma C
state_7437:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2249;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2249;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma D
state_7438:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2250;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2250;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma E
state_7439:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2251;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2251;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma H
state_7440:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2252;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2252;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma HL
state_7441:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2253;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2253;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma L
state_7442:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2254;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2254;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY RParen Comma expr
state_7443:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2255;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2255;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr
state_7444:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7445;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen
state_7445:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7446;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma
state_7446:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7447;
	case Keyword::B: m_lexer.next(); goto state_7448;
	case Keyword::C: m_lexer.next(); goto state_7449;
	case Keyword::D: m_lexer.next(); goto state_7450;
	case Keyword::E: m_lexer.next(); goto state_7451;
	case Keyword::H: m_lexer.next(); goto state_7452;
	case Keyword::HL: m_lexer.next(); goto state_7453;
	case Keyword::L: m_lexer.next(); goto state_7454;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7455; }
	/*if (check_expr())*/ goto state_7455;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma A
state_7447:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2256;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2256;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma B
state_7448:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2257;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2257;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma C
state_7449:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2258;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2258;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma D
state_7450:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2259;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2259;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma E
state_7451:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2260;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2260;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma H
state_7452:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2261;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma HL
state_7453:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2262;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2262;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma L
state_7454:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2263;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2263;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen IY expr RParen Comma expr
state_7455:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2264;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2264;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP
state_7456:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7457;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7462; }
	/*if (check_expr())*/ goto state_7462;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP RParen
state_7457:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7458;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP RParen Comma
state_7458:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7459;
	case Keyword::IX: m_lexer.next(); goto state_7460;
	case Keyword::IY: m_lexer.next(); goto state_7461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP RParen Comma HL
state_7459:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2265;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2265;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP RParen Comma IX
state_7460:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2266;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2266;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP RParen Comma IY
state_7461:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2267;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2267;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP expr
state_7462:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP expr RParen
state_7463:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP expr RParen Comma
state_7464:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7465;
	case Keyword::IX: m_lexer.next(); goto state_7466;
	case Keyword::IY: m_lexer.next(); goto state_7467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP expr RParen Comma HL
state_7465:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2268;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2268;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP expr RParen Comma IX
state_7466:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2269;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD LParen SP expr RParen Comma IY
state_7467:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2270;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD expr
state_7468:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD expr Comma
state_7469:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7470;
	case Keyword::BC: m_lexer.next(); goto state_7471;
	case Keyword::DE: m_lexer.next(); goto state_7472;
	case Keyword::HL: m_lexer.next(); goto state_7473;
	case Keyword::IX: m_lexer.next(); goto state_7474;
	case Keyword::IY: m_lexer.next(); goto state_7475;
	case Keyword::SP: m_lexer.next(); goto state_7476;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD expr Comma A
state_7470:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2271;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2271;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD expr Comma BC
state_7471:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2272;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2272;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD expr Comma DE
state_7472:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2273;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2273;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD expr Comma HL
state_7473:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2274;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2274;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD expr Comma IX
state_7474:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2275;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2275;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD expr Comma IY
state_7475:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2276;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2276;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LD expr Comma SP
state_7476:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2277;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2277;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDA
state_7477:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7478; }
	/*if (check_expr())*/ goto state_7478;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDA expr
state_7478:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2278;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2278;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDAX
state_7479:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_7480;
	case Keyword::BC: m_lexer.next(); goto state_7481;
	case Keyword::D: m_lexer.next(); goto state_7482;
	case Keyword::DE: m_lexer.next(); goto state_7483;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDAX B
state_7480:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1949;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1949;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDAX BC
state_7481:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1949;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1949;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDAX D
state_7482:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1953;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1953;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDAX DE
state_7483:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1953;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1953;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD
state_7484:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7485;
	case Keyword::B: m_lexer.next(); goto state_7494;
	case Keyword::C: m_lexer.next(); goto state_7501;
	case Keyword::D: m_lexer.next(); goto state_7508;
	case Keyword::E: m_lexer.next(); goto state_7515;
	case Keyword::H: m_lexer.next(); goto state_7522;
	case Keyword::L: m_lexer.next(); goto state_7529;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2279;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2279;
	case TType::LParen: m_lexer.next(); goto state_7536;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD A
state_7485:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD A Comma
state_7486:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7487;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD A Comma LParen
state_7487:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7488;
	case Keyword::DE: m_lexer.next(); goto state_7490;
	case Keyword::HL: m_lexer.next(); goto state_7492;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD A Comma LParen BC
state_7488:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7489;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD A Comma LParen BC RParen
state_7489:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1947;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1947;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD A Comma LParen DE
state_7490:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7491;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD A Comma LParen DE RParen
state_7491:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1951;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1951;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD A Comma LParen HL
state_7492:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7493;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD A Comma LParen HL RParen
state_7493:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1954;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1954;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD B
state_7494:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7495;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD B Comma
state_7495:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7496;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD B Comma LParen
state_7496:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7497;
	case Keyword::HL: m_lexer.next(); goto state_7499;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD B Comma LParen DE
state_7497:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7498;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD B Comma LParen DE RParen
state_7498:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1973;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1973;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD B Comma LParen HL
state_7499:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD B Comma LParen HL RParen
state_7500:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1976;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1976;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD C
state_7501:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7502;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD C Comma
state_7502:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7503;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD C Comma LParen
state_7503:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7504;
	case Keyword::HL: m_lexer.next(); goto state_7506;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD C Comma LParen DE
state_7504:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7505;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD C Comma LParen DE RParen
state_7505:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2000;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2000;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD C Comma LParen HL
state_7506:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7507;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD C Comma LParen HL RParen
state_7507:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2003;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2003;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD D
state_7508:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7509;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD D Comma
state_7509:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7510;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD D Comma LParen
state_7510:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7511;
	case Keyword::HL: m_lexer.next(); goto state_7513;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD D Comma LParen DE
state_7511:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7512;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD D Comma LParen DE RParen
state_7512:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2022;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2022;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD D Comma LParen HL
state_7513:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7514;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD D Comma LParen HL RParen
state_7514:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2025;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2025;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD E
state_7515:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7516;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD E Comma
state_7516:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7517;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD E Comma LParen
state_7517:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7518;
	case Keyword::HL: m_lexer.next(); goto state_7520;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD E Comma LParen DE
state_7518:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7519;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD E Comma LParen DE RParen
state_7519:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2052;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2052;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD E Comma LParen HL
state_7520:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7521;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD E Comma LParen HL RParen
state_7521:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2055;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2055;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD H
state_7522:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD H Comma
state_7523:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD H Comma LParen
state_7524:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7525;
	case Keyword::HL: m_lexer.next(); goto state_7527;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD H Comma LParen DE
state_7525:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7526;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD H Comma LParen DE RParen
state_7526:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2071;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2071;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD H Comma LParen HL
state_7527:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7528;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD H Comma LParen HL RParen
state_7528:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2074;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2074;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD L
state_7529:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7530;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD L Comma
state_7530:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD L Comma LParen
state_7531:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7532;
	case Keyword::HL: m_lexer.next(); goto state_7534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD L Comma LParen DE
state_7532:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7533;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD L Comma LParen DE RParen
state_7533:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2153;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2153;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD L Comma LParen HL
state_7534:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7535;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD L Comma LParen HL RParen
state_7535:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2156;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2156;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen
state_7536:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7537;
	case Keyword::DE: m_lexer.next(); goto state_7541;
	case Keyword::HL: m_lexer.next(); goto state_7552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen BC
state_7537:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7538;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen BC RParen
state_7538:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7539;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen BC RParen Comma
state_7539:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen BC RParen Comma A
state_7540:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2170;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2170;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE
state_7541:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7542;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen
state_7542:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen Comma
state_7543:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7544;
	case Keyword::B: m_lexer.next(); goto state_7545;
	case Keyword::C: m_lexer.next(); goto state_7546;
	case Keyword::D: m_lexer.next(); goto state_7547;
	case Keyword::E: m_lexer.next(); goto state_7548;
	case Keyword::H: m_lexer.next(); goto state_7549;
	case Keyword::L: m_lexer.next(); goto state_7550;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7551; }
	/*if (check_expr())*/ goto state_7551;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen Comma A
state_7544:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2174;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2174;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen Comma B
state_7545:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2175;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2175;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen Comma C
state_7546:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2176;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2176;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen Comma D
state_7547:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2177;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2177;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen Comma E
state_7548:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2178;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2178;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen Comma H
state_7549:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2179;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2179;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen Comma L
state_7550:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2180;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2180;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen DE RParen Comma expr
state_7551:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2181;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2181;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL
state_7552:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7553;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen
state_7553:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7554;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen Comma
state_7554:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7555;
	case Keyword::B: m_lexer.next(); goto state_7556;
	case Keyword::C: m_lexer.next(); goto state_7557;
	case Keyword::D: m_lexer.next(); goto state_7558;
	case Keyword::E: m_lexer.next(); goto state_7559;
	case Keyword::H: m_lexer.next(); goto state_7560;
	case Keyword::L: m_lexer.next(); goto state_7561;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7562; }
	/*if (check_expr())*/ goto state_7562;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen Comma A
state_7555:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2199;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2199;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen Comma B
state_7556:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2200;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen Comma C
state_7557:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2201;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2201;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen Comma D
state_7558:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2202;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2202;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen Comma E
state_7559:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2203;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2203;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen Comma H
state_7560:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2204;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2204;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen Comma L
state_7561:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2205;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2205;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDD LParen HL RParen Comma expr
state_7562:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2206;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2206;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDDR
state_7563:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2280;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2280;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDDRX
state_7564:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2281;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDDSR
state_7565:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2282;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2282;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDDX
state_7566:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2283;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2283;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH
state_7567:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7568;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7574;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7579; }
	/*if (check_expr())*/ goto state_7579;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH A
state_7568:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7569;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH A Comma
state_7569:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7570;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7573; }
	/*if (check_expr())*/ goto state_7573;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH A Comma LParen
state_7570:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_7571;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH A Comma LParen C
state_7571:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7572;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH A Comma LParen C RParen
state_7572:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1950;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1950;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH A Comma expr
state_7573:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2284;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2284;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH LParen
state_7574:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_7575;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH LParen C
state_7575:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH LParen C RParen
state_7576:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH LParen C RParen Comma
state_7577:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH LParen C RParen Comma A
state_7578:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2173;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2173;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH expr
state_7579:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH expr Comma
state_7580:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7581;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDH expr Comma A
state_7581:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2285;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2285;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDHI
state_7582:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7583; }
	/*if (check_expr())*/ goto state_7583;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDHI expr
state_7583:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_99;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_99;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDHL
state_7584:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::SP: m_lexer.next(); goto state_7585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDHL SP
state_7585:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDHL SP Comma
state_7586:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7587; }
	/*if (check_expr())*/ goto state_7587;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDHL SP Comma expr
state_7587:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2286;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2286;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI
state_7588:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7589;
	case Keyword::B: m_lexer.next(); goto state_7598;
	case Keyword::C: m_lexer.next(); goto state_7605;
	case Keyword::D: m_lexer.next(); goto state_7612;
	case Keyword::E: m_lexer.next(); goto state_7619;
	case Keyword::H: m_lexer.next(); goto state_7626;
	case Keyword::L: m_lexer.next(); goto state_7633;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2287;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2287;
	case TType::LParen: m_lexer.next(); goto state_7640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI A
state_7589:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7590;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI A Comma
state_7590:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7591;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI A Comma LParen
state_7591:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7592;
	case Keyword::DE: m_lexer.next(); goto state_7594;
	case Keyword::HL: m_lexer.next(); goto state_7596;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI A Comma LParen BC
state_7592:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7593;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI A Comma LParen BC RParen
state_7593:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1948;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1948;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI A Comma LParen DE
state_7594:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7595;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI A Comma LParen DE RParen
state_7595:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1952;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1952;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI A Comma LParen HL
state_7596:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7597;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI A Comma LParen HL RParen
state_7597:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1955;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1955;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI B
state_7598:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7599;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI B Comma
state_7599:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI B Comma LParen
state_7600:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7601;
	case Keyword::HL: m_lexer.next(); goto state_7603;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI B Comma LParen DE
state_7601:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7602;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI B Comma LParen DE RParen
state_7602:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1974;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1974;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI B Comma LParen HL
state_7603:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7604;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI B Comma LParen HL RParen
state_7604:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1977;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1977;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI C
state_7605:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7606;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI C Comma
state_7606:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7607;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI C Comma LParen
state_7607:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7608;
	case Keyword::HL: m_lexer.next(); goto state_7610;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI C Comma LParen DE
state_7608:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7609;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI C Comma LParen DE RParen
state_7609:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2001;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2001;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI C Comma LParen HL
state_7610:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI C Comma LParen HL RParen
state_7611:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2004;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2004;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI D
state_7612:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7613;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI D Comma
state_7613:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI D Comma LParen
state_7614:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7615;
	case Keyword::HL: m_lexer.next(); goto state_7617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI D Comma LParen DE
state_7615:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7616;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI D Comma LParen DE RParen
state_7616:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2023;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2023;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI D Comma LParen HL
state_7617:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI D Comma LParen HL RParen
state_7618:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2026;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2026;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI E
state_7619:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7620;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI E Comma
state_7620:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7621;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI E Comma LParen
state_7621:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7622;
	case Keyword::HL: m_lexer.next(); goto state_7624;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI E Comma LParen DE
state_7622:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI E Comma LParen DE RParen
state_7623:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2053;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2053;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI E Comma LParen HL
state_7624:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7625;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI E Comma LParen HL RParen
state_7625:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2056;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2056;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI H
state_7626:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7627;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI H Comma
state_7627:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7628;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI H Comma LParen
state_7628:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7629;
	case Keyword::HL: m_lexer.next(); goto state_7631;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI H Comma LParen DE
state_7629:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7630;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI H Comma LParen DE RParen
state_7630:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2072;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2072;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI H Comma LParen HL
state_7631:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI H Comma LParen HL RParen
state_7632:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2075;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2075;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI L
state_7633:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7634;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI L Comma
state_7634:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7635;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI L Comma LParen
state_7635:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7636;
	case Keyword::HL: m_lexer.next(); goto state_7638;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI L Comma LParen DE
state_7636:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI L Comma LParen DE RParen
state_7637:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2154;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2154;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI L Comma LParen HL
state_7638:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI L Comma LParen HL RParen
state_7639:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2157;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2157;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen
state_7640:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7641;
	case Keyword::DE: m_lexer.next(); goto state_7645;
	case Keyword::HL: m_lexer.next(); goto state_7656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen BC
state_7641:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7642;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen BC RParen
state_7642:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7643;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen BC RParen Comma
state_7643:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen BC RParen Comma A
state_7644:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2171;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2171;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE
state_7645:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen
state_7646:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen Comma
state_7647:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7648;
	case Keyword::B: m_lexer.next(); goto state_7649;
	case Keyword::C: m_lexer.next(); goto state_7650;
	case Keyword::D: m_lexer.next(); goto state_7651;
	case Keyword::E: m_lexer.next(); goto state_7652;
	case Keyword::H: m_lexer.next(); goto state_7653;
	case Keyword::L: m_lexer.next(); goto state_7654;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7655; }
	/*if (check_expr())*/ goto state_7655;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen Comma A
state_7648:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2182;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2182;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen Comma B
state_7649:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2183;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2183;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen Comma C
state_7650:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2184;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2184;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen Comma D
state_7651:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2185;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2185;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen Comma E
state_7652:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2186;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2186;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen Comma H
state_7653:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2187;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen Comma L
state_7654:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2188;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2188;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen DE RParen Comma expr
state_7655:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2189;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL
state_7656:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7657;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen
state_7657:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma
state_7658:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7659;
	case Keyword::B: m_lexer.next(); goto state_7660;
	case Keyword::BC: m_lexer.next(); goto state_7661;
	case Keyword::C: m_lexer.next(); goto state_7662;
	case Keyword::D: m_lexer.next(); goto state_7663;
	case Keyword::DE: m_lexer.next(); goto state_7664;
	case Keyword::E: m_lexer.next(); goto state_7665;
	case Keyword::H: m_lexer.next(); goto state_7666;
	case Keyword::L: m_lexer.next(); goto state_7667;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7668; }
	/*if (check_expr())*/ goto state_7668;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma A
state_7659:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2207;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2207;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma B
state_7660:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2208;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2208;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma BC
state_7661:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2209;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2209;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma C
state_7662:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2210;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma D
state_7663:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2211;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2211;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma DE
state_7664:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2212;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2212;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma E
state_7665:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2213;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2213;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma H
state_7666:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2214;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2214;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma L
state_7667:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2215;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDI LParen HL RParen Comma expr
state_7668:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2216;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2216;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDIR
state_7669:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2288;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2288;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDIRX
state_7670:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2289;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2289;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDISR
state_7671:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2290;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2290;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDIX
state_7672:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2291;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2291;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP
state_7673:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7674;
	case Keyword::IX: m_lexer.next(); goto state_7684;
	case Keyword::IY: m_lexer.next(); goto state_7687;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7690;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7703; }
	/*if (check_expr())*/ goto state_7703;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL
state_7674:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7675;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL Comma
state_7675:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7676;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7683; }
	/*if (check_expr())*/ goto state_7683;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL Comma LParen
state_7676:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7677;
	case Keyword::IX: m_lexer.next(); goto state_7679;
	case Keyword::IY: m_lexer.next(); goto state_7681;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL Comma LParen HL
state_7677:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL Comma LParen HL RParen
state_7678:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2292;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2292;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL Comma LParen IX
state_7679:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7680;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL Comma LParen IX RParen
state_7680:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2293;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2293;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL Comma LParen IY
state_7681:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL Comma LParen IY RParen
state_7682:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2294;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2294;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP HL Comma expr
state_7683:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2295;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2295;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP IX
state_7684:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP IX Comma
state_7685:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7686; }
	/*if (check_expr())*/ goto state_7686;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP IX Comma expr
state_7686:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2296;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2296;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP IY
state_7687:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7688;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP IY Comma
state_7688:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7689; }
	/*if (check_expr())*/ goto state_7689;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP IY Comma expr
state_7689:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2297;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2297;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen
state_7690:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7691;
	case Keyword::IX: m_lexer.next(); goto state_7695;
	case Keyword::IY: m_lexer.next(); goto state_7699;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen HL
state_7691:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7692;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen HL RParen
state_7692:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7693;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen HL RParen Comma
state_7693:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen HL RParen Comma HL
state_7694:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2298;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2298;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen IX
state_7695:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7696;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen IX RParen
state_7696:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7697;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen IX RParen Comma
state_7697:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7698;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen IX RParen Comma HL
state_7698:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2299;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2299;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen IY
state_7699:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7700;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen IY RParen
state_7700:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen IY RParen Comma
state_7701:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP LParen IY RParen Comma HL
state_7702:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2300;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2300;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP expr
state_7703:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7704;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP expr Comma
state_7704:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7705;
	case Keyword::IX: m_lexer.next(); goto state_7706;
	case Keyword::IY: m_lexer.next(); goto state_7707;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP expr Comma HL
state_7705:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2301;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2301;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP expr Comma IX
state_7706:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2302;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2302;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDP expr Comma IY
state_7707:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2303;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2303;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDPIRX
state_7708:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2304;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2304;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDRX
state_7709:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2281;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDSI
state_7710:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7711; }
	/*if (check_expr())*/ goto state_7711;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDSI expr
state_7711:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_100;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_100;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LDWS
state_7712:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2305;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2305;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LHLD
state_7713:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7714; }
	/*if (check_expr())*/ goto state_7714;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LHLD expr
state_7714:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2306;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2306;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LHLDE
state_7715:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2088;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2088;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LHLX
state_7716:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2088;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2088;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LIRX
state_7717:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2289;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2289;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LPRX
state_7718:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2304;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2304;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LSDDR
state_7719:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2307;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2307;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LSDR
state_7720:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2308;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2308;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LSIDR
state_7721:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2309;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2309;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LSIR
state_7722:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2310;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2310;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI
state_7723:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_7724;
	case Keyword::BC: m_lexer.next(); goto state_7727;
	case Keyword::D: m_lexer.next(); goto state_7730;
	case Keyword::DE: m_lexer.next(); goto state_7733;
	case Keyword::H: m_lexer.next(); goto state_7736;
	case Keyword::HL: m_lexer.next(); goto state_7739;
	case Keyword::SP: m_lexer.next(); goto state_7742;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI B
state_7724:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7725;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI B Comma
state_7725:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7726; }
	/*if (check_expr())*/ goto state_7726;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI B Comma expr
state_7726:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2311;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI BC
state_7727:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7728;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI BC Comma
state_7728:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7729; }
	/*if (check_expr())*/ goto state_7729;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI BC Comma expr
state_7729:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2311;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2311;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI D
state_7730:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7731;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI D Comma
state_7731:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7732; }
	/*if (check_expr())*/ goto state_7732;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI D Comma expr
state_7732:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2312;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2312;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI DE
state_7733:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7734;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI DE Comma
state_7734:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7735; }
	/*if (check_expr())*/ goto state_7735;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI DE Comma expr
state_7735:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2312;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2312;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI H
state_7736:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7737;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI H Comma
state_7737:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7738; }
	/*if (check_expr())*/ goto state_7738;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI H Comma expr
state_7738:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2313;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2313;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI HL
state_7739:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI HL Comma
state_7740:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7741; }
	/*if (check_expr())*/ goto state_7741;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI HL Comma expr
state_7741:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2313;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2313;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI SP
state_7742:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7743;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI SP Comma
state_7743:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7744; }
	/*if (check_expr())*/ goto state_7744;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: LXI SP Comma expr
state_7744:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2314;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2314;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MIRR
state_7745:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7746;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MIRR A
state_7746:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2315;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MIRROR
state_7747:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7748;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MIRROR A
state_7748:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2315;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2315;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MLT
state_7749:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_7750;
	case Keyword::DE: m_lexer.next(); goto state_7751;
	case Keyword::HL: m_lexer.next(); goto state_7752;
	case Keyword::SP: m_lexer.next(); goto state_7753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MLT BC
state_7750:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2316;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2316;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MLT DE
state_7751:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2317;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2317;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MLT HL
state_7752:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2318;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2318;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MLT SP
state_7753:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2319;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2319;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU
state_7754:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7755; }
	/*if (check_const_expr())*/ goto state_7755;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU const_expr
state_7755:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU const_expr Comma
state_7756:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7757;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7758; }
	/*if (check_expr())*/ goto state_7758;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU const_expr Comma A
state_7757:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2320;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2320;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU const_expr Comma expr
state_7758:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2321;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2321;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU0
state_7759:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7760;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7761; }
	/*if (check_expr())*/ goto state_7761;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU0 A
state_7760:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2322;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2322;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU0 expr
state_7761:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2323;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2323;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU1
state_7762:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7763;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7764; }
	/*if (check_expr())*/ goto state_7764;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU1 A
state_7763:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2324;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2324;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU1 expr
state_7764:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2325;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2325;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU2
state_7765:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7766;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7767; }
	/*if (check_expr())*/ goto state_7767;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU2 A
state_7766:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2326;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2326;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU2 expr
state_7767:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2327;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2327;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU3
state_7768:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7769;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7770; }
	/*if (check_expr())*/ goto state_7770;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU3 A
state_7769:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2328;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2328;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU3 expr
state_7770:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2329;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2329;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU4
state_7771:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7772;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7773; }
	/*if (check_expr())*/ goto state_7773;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU4 A
state_7772:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2330;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2330;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU4 expr
state_7773:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2331;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2331;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU5
state_7774:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7775;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7776; }
	/*if (check_expr())*/ goto state_7776;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU5 A
state_7775:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2332;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2332;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU5 expr
state_7776:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2333;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2333;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU6
state_7777:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7778;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7779; }
	/*if (check_expr())*/ goto state_7779;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU6 A
state_7778:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2334;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2334;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU6 expr
state_7779:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2335;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2335;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU7
state_7780:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7781;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7782; }
	/*if (check_expr())*/ goto state_7782;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU7 A
state_7781:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2336;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2336;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MMU7 expr
state_7782:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2337;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2337;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV
state_7783:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7784;
	case Keyword::B: m_lexer.next(); goto state_7794;
	case Keyword::C: m_lexer.next(); goto state_7804;
	case Keyword::D: m_lexer.next(); goto state_7814;
	case Keyword::E: m_lexer.next(); goto state_7824;
	case Keyword::H: m_lexer.next(); goto state_7834;
	case Keyword::L: m_lexer.next(); goto state_7844;
	case Keyword::M: m_lexer.next(); goto state_7854;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A
state_7784:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A Comma
state_7785:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7786;
	case Keyword::B: m_lexer.next(); goto state_7787;
	case Keyword::C: m_lexer.next(); goto state_7788;
	case Keyword::D: m_lexer.next(); goto state_7789;
	case Keyword::E: m_lexer.next(); goto state_7790;
	case Keyword::H: m_lexer.next(); goto state_7791;
	case Keyword::L: m_lexer.next(); goto state_7792;
	case Keyword::M: m_lexer.next(); goto state_7793;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A Comma A
state_7786:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1931;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A Comma B
state_7787:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1932;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A Comma C
state_7788:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1933;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A Comma D
state_7789:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1934;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A Comma E
state_7790:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1935;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A Comma H
state_7791:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1937;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1937;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A Comma L
state_7792:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1944;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1944;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV A Comma M
state_7793:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1956;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1956;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B
state_7794:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7795;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B Comma
state_7795:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7796;
	case Keyword::B: m_lexer.next(); goto state_7797;
	case Keyword::C: m_lexer.next(); goto state_7798;
	case Keyword::D: m_lexer.next(); goto state_7799;
	case Keyword::E: m_lexer.next(); goto state_7800;
	case Keyword::H: m_lexer.next(); goto state_7801;
	case Keyword::L: m_lexer.next(); goto state_7802;
	case Keyword::M: m_lexer.next(); goto state_7803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B Comma A
state_7796:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1962;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1962;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B Comma B
state_7797:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1963;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1963;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B Comma C
state_7798:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1964;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1964;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B Comma D
state_7799:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1965;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1965;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B Comma E
state_7800:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1966;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1966;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B Comma H
state_7801:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1967;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1967;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B Comma L
state_7802:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1972;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1972;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV B Comma M
state_7803:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1978;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1978;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C
state_7804:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7805;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C Comma
state_7805:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7806;
	case Keyword::B: m_lexer.next(); goto state_7807;
	case Keyword::C: m_lexer.next(); goto state_7808;
	case Keyword::D: m_lexer.next(); goto state_7809;
	case Keyword::E: m_lexer.next(); goto state_7810;
	case Keyword::H: m_lexer.next(); goto state_7811;
	case Keyword::L: m_lexer.next(); goto state_7812;
	case Keyword::M: m_lexer.next(); goto state_7813;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C Comma A
state_7806:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1989;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C Comma B
state_7807:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1990;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1990;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C Comma C
state_7808:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1991;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1991;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C Comma D
state_7809:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1992;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1992;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C Comma E
state_7810:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1993;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1993;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C Comma H
state_7811:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1994;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1994;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C Comma L
state_7812:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1999;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1999;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV C Comma M
state_7813:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2005;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2005;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D
state_7814:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D Comma
state_7815:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7816;
	case Keyword::B: m_lexer.next(); goto state_7817;
	case Keyword::C: m_lexer.next(); goto state_7818;
	case Keyword::D: m_lexer.next(); goto state_7819;
	case Keyword::E: m_lexer.next(); goto state_7820;
	case Keyword::H: m_lexer.next(); goto state_7821;
	case Keyword::L: m_lexer.next(); goto state_7822;
	case Keyword::M: m_lexer.next(); goto state_7823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D Comma A
state_7816:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2011;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2011;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D Comma B
state_7817:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2012;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2012;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D Comma C
state_7818:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2013;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2013;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D Comma D
state_7819:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2014;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2014;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D Comma E
state_7820:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2015;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2015;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D Comma H
state_7821:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2016;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2016;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D Comma L
state_7822:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2021;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2021;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV D Comma M
state_7823:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2027;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2027;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E
state_7824:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7825;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E Comma
state_7825:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7826;
	case Keyword::B: m_lexer.next(); goto state_7827;
	case Keyword::C: m_lexer.next(); goto state_7828;
	case Keyword::D: m_lexer.next(); goto state_7829;
	case Keyword::E: m_lexer.next(); goto state_7830;
	case Keyword::H: m_lexer.next(); goto state_7831;
	case Keyword::L: m_lexer.next(); goto state_7832;
	case Keyword::M: m_lexer.next(); goto state_7833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E Comma A
state_7826:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2041;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2041;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E Comma B
state_7827:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2042;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2042;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E Comma C
state_7828:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2043;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2043;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E Comma D
state_7829:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2044;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2044;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E Comma E
state_7830:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2045;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2045;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E Comma H
state_7831:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2046;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2046;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E Comma L
state_7832:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2051;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2051;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV E Comma M
state_7833:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2057;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2057;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H
state_7834:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H Comma
state_7835:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7836;
	case Keyword::B: m_lexer.next(); goto state_7837;
	case Keyword::C: m_lexer.next(); goto state_7838;
	case Keyword::D: m_lexer.next(); goto state_7839;
	case Keyword::E: m_lexer.next(); goto state_7840;
	case Keyword::H: m_lexer.next(); goto state_7841;
	case Keyword::L: m_lexer.next(); goto state_7842;
	case Keyword::M: m_lexer.next(); goto state_7843;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H Comma A
state_7836:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2064;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2064;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H Comma B
state_7837:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2065;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2065;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H Comma C
state_7838:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2066;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2066;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H Comma D
state_7839:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2067;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2067;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H Comma E
state_7840:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2068;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2068;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H Comma H
state_7841:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2069;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2069;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H Comma L
state_7842:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2070;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2070;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV H Comma M
state_7843:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2076;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2076;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L
state_7844:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7845;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L Comma
state_7845:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7846;
	case Keyword::B: m_lexer.next(); goto state_7847;
	case Keyword::C: m_lexer.next(); goto state_7848;
	case Keyword::D: m_lexer.next(); goto state_7849;
	case Keyword::E: m_lexer.next(); goto state_7850;
	case Keyword::H: m_lexer.next(); goto state_7851;
	case Keyword::L: m_lexer.next(); goto state_7852;
	case Keyword::M: m_lexer.next(); goto state_7853;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L Comma A
state_7846:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2146;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L Comma B
state_7847:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2147;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2147;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L Comma C
state_7848:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2148;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2148;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L Comma D
state_7849:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2149;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2149;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L Comma E
state_7850:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2150;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2150;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L Comma H
state_7851:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2151;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L Comma L
state_7852:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2152;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV L Comma M
state_7853:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2158;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2158;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV M
state_7854:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7855;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV M Comma
state_7855:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7856;
	case Keyword::B: m_lexer.next(); goto state_7857;
	case Keyword::C: m_lexer.next(); goto state_7858;
	case Keyword::D: m_lexer.next(); goto state_7859;
	case Keyword::E: m_lexer.next(); goto state_7860;
	case Keyword::H: m_lexer.next(); goto state_7861;
	case Keyword::L: m_lexer.next(); goto state_7862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV M Comma A
state_7856:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2217;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2217;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV M Comma B
state_7857:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2218;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2218;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV M Comma C
state_7858:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2220;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2220;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV M Comma D
state_7859:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2221;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2221;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV M Comma E
state_7860:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2223;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2223;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV M Comma H
state_7861:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2224;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2224;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MOV M Comma L
state_7862:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2226;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2226;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MUL
state_7863:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::D: m_lexer.next(); goto state_7864;
	case Keyword::DE: m_lexer.next(); goto state_7867;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2339;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2339;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MUL D
state_7864:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7865;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MUL D Comma
state_7865:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::E: m_lexer.next(); goto state_7866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MUL D Comma E
state_7866:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2338;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2338;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MUL DE
state_7867:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2338;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2338;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI
state_7868:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7869;
	case Keyword::B: m_lexer.next(); goto state_7872;
	case Keyword::C: m_lexer.next(); goto state_7875;
	case Keyword::D: m_lexer.next(); goto state_7878;
	case Keyword::E: m_lexer.next(); goto state_7881;
	case Keyword::H: m_lexer.next(); goto state_7884;
	case Keyword::L: m_lexer.next(); goto state_7887;
	case Keyword::M: m_lexer.next(); goto state_7890;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI A
state_7869:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7870;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI A Comma
state_7870:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7871; }
	/*if (check_expr())*/ goto state_7871;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI A Comma expr
state_7871:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2340;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2340;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI B
state_7872:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7873;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI B Comma
state_7873:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7874; }
	/*if (check_expr())*/ goto state_7874;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI B Comma expr
state_7874:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1983;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1983;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI C
state_7875:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7876;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI C Comma
state_7876:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7877; }
	/*if (check_expr())*/ goto state_7877;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI C Comma expr
state_7877:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2010;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2010;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI D
state_7878:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7879;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI D Comma
state_7879:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7880; }
	/*if (check_expr())*/ goto state_7880;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI D Comma expr
state_7880:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2032;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2032;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI E
state_7881:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7882;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI E Comma
state_7882:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7883; }
	/*if (check_expr())*/ goto state_7883;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI E Comma expr
state_7883:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2062;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2062;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI H
state_7884:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7885;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI H Comma
state_7885:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7886; }
	/*if (check_expr())*/ goto state_7886;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI H Comma expr
state_7886:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2081;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2081;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI L
state_7887:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI L Comma
state_7888:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7889; }
	/*if (check_expr())*/ goto state_7889;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI L Comma expr
state_7889:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2163;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI M
state_7890:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7891;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI M Comma
state_7891:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7892; }
	/*if (check_expr())*/ goto state_7892;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: MVI M Comma expr
state_7892:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2227;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2227;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NEG
state_7893:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7894;
	case Keyword::A1: m_lexer.next(); goto state_7895;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2341;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2341;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NEG A
state_7894:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2341;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2341;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NEG A1
state_7895:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_668;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_668;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NEXTREG
state_7896:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7897; }
	/*if (check_expr())*/ goto state_7897;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: NEXTREG expr
state_7897:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7898;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NEXTREG expr Comma
state_7898:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7899;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7900; }
	/*if (check_expr())*/ goto state_7900;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: NEXTREG expr Comma A
state_7899:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2342;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2342;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NEXTREG expr Comma expr
state_7900:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2343;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2343;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NOP
state_7901:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2344;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2344;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NREG
state_7902:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7903; }
	/*if (check_expr())*/ goto state_7903;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: NREG expr
state_7903:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NREG expr Comma
state_7904:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7905;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7906; }
	/*if (check_expr())*/ goto state_7906;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: NREG expr Comma A
state_7905:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2342;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2342;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: NREG expr Comma expr
state_7906:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2343;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2343;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR
state_7907:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7908;
	case Keyword::A1: m_lexer.next(); goto state_7937;
	case Keyword::B: m_lexer.next(); goto state_7962;
	case Keyword::C: m_lexer.next(); goto state_7963;
	case Keyword::D: m_lexer.next(); goto state_7964;
	case Keyword::E: m_lexer.next(); goto state_7965;
	case Keyword::H: m_lexer.next(); goto state_7966;
	case Keyword::HL: m_lexer.next(); goto state_7967;
	case Keyword::HL1: m_lexer.next(); goto state_7970;
	case Keyword::IX: m_lexer.next(); goto state_7973;
	case Keyword::IXH: m_lexer.next(); goto state_7976;
	case Keyword::IXL: m_lexer.next(); goto state_7977;
	case Keyword::IY: m_lexer.next(); goto state_7978;
	case Keyword::IYH: m_lexer.next(); goto state_7981;
	case Keyword::IYL: m_lexer.next(); goto state_7982;
	case Keyword::L: m_lexer.next(); goto state_7983;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7984;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7999; }
	/*if (check_expr())*/ goto state_7999;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A
state_7908:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7909;
	case TType::End: goto action_2345;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2345;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma
state_7909:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7910;
	case Keyword::B: m_lexer.next(); goto state_7911;
	case Keyword::C: m_lexer.next(); goto state_7912;
	case Keyword::D: m_lexer.next(); goto state_7913;
	case Keyword::E: m_lexer.next(); goto state_7914;
	case Keyword::H: m_lexer.next(); goto state_7915;
	case Keyword::IXH: m_lexer.next(); goto state_7916;
	case Keyword::IXL: m_lexer.next(); goto state_7917;
	case Keyword::IYH: m_lexer.next(); goto state_7918;
	case Keyword::IYL: m_lexer.next(); goto state_7919;
	case Keyword::L: m_lexer.next(); goto state_7920;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7921;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7936; }
	/*if (check_expr())*/ goto state_7936;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma A
state_7910:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2345;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2345;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma B
state_7911:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2346;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2346;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma C
state_7912:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2347;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2347;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma D
state_7913:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2348;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma E
state_7914:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2349;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma H
state_7915:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2350;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2350;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma IXH
state_7916:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2351;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma IXL
state_7917:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2352;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2352;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma IYH
state_7918:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2353;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2353;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma IYL
state_7919:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2354;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2354;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma L
state_7920:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2355;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2355;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen
state_7921:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7922;
	case Keyword::IX: m_lexer.next(); goto state_7928;
	case Keyword::IY: m_lexer.next(); goto state_7932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen HL
state_7922:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7923;
	case TType::Plus: m_lexer.next(); goto state_7925;
	case TType::RParen: m_lexer.next(); goto state_7927;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen HL Minus
state_7923:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen HL Minus RParen
state_7924:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2356;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2356;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen HL Plus
state_7925:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen HL Plus RParen
state_7926:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2357;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen HL RParen
state_7927:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2358;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen IX
state_7928:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7929;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7930; }
	/*if (check_expr())*/ goto state_7930;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen IX RParen
state_7929:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2359;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen IX expr
state_7930:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen IX expr RParen
state_7931:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2360;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2360;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen IY
state_7932:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7933;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7934; }
	/*if (check_expr())*/ goto state_7934;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen IY RParen
state_7933:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2361;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2361;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen IY expr
state_7934:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma LParen IY expr RParen
state_7935:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2362;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2362;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A Comma expr
state_7936:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2363;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1
state_7937:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7938;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma
state_7938:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_7939;
	case Keyword::B: m_lexer.next(); goto state_7940;
	case Keyword::C: m_lexer.next(); goto state_7941;
	case Keyword::D: m_lexer.next(); goto state_7942;
	case Keyword::E: m_lexer.next(); goto state_7943;
	case Keyword::H: m_lexer.next(); goto state_7944;
	case Keyword::L: m_lexer.next(); goto state_7945;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_7946;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7961; }
	/*if (check_expr())*/ goto state_7961;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma A
state_7939:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_669;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_669;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma B
state_7940:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_670;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_670;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma C
state_7941:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_671;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_671;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma D
state_7942:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_672;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_672;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma E
state_7943:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_673;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma H
state_7944:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_674;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_674;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma L
state_7945:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_675;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_675;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen
state_7946:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7947;
	case Keyword::IX: m_lexer.next(); goto state_7953;
	case Keyword::IY: m_lexer.next(); goto state_7957;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen HL
state_7947:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7948;
	case TType::Plus: m_lexer.next(); goto state_7950;
	case TType::RParen: m_lexer.next(); goto state_7952;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen HL Minus
state_7948:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7949;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen HL Minus RParen
state_7949:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_676;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_676;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen HL Plus
state_7950:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7951;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen HL Plus RParen
state_7951:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_677;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_677;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen HL RParen
state_7952:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_678;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen IX
state_7953:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7954;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7955; }
	/*if (check_expr())*/ goto state_7955;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen IX RParen
state_7954:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_679;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen IX expr
state_7955:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7956;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen IX expr RParen
state_7956:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_680;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_680;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen IY
state_7957:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7958;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7959; }
	/*if (check_expr())*/ goto state_7959;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen IY RParen
state_7958:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_681;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_681;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen IY expr
state_7959:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7960;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma LParen IY expr RParen
state_7960:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_682;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR A1 Comma expr
state_7961:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_683;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_683;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR B
state_7962:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2346;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2346;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR C
state_7963:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2347;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2347;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR D
state_7964:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2348;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR E
state_7965:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2349;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR H
state_7966:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2350;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2350;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR HL
state_7967:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7968;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR HL Comma
state_7968:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7969;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR HL Comma DE
state_7969:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2364;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2364;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR HL1
state_7970:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7971;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR HL1 Comma
state_7971:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7972;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR HL1 Comma DE
state_7972:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_684;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_684;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IX
state_7973:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7974;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IX Comma
state_7974:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7975;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IX Comma DE
state_7975:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2365;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2365;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IXH
state_7976:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2351;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2351;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IXL
state_7977:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2352;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2352;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IY
state_7978:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_7979;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IY Comma
state_7979:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::DE: m_lexer.next(); goto state_7980;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IY Comma DE
state_7980:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2366;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2366;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IYH
state_7981:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2353;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2353;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR IYL
state_7982:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2354;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2354;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR L
state_7983:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2355;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2355;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen
state_7984:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_7985;
	case Keyword::IX: m_lexer.next(); goto state_7991;
	case Keyword::IY: m_lexer.next(); goto state_7995;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen HL
state_7985:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_7986;
	case TType::Plus: m_lexer.next(); goto state_7988;
	case TType::RParen: m_lexer.next(); goto state_7990;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen HL Minus
state_7986:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7987;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen HL Minus RParen
state_7987:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2356;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2356;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen HL Plus
state_7988:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen HL Plus RParen
state_7989:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2357;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen HL RParen
state_7990:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2358;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen IX
state_7991:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7992;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7993; }
	/*if (check_expr())*/ goto state_7993;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen IX RParen
state_7992:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2359;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen IX expr
state_7993:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7994;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen IX expr RParen
state_7994:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2360;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2360;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen IY
state_7995:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7996;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_7997; }
	/*if (check_expr())*/ goto state_7997;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen IY RParen
state_7996:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2361;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2361;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen IY expr
state_7997:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_7998;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR LParen IY expr RParen
state_7998:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2362;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2362;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OR expr
state_7999:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2363;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORA
state_8000:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8001;
	case Keyword::B: m_lexer.next(); goto state_8002;
	case Keyword::C: m_lexer.next(); goto state_8003;
	case Keyword::D: m_lexer.next(); goto state_8004;
	case Keyword::E: m_lexer.next(); goto state_8005;
	case Keyword::H: m_lexer.next(); goto state_8006;
	case Keyword::L: m_lexer.next(); goto state_8007;
	case Keyword::M: m_lexer.next(); goto state_8008;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORA A
state_8001:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2345;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2345;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORA B
state_8002:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2346;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2346;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORA C
state_8003:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2347;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2347;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORA D
state_8004:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2348;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORA E
state_8005:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2349;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2349;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORA H
state_8006:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2350;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2350;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORA L
state_8007:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2355;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2355;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORA M
state_8008:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2358;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2358;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORG
state_8009:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8010; }
	/*if (check_expr())*/ goto state_8010;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORG expr
state_8010:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_958;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_958;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORI
state_8011:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8012; }
	/*if (check_expr())*/ goto state_8012;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: ORI expr
state_8012:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2363;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2363;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OTDM
state_8013:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2367;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2367;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OTDMR
state_8014:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2368;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2368;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OTDR
state_8015:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2369;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2369;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OTIB
state_8016:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2370;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2370;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OTIM
state_8017:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2371;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2371;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OTIMR
state_8018:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2372;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2372;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OTIR
state_8019:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2373;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2373;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT
state_8020:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8021;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8034; }
	/*if (check_expr())*/ goto state_8034;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen
state_8021:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_8022;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C
state_8022:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8023;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen
state_8023:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8024;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma
state_8024:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8025;
	case Keyword::B: m_lexer.next(); goto state_8026;
	case Keyword::C: m_lexer.next(); goto state_8027;
	case Keyword::D: m_lexer.next(); goto state_8028;
	case Keyword::E: m_lexer.next(); goto state_8029;
	case Keyword::F: m_lexer.next(); goto state_8030;
	case Keyword::H: m_lexer.next(); goto state_8031;
	case Keyword::L: m_lexer.next(); goto state_8032;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8033; }
	/*if (check_const_expr())*/ goto state_8033;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma A
state_8025:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2374;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2374;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma B
state_8026:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2375;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2375;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma C
state_8027:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2376;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2376;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma D
state_8028:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2377;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2377;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma E
state_8029:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2378;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2378;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma F
state_8030:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2379;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2379;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma H
state_8031:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2380;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2380;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma L
state_8032:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2381;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2381;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT LParen C RParen Comma const_expr
state_8033:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2382;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2382;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT expr
state_8034:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8035;
	case TType::End: goto action_2384;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2384;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT expr Comma
state_8035:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8036;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT expr Comma A
state_8036:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2383;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2383;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0
state_8037:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8038; }
	/*if (check_expr())*/ goto state_8038;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0 expr
state_8038:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0 expr Comma
state_8039:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8040;
	case Keyword::B: m_lexer.next(); goto state_8041;
	case Keyword::C: m_lexer.next(); goto state_8042;
	case Keyword::D: m_lexer.next(); goto state_8043;
	case Keyword::E: m_lexer.next(); goto state_8044;
	case Keyword::H: m_lexer.next(); goto state_8045;
	case Keyword::L: m_lexer.next(); goto state_8046;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0 expr Comma A
state_8040:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2385;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2385;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0 expr Comma B
state_8041:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2386;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2386;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0 expr Comma C
state_8042:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2387;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2387;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0 expr Comma D
state_8043:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2388;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2388;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0 expr Comma E
state_8044:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2389;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2389;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0 expr Comma H
state_8045:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2390;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2390;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUT0 expr Comma L
state_8046:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2391;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2391;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUTD
state_8047:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2392;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2392;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUTI
state_8048:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2393;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2393;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OUTINB
state_8049:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2370;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2370;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: OVRST8
state_8050:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2394;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2394;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PCHL
state_8051:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_1923;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_1923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PIXELAD
state_8052:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2395;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2395;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PIXELDN
state_8053:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2396;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2396;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP
state_8054:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::AF: m_lexer.next(); goto state_8055;
	case Keyword::AF1: m_lexer.next(); goto state_8056;
	case Keyword::B: m_lexer.next(); goto state_8057;
	case Keyword::BC: m_lexer.next(); goto state_8058;
	case Keyword::BC1: m_lexer.next(); goto state_8059;
	case Keyword::D: m_lexer.next(); goto state_8060;
	case Keyword::DE: m_lexer.next(); goto state_8061;
	case Keyword::DE1: m_lexer.next(); goto state_8062;
	case Keyword::H: m_lexer.next(); goto state_8063;
	case Keyword::HL: m_lexer.next(); goto state_8064;
	case Keyword::HL1: m_lexer.next(); goto state_8065;
	case Keyword::IP: m_lexer.next(); goto state_8066;
	case Keyword::IX: m_lexer.next(); goto state_8067;
	case Keyword::IY: m_lexer.next(); goto state_8068;
	case Keyword::PSW: m_lexer.next(); goto state_8069;
	case Keyword::SU: m_lexer.next(); goto state_8070;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP AF
state_8055:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2397;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2397;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP AF1
state_8056:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_685;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP B
state_8057:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2398;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2398;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP BC
state_8058:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2398;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2398;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP BC1
state_8059:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_686;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_686;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP D
state_8060:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2399;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2399;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP DE
state_8061:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2399;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2399;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP DE1
state_8062:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_687;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_687;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP H
state_8063:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2400;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP HL
state_8064:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2400;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2400;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP HL1
state_8065:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_688;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_688;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP IP
state_8066:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2401;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2401;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP IX
state_8067:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2402;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2402;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP IY
state_8068:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2403;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2403;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP PSW
state_8069:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2397;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2397;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: POP SU
state_8070:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2404;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2404;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH
state_8071:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::AF: m_lexer.next(); goto state_8072;
	case Keyword::B: m_lexer.next(); goto state_8073;
	case Keyword::BC: m_lexer.next(); goto state_8074;
	case Keyword::D: m_lexer.next(); goto state_8075;
	case Keyword::DE: m_lexer.next(); goto state_8076;
	case Keyword::H: m_lexer.next(); goto state_8077;
	case Keyword::HL: m_lexer.next(); goto state_8078;
	case Keyword::IP: m_lexer.next(); goto state_8079;
	case Keyword::IX: m_lexer.next(); goto state_8080;
	case Keyword::IY: m_lexer.next(); goto state_8081;
	case Keyword::PSW: m_lexer.next(); goto state_8082;
	case Keyword::SU: m_lexer.next(); goto state_8083;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8084; }
	/*if (check_expr())*/ goto state_8084;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH AF
state_8072:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2405;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2405;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH B
state_8073:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2406;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2406;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH BC
state_8074:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2406;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2406;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH D
state_8075:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2407;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2407;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH DE
state_8076:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2407;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2407;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH H
state_8077:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2408;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2408;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH HL
state_8078:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2408;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2408;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH IP
state_8079:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2409;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2409;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH IX
state_8080:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2410;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2410;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH IY
state_8081:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2411;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2411;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH PSW
state_8082:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2405;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2405;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH SU
state_8083:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2412;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2412;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PUSH expr
state_8084:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2413;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2413;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PXAD
state_8085:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2395;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2395;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: PXDN
state_8086:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2396;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2396;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RAL
state_8087:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2414;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2414;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RAR
state_8088:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2415;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2415;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RC
state_8089:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2416;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2416;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RDEL
state_8090:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2417;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RDMODE
state_8091:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2418;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2418;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES
state_8092:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8093; }
	/*if (check_const_expr())*/ goto state_8093;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr
state_8093:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8094;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma
state_8094:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8095;
	case Keyword::A1: m_lexer.next(); goto state_8096;
	case Keyword::B: m_lexer.next(); goto state_8097;
	case Keyword::B1: m_lexer.next(); goto state_8098;
	case Keyword::C: m_lexer.next(); goto state_8099;
	case Keyword::C1: m_lexer.next(); goto state_8100;
	case Keyword::D: m_lexer.next(); goto state_8101;
	case Keyword::D1: m_lexer.next(); goto state_8102;
	case Keyword::E: m_lexer.next(); goto state_8103;
	case Keyword::E1: m_lexer.next(); goto state_8104;
	case Keyword::H: m_lexer.next(); goto state_8105;
	case Keyword::H1: m_lexer.next(); goto state_8106;
	case Keyword::L: m_lexer.next(); goto state_8107;
	case Keyword::L1: m_lexer.next(); goto state_8108;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8109;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma A
state_8095:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2419;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2419;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma A1
state_8096:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_689;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_689;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma B
state_8097:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2420;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2420;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma B1
state_8098:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_690;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_690;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma C
state_8099:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2421;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2421;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma C1
state_8100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_691;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_691;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma D
state_8101:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2422;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2422;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma D1
state_8102:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_692;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_692;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma E
state_8103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2423;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2423;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma E1
state_8104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_693;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_693;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma H
state_8105:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2424;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2424;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma H1
state_8106:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_694;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma L
state_8107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2425;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2425;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma L1
state_8108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_695;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_695;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen
state_8109:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8110;
	case Keyword::IX: m_lexer.next(); goto state_8112;
	case Keyword::IY: m_lexer.next(); goto state_8132;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen HL
state_8110:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8111;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen HL RParen
state_8111:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2426;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2426;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX
state_8112:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8113;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8122; }
	/*if (check_expr())*/ goto state_8122;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX RParen
state_8113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8114;
	case TType::End: goto action_2434;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2434;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX RParen Comma
state_8114:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8115;
	case Keyword::B: m_lexer.next(); goto state_8116;
	case Keyword::C: m_lexer.next(); goto state_8117;
	case Keyword::D: m_lexer.next(); goto state_8118;
	case Keyword::E: m_lexer.next(); goto state_8119;
	case Keyword::H: m_lexer.next(); goto state_8120;
	case Keyword::L: m_lexer.next(); goto state_8121;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX RParen Comma A
state_8115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2427;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2427;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX RParen Comma B
state_8116:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2428;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2428;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX RParen Comma C
state_8117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2429;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2429;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX RParen Comma D
state_8118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2430;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2430;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX RParen Comma E
state_8119:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2431;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2431;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX RParen Comma H
state_8120:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2432;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2432;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX RParen Comma L
state_8121:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2433;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2433;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr
state_8122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8123;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr RParen
state_8123:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8124;
	case TType::End: goto action_2442;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2442;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr RParen Comma
state_8124:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8125;
	case Keyword::B: m_lexer.next(); goto state_8126;
	case Keyword::C: m_lexer.next(); goto state_8127;
	case Keyword::D: m_lexer.next(); goto state_8128;
	case Keyword::E: m_lexer.next(); goto state_8129;
	case Keyword::H: m_lexer.next(); goto state_8130;
	case Keyword::L: m_lexer.next(); goto state_8131;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr RParen Comma A
state_8125:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2435;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2435;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr RParen Comma B
state_8126:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2436;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2436;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr RParen Comma C
state_8127:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2437;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2437;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr RParen Comma D
state_8128:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2438;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2438;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr RParen Comma E
state_8129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2439;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2439;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr RParen Comma H
state_8130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2440;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2440;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IX expr RParen Comma L
state_8131:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2441;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2441;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY
state_8132:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8133;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8142; }
	/*if (check_expr())*/ goto state_8142;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY RParen
state_8133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8134;
	case TType::End: goto action_2450;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2450;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY RParen Comma
state_8134:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8135;
	case Keyword::B: m_lexer.next(); goto state_8136;
	case Keyword::C: m_lexer.next(); goto state_8137;
	case Keyword::D: m_lexer.next(); goto state_8138;
	case Keyword::E: m_lexer.next(); goto state_8139;
	case Keyword::H: m_lexer.next(); goto state_8140;
	case Keyword::L: m_lexer.next(); goto state_8141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY RParen Comma A
state_8135:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2443;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2443;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY RParen Comma B
state_8136:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2444;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2444;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY RParen Comma C
state_8137:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2445;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2445;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY RParen Comma D
state_8138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2446;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2446;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY RParen Comma E
state_8139:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2447;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2447;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY RParen Comma H
state_8140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2448;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2448;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY RParen Comma L
state_8141:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2449;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2449;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr
state_8142:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8143;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr RParen
state_8143:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8144;
	case TType::End: goto action_2458;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2458;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr RParen Comma
state_8144:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8145;
	case Keyword::B: m_lexer.next(); goto state_8146;
	case Keyword::C: m_lexer.next(); goto state_8147;
	case Keyword::D: m_lexer.next(); goto state_8148;
	case Keyword::E: m_lexer.next(); goto state_8149;
	case Keyword::H: m_lexer.next(); goto state_8150;
	case Keyword::L: m_lexer.next(); goto state_8151;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr RParen Comma A
state_8145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2451;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2451;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr RParen Comma B
state_8146:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2452;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2452;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr RParen Comma C
state_8147:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2453;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2453;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr RParen Comma D
state_8148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2454;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2454;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr RParen Comma E
state_8149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2455;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2455;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr RParen Comma H
state_8150:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2456;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2456;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RES const_expr Comma LParen IY expr RParen Comma L
state_8151:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2457;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2457;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET
state_8152:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::C: m_lexer.next(); goto state_8153;
	case Keyword::LO: m_lexer.next(); goto state_8154;
	case Keyword::LZ: m_lexer.next(); goto state_8155;
	case Keyword::M: m_lexer.next(); goto state_8156;
	case Keyword::NC: m_lexer.next(); goto state_8157;
	case Keyword::NV: m_lexer.next(); goto state_8158;
	case Keyword::NZ: m_lexer.next(); goto state_8159;
	case Keyword::P: m_lexer.next(); goto state_8160;
	case Keyword::PE: m_lexer.next(); goto state_8161;
	case Keyword::PO: m_lexer.next(); goto state_8162;
	case Keyword::V: m_lexer.next(); goto state_8163;
	case Keyword::Z: m_lexer.next(); goto state_8164;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2468;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2468;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET C
state_8153:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2416;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2416;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET LO
state_8154:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2459;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2459;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET LZ
state_8155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2460;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2460;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET M
state_8156:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2461;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET NC
state_8157:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2462;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2462;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET NV
state_8158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2463;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET NZ
state_8159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2464;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET P
state_8160:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2465;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET PE
state_8161:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET PO
state_8162:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2463;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET V
state_8163:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RET Z
state_8164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2467;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RETI
state_8165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2469;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2469;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RETN
state_8166:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2470;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2470;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RIM
state_8167:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2471;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2471;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL
state_8168:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8169;
	case Keyword::A1: m_lexer.next(); goto state_8170;
	case Keyword::B: m_lexer.next(); goto state_8171;
	case Keyword::B1: m_lexer.next(); goto state_8172;
	case Keyword::BC: m_lexer.next(); goto state_8173;
	case Keyword::C: m_lexer.next(); goto state_8174;
	case Keyword::C1: m_lexer.next(); goto state_8175;
	case Keyword::D: m_lexer.next(); goto state_8176;
	case Keyword::D1: m_lexer.next(); goto state_8177;
	case Keyword::DE: m_lexer.next(); goto state_8178;
	case Keyword::DE1: m_lexer.next(); goto state_8179;
	case Keyword::E: m_lexer.next(); goto state_8180;
	case Keyword::E1: m_lexer.next(); goto state_8181;
	case Keyword::H: m_lexer.next(); goto state_8182;
	case Keyword::H1: m_lexer.next(); goto state_8183;
	case Keyword::HL: m_lexer.next(); goto state_8184;
	case Keyword::L: m_lexer.next(); goto state_8185;
	case Keyword::L1: m_lexer.next(); goto state_8186;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8187;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL A
state_8169:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2472;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2472;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL A1
state_8170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_696;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_696;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL B
state_8171:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2473;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2473;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL B1
state_8172:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_697;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_697;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL BC
state_8173:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2474;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2474;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL C
state_8174:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2475;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL C1
state_8175:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_698;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_698;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL D
state_8176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2476;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2476;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL D1
state_8177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_699;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_699;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL DE
state_8178:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2417;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL DE1
state_8179:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_700;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_700;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL E
state_8180:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2477;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2477;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL E1
state_8181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_701;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL H
state_8182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2478;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL H1
state_8183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_702;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL HL
state_8184:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2479;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2479;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL L
state_8185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2480;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2480;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL L1
state_8186:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_703;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_703;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen
state_8187:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8188;
	case Keyword::IX: m_lexer.next(); goto state_8190;
	case Keyword::IY: m_lexer.next(); goto state_8210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen HL
state_8188:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen HL RParen
state_8189:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2481;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2481;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX
state_8190:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8191;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8200; }
	/*if (check_expr())*/ goto state_8200;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX RParen
state_8191:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8192;
	case TType::End: goto action_2489;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2489;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX RParen Comma
state_8192:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8193;
	case Keyword::B: m_lexer.next(); goto state_8194;
	case Keyword::C: m_lexer.next(); goto state_8195;
	case Keyword::D: m_lexer.next(); goto state_8196;
	case Keyword::E: m_lexer.next(); goto state_8197;
	case Keyword::H: m_lexer.next(); goto state_8198;
	case Keyword::L: m_lexer.next(); goto state_8199;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX RParen Comma A
state_8193:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2482;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX RParen Comma B
state_8194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2483;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2483;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX RParen Comma C
state_8195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2484;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2484;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX RParen Comma D
state_8196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2485;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2485;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX RParen Comma E
state_8197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2486;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX RParen Comma H
state_8198:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2487;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2487;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX RParen Comma L
state_8199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2488;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2488;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr
state_8200:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8201;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr RParen
state_8201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8202;
	case TType::End: goto action_2497;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2497;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr RParen Comma
state_8202:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8203;
	case Keyword::B: m_lexer.next(); goto state_8204;
	case Keyword::C: m_lexer.next(); goto state_8205;
	case Keyword::D: m_lexer.next(); goto state_8206;
	case Keyword::E: m_lexer.next(); goto state_8207;
	case Keyword::H: m_lexer.next(); goto state_8208;
	case Keyword::L: m_lexer.next(); goto state_8209;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr RParen Comma A
state_8203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2490;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2490;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr RParen Comma B
state_8204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2491;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2491;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr RParen Comma C
state_8205:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2492;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2492;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr RParen Comma D
state_8206:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2493;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2493;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr RParen Comma E
state_8207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2494;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2494;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr RParen Comma H
state_8208:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2495;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2495;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IX expr RParen Comma L
state_8209:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2496;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2496;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY
state_8210:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8211;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8220; }
	/*if (check_expr())*/ goto state_8220;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY RParen
state_8211:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8212;
	case TType::End: goto action_2505;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2505;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY RParen Comma
state_8212:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8213;
	case Keyword::B: m_lexer.next(); goto state_8214;
	case Keyword::C: m_lexer.next(); goto state_8215;
	case Keyword::D: m_lexer.next(); goto state_8216;
	case Keyword::E: m_lexer.next(); goto state_8217;
	case Keyword::H: m_lexer.next(); goto state_8218;
	case Keyword::L: m_lexer.next(); goto state_8219;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY RParen Comma A
state_8213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2498;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2498;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY RParen Comma B
state_8214:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2499;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2499;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY RParen Comma C
state_8215:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2500;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY RParen Comma D
state_8216:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2501;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2501;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY RParen Comma E
state_8217:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2502;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2502;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY RParen Comma H
state_8218:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2503;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2503;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY RParen Comma L
state_8219:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2504;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2504;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr
state_8220:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8221;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr RParen
state_8221:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8222;
	case TType::End: goto action_2513;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2513;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr RParen Comma
state_8222:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8223;
	case Keyword::B: m_lexer.next(); goto state_8224;
	case Keyword::C: m_lexer.next(); goto state_8225;
	case Keyword::D: m_lexer.next(); goto state_8226;
	case Keyword::E: m_lexer.next(); goto state_8227;
	case Keyword::H: m_lexer.next(); goto state_8228;
	case Keyword::L: m_lexer.next(); goto state_8229;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr RParen Comma A
state_8223:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2506;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2506;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr RParen Comma B
state_8224:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2507;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2507;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr RParen Comma C
state_8225:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2508;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2508;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr RParen Comma D
state_8226:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2509;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2509;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr RParen Comma E
state_8227:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2510;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2510;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr RParen Comma H
state_8228:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2511;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2511;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RL LParen IY expr RParen Comma L
state_8229:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2512;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2512;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLA
state_8230:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2414;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2414;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLA1
state_8231:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_709;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_709;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC
state_8232:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8233;
	case Keyword::A1: m_lexer.next(); goto state_8234;
	case Keyword::B: m_lexer.next(); goto state_8235;
	case Keyword::B1: m_lexer.next(); goto state_8236;
	case Keyword::C: m_lexer.next(); goto state_8237;
	case Keyword::C1: m_lexer.next(); goto state_8238;
	case Keyword::D: m_lexer.next(); goto state_8239;
	case Keyword::D1: m_lexer.next(); goto state_8240;
	case Keyword::E: m_lexer.next(); goto state_8241;
	case Keyword::E1: m_lexer.next(); goto state_8242;
	case Keyword::H: m_lexer.next(); goto state_8243;
	case Keyword::H1: m_lexer.next(); goto state_8244;
	case Keyword::L: m_lexer.next(); goto state_8245;
	case Keyword::L1: m_lexer.next(); goto state_8246;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2521;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2521;
	case TType::LParen: m_lexer.next(); goto state_8247;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC A
state_8233:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2514;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2514;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC A1
state_8234:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_710;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_710;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC B
state_8235:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2515;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2515;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC B1
state_8236:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_711;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_711;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC C
state_8237:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2516;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2516;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC C1
state_8238:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_712;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_712;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC D
state_8239:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2517;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2517;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC D1
state_8240:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_713;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_713;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC E
state_8241:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2518;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2518;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC E1
state_8242:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_714;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_714;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC H
state_8243:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2519;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2519;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC H1
state_8244:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_715;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_715;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC L
state_8245:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2520;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2520;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC L1
state_8246:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_716;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_716;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen
state_8247:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8248;
	case Keyword::IX: m_lexer.next(); goto state_8250;
	case Keyword::IY: m_lexer.next(); goto state_8270;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen HL
state_8248:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8249;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen HL RParen
state_8249:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2522;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2522;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX
state_8250:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8251;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8260; }
	/*if (check_expr())*/ goto state_8260;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX RParen
state_8251:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8252;
	case TType::End: goto action_2530;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2530;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX RParen Comma
state_8252:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8253;
	case Keyword::B: m_lexer.next(); goto state_8254;
	case Keyword::C: m_lexer.next(); goto state_8255;
	case Keyword::D: m_lexer.next(); goto state_8256;
	case Keyword::E: m_lexer.next(); goto state_8257;
	case Keyword::H: m_lexer.next(); goto state_8258;
	case Keyword::L: m_lexer.next(); goto state_8259;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX RParen Comma A
state_8253:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2523;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX RParen Comma B
state_8254:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2524;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2524;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX RParen Comma C
state_8255:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2525;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX RParen Comma D
state_8256:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2526;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2526;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX RParen Comma E
state_8257:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2527;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2527;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX RParen Comma H
state_8258:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2528;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2528;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX RParen Comma L
state_8259:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2529;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2529;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr
state_8260:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8261;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr RParen
state_8261:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8262;
	case TType::End: goto action_2538;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2538;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr RParen Comma
state_8262:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8263;
	case Keyword::B: m_lexer.next(); goto state_8264;
	case Keyword::C: m_lexer.next(); goto state_8265;
	case Keyword::D: m_lexer.next(); goto state_8266;
	case Keyword::E: m_lexer.next(); goto state_8267;
	case Keyword::H: m_lexer.next(); goto state_8268;
	case Keyword::L: m_lexer.next(); goto state_8269;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr RParen Comma A
state_8263:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2531;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2531;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr RParen Comma B
state_8264:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2532;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2532;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr RParen Comma C
state_8265:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2533;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2533;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr RParen Comma D
state_8266:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2534;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2534;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr RParen Comma E
state_8267:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2535;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2535;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr RParen Comma H
state_8268:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2536;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2536;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IX expr RParen Comma L
state_8269:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2537;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2537;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY
state_8270:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8271;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8280; }
	/*if (check_expr())*/ goto state_8280;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY RParen
state_8271:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8272;
	case TType::End: goto action_2546;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2546;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY RParen Comma
state_8272:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8273;
	case Keyword::B: m_lexer.next(); goto state_8274;
	case Keyword::C: m_lexer.next(); goto state_8275;
	case Keyword::D: m_lexer.next(); goto state_8276;
	case Keyword::E: m_lexer.next(); goto state_8277;
	case Keyword::H: m_lexer.next(); goto state_8278;
	case Keyword::L: m_lexer.next(); goto state_8279;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY RParen Comma A
state_8273:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2539;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2539;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY RParen Comma B
state_8274:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2540;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY RParen Comma C
state_8275:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2541;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY RParen Comma D
state_8276:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2542;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2542;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY RParen Comma E
state_8277:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2543;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2543;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY RParen Comma H
state_8278:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2544;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2544;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY RParen Comma L
state_8279:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2545;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2545;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr
state_8280:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8281;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr RParen
state_8281:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8282;
	case TType::End: goto action_2554;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2554;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr RParen Comma
state_8282:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8283;
	case Keyword::B: m_lexer.next(); goto state_8284;
	case Keyword::C: m_lexer.next(); goto state_8285;
	case Keyword::D: m_lexer.next(); goto state_8286;
	case Keyword::E: m_lexer.next(); goto state_8287;
	case Keyword::H: m_lexer.next(); goto state_8288;
	case Keyword::L: m_lexer.next(); goto state_8289;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr RParen Comma A
state_8283:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2547;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2547;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr RParen Comma B
state_8284:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2548;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2548;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr RParen Comma C
state_8285:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2549;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr RParen Comma D
state_8286:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2550;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2550;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr RParen Comma E
state_8287:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2551;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2551;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr RParen Comma H
state_8288:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2552;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2552;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLC LParen IY expr RParen Comma L
state_8289:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2553;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2553;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLCA
state_8290:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2521;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2521;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLCA1
state_8291:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_722;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_722;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLD
state_8292:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2555;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2555;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLDE
state_8293:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2417;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLO
state_8294:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2459;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2459;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RLZ
state_8295:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2460;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2460;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RM
state_8296:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2461;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RNC
state_8297:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2462;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2462;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RNV
state_8298:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2463;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RNZ
state_8299:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2464;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RP
state_8300:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2465;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RPE
state_8301:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RPO
state_8302:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2463;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR
state_8303:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8304;
	case Keyword::A1: m_lexer.next(); goto state_8305;
	case Keyword::B: m_lexer.next(); goto state_8306;
	case Keyword::B1: m_lexer.next(); goto state_8307;
	case Keyword::BC: m_lexer.next(); goto state_8308;
	case Keyword::C: m_lexer.next(); goto state_8309;
	case Keyword::C1: m_lexer.next(); goto state_8310;
	case Keyword::D: m_lexer.next(); goto state_8311;
	case Keyword::D1: m_lexer.next(); goto state_8312;
	case Keyword::DE: m_lexer.next(); goto state_8313;
	case Keyword::DE1: m_lexer.next(); goto state_8314;
	case Keyword::E: m_lexer.next(); goto state_8315;
	case Keyword::E1: m_lexer.next(); goto state_8316;
	case Keyword::H: m_lexer.next(); goto state_8317;
	case Keyword::H1: m_lexer.next(); goto state_8318;
	case Keyword::HL: m_lexer.next(); goto state_8319;
	case Keyword::HL1: m_lexer.next(); goto state_8320;
	case Keyword::IX: m_lexer.next(); goto state_8321;
	case Keyword::IY: m_lexer.next(); goto state_8322;
	case Keyword::L: m_lexer.next(); goto state_8323;
	case Keyword::L1: m_lexer.next(); goto state_8324;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8325;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR A
state_8304:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2556;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2556;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR A1
state_8305:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_723;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR B
state_8306:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2557;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR B1
state_8307:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_724;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR BC
state_8308:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2558;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2558;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR C
state_8309:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2559;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2559;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR C1
state_8310:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_725;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_725;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR D
state_8311:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2560;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2560;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR D1
state_8312:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_726;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_726;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR DE
state_8313:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2561;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2561;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR DE1
state_8314:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_727;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_727;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR E
state_8315:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2562;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2562;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR E1
state_8316:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_728;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_728;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR H
state_8317:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2563;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2563;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR H1
state_8318:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_729;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR HL
state_8319:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2564;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2564;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR HL1
state_8320:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_730;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_730;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR IX
state_8321:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2565;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2565;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR IY
state_8322:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2566;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2566;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR L
state_8323:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2567;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2567;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR L1
state_8324:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_731;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_731;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen
state_8325:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8326;
	case Keyword::IX: m_lexer.next(); goto state_8328;
	case Keyword::IY: m_lexer.next(); goto state_8348;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen HL
state_8326:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8327;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen HL RParen
state_8327:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2568;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2568;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX
state_8328:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8329;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8338; }
	/*if (check_expr())*/ goto state_8338;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX RParen
state_8329:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8330;
	case TType::End: goto action_2576;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2576;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX RParen Comma
state_8330:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8331;
	case Keyword::B: m_lexer.next(); goto state_8332;
	case Keyword::C: m_lexer.next(); goto state_8333;
	case Keyword::D: m_lexer.next(); goto state_8334;
	case Keyword::E: m_lexer.next(); goto state_8335;
	case Keyword::H: m_lexer.next(); goto state_8336;
	case Keyword::L: m_lexer.next(); goto state_8337;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX RParen Comma A
state_8331:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2569;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2569;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX RParen Comma B
state_8332:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2570;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2570;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX RParen Comma C
state_8333:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2571;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2571;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX RParen Comma D
state_8334:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2572;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2572;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX RParen Comma E
state_8335:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2573;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2573;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX RParen Comma H
state_8336:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2574;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX RParen Comma L
state_8337:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2575;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2575;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr
state_8338:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8339;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr RParen
state_8339:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8340;
	case TType::End: goto action_2584;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr RParen Comma
state_8340:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8341;
	case Keyword::B: m_lexer.next(); goto state_8342;
	case Keyword::C: m_lexer.next(); goto state_8343;
	case Keyword::D: m_lexer.next(); goto state_8344;
	case Keyword::E: m_lexer.next(); goto state_8345;
	case Keyword::H: m_lexer.next(); goto state_8346;
	case Keyword::L: m_lexer.next(); goto state_8347;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr RParen Comma A
state_8341:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2577;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2577;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr RParen Comma B
state_8342:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2578;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2578;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr RParen Comma C
state_8343:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2579;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2579;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr RParen Comma D
state_8344:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2580;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2580;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr RParen Comma E
state_8345:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2581;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2581;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr RParen Comma H
state_8346:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2582;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2582;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IX expr RParen Comma L
state_8347:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2583;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2583;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY
state_8348:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8349;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8358; }
	/*if (check_expr())*/ goto state_8358;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY RParen
state_8349:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8350;
	case TType::End: goto action_2592;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2592;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY RParen Comma
state_8350:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8351;
	case Keyword::B: m_lexer.next(); goto state_8352;
	case Keyword::C: m_lexer.next(); goto state_8353;
	case Keyword::D: m_lexer.next(); goto state_8354;
	case Keyword::E: m_lexer.next(); goto state_8355;
	case Keyword::H: m_lexer.next(); goto state_8356;
	case Keyword::L: m_lexer.next(); goto state_8357;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY RParen Comma A
state_8351:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2585;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2585;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY RParen Comma B
state_8352:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2586;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY RParen Comma C
state_8353:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2587;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2587;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY RParen Comma D
state_8354:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2588;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2588;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY RParen Comma E
state_8355:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2589;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2589;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY RParen Comma H
state_8356:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2590;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2590;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY RParen Comma L
state_8357:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2591;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2591;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr
state_8358:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8359;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr RParen
state_8359:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8360;
	case TType::End: goto action_2600;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2600;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr RParen Comma
state_8360:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8361;
	case Keyword::B: m_lexer.next(); goto state_8362;
	case Keyword::C: m_lexer.next(); goto state_8363;
	case Keyword::D: m_lexer.next(); goto state_8364;
	case Keyword::E: m_lexer.next(); goto state_8365;
	case Keyword::H: m_lexer.next(); goto state_8366;
	case Keyword::L: m_lexer.next(); goto state_8367;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr RParen Comma A
state_8361:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2593;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2593;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr RParen Comma B
state_8362:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2594;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2594;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr RParen Comma C
state_8363:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2595;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2595;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr RParen Comma D
state_8364:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2596;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2596;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr RParen Comma E
state_8365:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2597;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2597;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr RParen Comma H
state_8366:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2598;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2598;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RR LParen IY expr RParen Comma L
state_8367:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2599;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2599;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRA
state_8368:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2415;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2415;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRA1
state_8369:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_737;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_737;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC
state_8370:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8371;
	case Keyword::A1: m_lexer.next(); goto state_8372;
	case Keyword::B: m_lexer.next(); goto state_8373;
	case Keyword::B1: m_lexer.next(); goto state_8374;
	case Keyword::C: m_lexer.next(); goto state_8375;
	case Keyword::C1: m_lexer.next(); goto state_8376;
	case Keyword::D: m_lexer.next(); goto state_8377;
	case Keyword::D1: m_lexer.next(); goto state_8378;
	case Keyword::E: m_lexer.next(); goto state_8379;
	case Keyword::E1: m_lexer.next(); goto state_8380;
	case Keyword::H: m_lexer.next(); goto state_8381;
	case Keyword::H1: m_lexer.next(); goto state_8382;
	case Keyword::L: m_lexer.next(); goto state_8383;
	case Keyword::L1: m_lexer.next(); goto state_8384;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2608;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2608;
	case TType::LParen: m_lexer.next(); goto state_8385;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC A
state_8371:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2601;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2601;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC A1
state_8372:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_738;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_738;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC B
state_8373:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2602;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2602;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC B1
state_8374:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_739;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC C
state_8375:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2603;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2603;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC C1
state_8376:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_740;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC D
state_8377:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2604;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2604;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC D1
state_8378:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_741;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_741;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC E
state_8379:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2605;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2605;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC E1
state_8380:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_742;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_742;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC H
state_8381:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2606;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2606;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC H1
state_8382:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_743;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_743;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC L
state_8383:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2607;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2607;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC L1
state_8384:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_744;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_744;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen
state_8385:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8386;
	case Keyword::IX: m_lexer.next(); goto state_8388;
	case Keyword::IY: m_lexer.next(); goto state_8408;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen HL
state_8386:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8387;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen HL RParen
state_8387:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2609;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2609;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX
state_8388:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8389;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8398; }
	/*if (check_expr())*/ goto state_8398;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX RParen
state_8389:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8390;
	case TType::End: goto action_2617;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2617;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX RParen Comma
state_8390:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8391;
	case Keyword::B: m_lexer.next(); goto state_8392;
	case Keyword::C: m_lexer.next(); goto state_8393;
	case Keyword::D: m_lexer.next(); goto state_8394;
	case Keyword::E: m_lexer.next(); goto state_8395;
	case Keyword::H: m_lexer.next(); goto state_8396;
	case Keyword::L: m_lexer.next(); goto state_8397;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX RParen Comma A
state_8391:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2610;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2610;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX RParen Comma B
state_8392:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2611;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2611;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX RParen Comma C
state_8393:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2612;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2612;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX RParen Comma D
state_8394:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2613;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2613;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX RParen Comma E
state_8395:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2614;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX RParen Comma H
state_8396:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2615;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2615;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX RParen Comma L
state_8397:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2616;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2616;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr
state_8398:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8399;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr RParen
state_8399:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8400;
	case TType::End: goto action_2625;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2625;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr RParen Comma
state_8400:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8401;
	case Keyword::B: m_lexer.next(); goto state_8402;
	case Keyword::C: m_lexer.next(); goto state_8403;
	case Keyword::D: m_lexer.next(); goto state_8404;
	case Keyword::E: m_lexer.next(); goto state_8405;
	case Keyword::H: m_lexer.next(); goto state_8406;
	case Keyword::L: m_lexer.next(); goto state_8407;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr RParen Comma A
state_8401:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2618;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2618;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr RParen Comma B
state_8402:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2619;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2619;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr RParen Comma C
state_8403:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2620;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2620;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr RParen Comma D
state_8404:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2621;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2621;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr RParen Comma E
state_8405:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2622;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2622;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr RParen Comma H
state_8406:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2623;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2623;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IX expr RParen Comma L
state_8407:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2624;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2624;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY
state_8408:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8409;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8418; }
	/*if (check_expr())*/ goto state_8418;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY RParen
state_8409:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8410;
	case TType::End: goto action_2633;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2633;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY RParen Comma
state_8410:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8411;
	case Keyword::B: m_lexer.next(); goto state_8412;
	case Keyword::C: m_lexer.next(); goto state_8413;
	case Keyword::D: m_lexer.next(); goto state_8414;
	case Keyword::E: m_lexer.next(); goto state_8415;
	case Keyword::H: m_lexer.next(); goto state_8416;
	case Keyword::L: m_lexer.next(); goto state_8417;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY RParen Comma A
state_8411:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2626;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2626;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY RParen Comma B
state_8412:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2627;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2627;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY RParen Comma C
state_8413:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2628;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2628;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY RParen Comma D
state_8414:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2629;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2629;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY RParen Comma E
state_8415:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2630;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2630;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY RParen Comma H
state_8416:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2631;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2631;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY RParen Comma L
state_8417:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2632;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2632;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr
state_8418:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8419;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr RParen
state_8419:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8420;
	case TType::End: goto action_2641;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2641;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr RParen Comma
state_8420:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8421;
	case Keyword::B: m_lexer.next(); goto state_8422;
	case Keyword::C: m_lexer.next(); goto state_8423;
	case Keyword::D: m_lexer.next(); goto state_8424;
	case Keyword::E: m_lexer.next(); goto state_8425;
	case Keyword::H: m_lexer.next(); goto state_8426;
	case Keyword::L: m_lexer.next(); goto state_8427;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr RParen Comma A
state_8421:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2634;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2634;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr RParen Comma B
state_8422:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2635;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2635;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr RParen Comma C
state_8423:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2636;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2636;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr RParen Comma D
state_8424:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2637;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr RParen Comma E
state_8425:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2638;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2638;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr RParen Comma H
state_8426:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2639;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRC LParen IY expr RParen Comma L
state_8427:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2640;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2640;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRCA
state_8428:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2608;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2608;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRCA1
state_8429:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_750;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_750;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRD
state_8430:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2642;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2642;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RRHL
state_8431:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_866;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RST
state_8432:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8433; }
	/*if (check_const_expr())*/ goto state_8433;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: RST const_expr
state_8433:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2643;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2643;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RSTV
state_8434:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2394;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2394;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RV
state_8435:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: RZ
state_8436:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2467;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_C
state_8437:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2416;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2416;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_LO
state_8438:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2459;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2459;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_LZ
state_8439:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2460;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2460;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_M
state_8440:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2461;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2461;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_NC
state_8441:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2462;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2462;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_NV
state_8442:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2463;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_NZ
state_8443:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2464;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2464;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_P
state_8444:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2465;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2465;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_PE
state_8445:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_PO
state_8446:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2463;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2463;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_V
state_8447:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2466;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2466;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: R_Z
state_8448:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2467;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2467;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBB
state_8449:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8450;
	case Keyword::B: m_lexer.next(); goto state_8451;
	case Keyword::C: m_lexer.next(); goto state_8452;
	case Keyword::D: m_lexer.next(); goto state_8453;
	case Keyword::E: m_lexer.next(); goto state_8454;
	case Keyword::H: m_lexer.next(); goto state_8455;
	case Keyword::L: m_lexer.next(); goto state_8456;
	case Keyword::M: m_lexer.next(); goto state_8457;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBB A
state_8450:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2644;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBB B
state_8451:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2645;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2645;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBB C
state_8452:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2646;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBB D
state_8453:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2647;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBB E
state_8454:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2648;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2648;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBB H
state_8455:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2649;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBB L
state_8456:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2650;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBB M
state_8457:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2651;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2651;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC
state_8458:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8459;
	case Keyword::A1: m_lexer.next(); goto state_8488;
	case Keyword::B: m_lexer.next(); goto state_8513;
	case Keyword::C: m_lexer.next(); goto state_8514;
	case Keyword::D: m_lexer.next(); goto state_8515;
	case Keyword::E: m_lexer.next(); goto state_8516;
	case Keyword::H: m_lexer.next(); goto state_8517;
	case Keyword::HL: m_lexer.next(); goto state_8518;
	case Keyword::HL1: m_lexer.next(); goto state_8524;
	case Keyword::IXH: m_lexer.next(); goto state_8530;
	case Keyword::IXL: m_lexer.next(); goto state_8531;
	case Keyword::IYH: m_lexer.next(); goto state_8532;
	case Keyword::IYL: m_lexer.next(); goto state_8533;
	case Keyword::L: m_lexer.next(); goto state_8534;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8535;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8550; }
	/*if (check_expr())*/ goto state_8550;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A
state_8459:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8460;
	case TType::End: goto action_2644;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma
state_8460:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8461;
	case Keyword::B: m_lexer.next(); goto state_8462;
	case Keyword::C: m_lexer.next(); goto state_8463;
	case Keyword::D: m_lexer.next(); goto state_8464;
	case Keyword::E: m_lexer.next(); goto state_8465;
	case Keyword::H: m_lexer.next(); goto state_8466;
	case Keyword::IXH: m_lexer.next(); goto state_8467;
	case Keyword::IXL: m_lexer.next(); goto state_8468;
	case Keyword::IYH: m_lexer.next(); goto state_8469;
	case Keyword::IYL: m_lexer.next(); goto state_8470;
	case Keyword::L: m_lexer.next(); goto state_8471;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8472;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8487; }
	/*if (check_expr())*/ goto state_8487;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma A
state_8461:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2644;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2644;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma B
state_8462:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2645;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2645;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma C
state_8463:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2646;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma D
state_8464:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2647;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma E
state_8465:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2648;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2648;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma H
state_8466:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2649;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma IXH
state_8467:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2652;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2652;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma IXL
state_8468:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2653;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2653;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma IYH
state_8469:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2654;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2654;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma IYL
state_8470:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2655;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2655;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma L
state_8471:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2650;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen
state_8472:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8473;
	case Keyword::IX: m_lexer.next(); goto state_8479;
	case Keyword::IY: m_lexer.next(); goto state_8483;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen HL
state_8473:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_8474;
	case TType::Plus: m_lexer.next(); goto state_8476;
	case TType::RParen: m_lexer.next(); goto state_8478;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen HL Minus
state_8474:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8475;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen HL Minus RParen
state_8475:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2656;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen HL Plus
state_8476:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8477;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen HL Plus RParen
state_8477:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2657;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2657;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen HL RParen
state_8478:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2651;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2651;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen IX
state_8479:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8480;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8481; }
	/*if (check_expr())*/ goto state_8481;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen IX RParen
state_8480:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2658;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen IX expr
state_8481:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8482;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen IX expr RParen
state_8482:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2659;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen IY
state_8483:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8484;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8485; }
	/*if (check_expr())*/ goto state_8485;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen IY RParen
state_8484:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen IY expr
state_8485:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8486;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma LParen IY expr RParen
state_8486:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A Comma expr
state_8487:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2662;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1
state_8488:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8489;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma
state_8489:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8490;
	case Keyword::B: m_lexer.next(); goto state_8491;
	case Keyword::C: m_lexer.next(); goto state_8492;
	case Keyword::D: m_lexer.next(); goto state_8493;
	case Keyword::E: m_lexer.next(); goto state_8494;
	case Keyword::H: m_lexer.next(); goto state_8495;
	case Keyword::L: m_lexer.next(); goto state_8496;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8497;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8512; }
	/*if (check_expr())*/ goto state_8512;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma A
state_8490:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_751;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma B
state_8491:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_752;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_752;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma C
state_8492:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_753;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma D
state_8493:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_754;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_754;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma E
state_8494:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_755;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma H
state_8495:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_756;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma L
state_8496:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_757;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen
state_8497:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8498;
	case Keyword::IX: m_lexer.next(); goto state_8504;
	case Keyword::IY: m_lexer.next(); goto state_8508;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen HL
state_8498:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_8499;
	case TType::Plus: m_lexer.next(); goto state_8501;
	case TType::RParen: m_lexer.next(); goto state_8503;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen HL Minus
state_8499:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8500;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen HL Minus RParen
state_8500:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_758;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen HL Plus
state_8501:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8502;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen HL Plus RParen
state_8502:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_759;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen HL RParen
state_8503:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_760;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen IX
state_8504:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8505;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8506; }
	/*if (check_expr())*/ goto state_8506;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen IX RParen
state_8505:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_761;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen IX expr
state_8506:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8507;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen IX expr RParen
state_8507:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_762;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen IY
state_8508:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8509;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8510; }
	/*if (check_expr())*/ goto state_8510;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen IY RParen
state_8509:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_763;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen IY expr
state_8510:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8511;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma LParen IY expr RParen
state_8511:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_764;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC A1 Comma expr
state_8512:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_765;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC B
state_8513:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2645;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2645;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC C
state_8514:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2646;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2646;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC D
state_8515:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2647;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2647;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC E
state_8516:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2648;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2648;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC H
state_8517:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2649;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL
state_8518:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8519;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL Comma
state_8519:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_8520;
	case Keyword::DE: m_lexer.next(); goto state_8521;
	case Keyword::HL: m_lexer.next(); goto state_8522;
	case Keyword::SP: m_lexer.next(); goto state_8523;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL Comma BC
state_8520:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2663;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2663;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL Comma DE
state_8521:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2664;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2664;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL Comma HL
state_8522:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2665;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2665;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL Comma SP
state_8523:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2666;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2666;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL1
state_8524:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8525;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL1 Comma
state_8525:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_8526;
	case Keyword::DE: m_lexer.next(); goto state_8527;
	case Keyword::HL: m_lexer.next(); goto state_8528;
	case Keyword::SP: m_lexer.next(); goto state_8529;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL1 Comma BC
state_8526:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_766;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_766;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL1 Comma DE
state_8527:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_767;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL1 Comma HL
state_8528:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_768;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC HL1 Comma SP
state_8529:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_769;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_769;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC IXH
state_8530:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2652;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2652;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC IXL
state_8531:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2653;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2653;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC IYH
state_8532:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2654;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2654;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC IYL
state_8533:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2655;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2655;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC L
state_8534:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2650;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2650;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen
state_8535:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8536;
	case Keyword::IX: m_lexer.next(); goto state_8542;
	case Keyword::IY: m_lexer.next(); goto state_8546;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen HL
state_8536:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_8537;
	case TType::Plus: m_lexer.next(); goto state_8539;
	case TType::RParen: m_lexer.next(); goto state_8541;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen HL Minus
state_8537:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8538;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen HL Minus RParen
state_8538:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2656;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2656;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen HL Plus
state_8539:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8540;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen HL Plus RParen
state_8540:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2657;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2657;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen HL RParen
state_8541:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2651;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2651;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen IX
state_8542:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8543;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8544; }
	/*if (check_expr())*/ goto state_8544;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen IX RParen
state_8543:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2658;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2658;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen IX expr
state_8544:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8545;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen IX expr RParen
state_8545:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2659;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen IY
state_8546:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8547;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8548; }
	/*if (check_expr())*/ goto state_8548;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen IY RParen
state_8547:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2660;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen IY expr
state_8548:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8549;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC LParen IY expr RParen
state_8549:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2661;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2661;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBC expr
state_8550:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2662;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBI
state_8551:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8552; }
	/*if (check_expr())*/ goto state_8552;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SBI expr
state_8552:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2662;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2662;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SCF
state_8553:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2667;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2667;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SCF1
state_8554:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_770;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_770;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET
state_8555:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8556; }
	/*if (check_const_expr())*/ goto state_8556;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr
state_8556:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8557;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma
state_8557:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8558;
	case Keyword::A1: m_lexer.next(); goto state_8559;
	case Keyword::B: m_lexer.next(); goto state_8560;
	case Keyword::B1: m_lexer.next(); goto state_8561;
	case Keyword::C: m_lexer.next(); goto state_8562;
	case Keyword::C1: m_lexer.next(); goto state_8563;
	case Keyword::D: m_lexer.next(); goto state_8564;
	case Keyword::D1: m_lexer.next(); goto state_8565;
	case Keyword::E: m_lexer.next(); goto state_8566;
	case Keyword::E1: m_lexer.next(); goto state_8567;
	case Keyword::H: m_lexer.next(); goto state_8568;
	case Keyword::H1: m_lexer.next(); goto state_8569;
	case Keyword::L: m_lexer.next(); goto state_8570;
	case Keyword::L1: m_lexer.next(); goto state_8571;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8572;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma A
state_8558:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2668;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2668;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma A1
state_8559:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_771;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma B
state_8560:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2669;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2669;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma B1
state_8561:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_772;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_772;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma C
state_8562:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2670;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2670;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma C1
state_8563:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_773;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma D
state_8564:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2671;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2671;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma D1
state_8565:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_774;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma E
state_8566:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2672;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2672;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma E1
state_8567:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_775;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_775;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma H
state_8568:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2673;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2673;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma H1
state_8569:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_776;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_776;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma L
state_8570:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2674;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2674;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma L1
state_8571:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_777;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen
state_8572:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8573;
	case Keyword::IX: m_lexer.next(); goto state_8575;
	case Keyword::IY: m_lexer.next(); goto state_8595;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen HL
state_8573:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8574;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen HL RParen
state_8574:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2675;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2675;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX
state_8575:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8576;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8585; }
	/*if (check_expr())*/ goto state_8585;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX RParen
state_8576:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8577;
	case TType::End: goto action_2683;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2683;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX RParen Comma
state_8577:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8578;
	case Keyword::B: m_lexer.next(); goto state_8579;
	case Keyword::C: m_lexer.next(); goto state_8580;
	case Keyword::D: m_lexer.next(); goto state_8581;
	case Keyword::E: m_lexer.next(); goto state_8582;
	case Keyword::H: m_lexer.next(); goto state_8583;
	case Keyword::L: m_lexer.next(); goto state_8584;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX RParen Comma A
state_8578:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2676;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2676;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX RParen Comma B
state_8579:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2677;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2677;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX RParen Comma C
state_8580:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2678;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2678;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX RParen Comma D
state_8581:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2679;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX RParen Comma E
state_8582:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2680;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2680;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX RParen Comma H
state_8583:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2681;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2681;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX RParen Comma L
state_8584:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2682;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2682;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr
state_8585:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8586;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr RParen
state_8586:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8587;
	case TType::End: goto action_2691;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2691;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr RParen Comma
state_8587:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8588;
	case Keyword::B: m_lexer.next(); goto state_8589;
	case Keyword::C: m_lexer.next(); goto state_8590;
	case Keyword::D: m_lexer.next(); goto state_8591;
	case Keyword::E: m_lexer.next(); goto state_8592;
	case Keyword::H: m_lexer.next(); goto state_8593;
	case Keyword::L: m_lexer.next(); goto state_8594;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr RParen Comma A
state_8588:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2684;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2684;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr RParen Comma B
state_8589:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2685;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2685;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr RParen Comma C
state_8590:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2686;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2686;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr RParen Comma D
state_8591:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2687;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2687;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr RParen Comma E
state_8592:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2688;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2688;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr RParen Comma H
state_8593:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2689;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2689;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IX expr RParen Comma L
state_8594:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2690;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2690;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY
state_8595:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8596;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8605; }
	/*if (check_expr())*/ goto state_8605;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY RParen
state_8596:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8597;
	case TType::End: goto action_2699;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2699;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY RParen Comma
state_8597:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8598;
	case Keyword::B: m_lexer.next(); goto state_8599;
	case Keyword::C: m_lexer.next(); goto state_8600;
	case Keyword::D: m_lexer.next(); goto state_8601;
	case Keyword::E: m_lexer.next(); goto state_8602;
	case Keyword::H: m_lexer.next(); goto state_8603;
	case Keyword::L: m_lexer.next(); goto state_8604;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY RParen Comma A
state_8598:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2692;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2692;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY RParen Comma B
state_8599:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2693;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2693;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY RParen Comma C
state_8600:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2694;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2694;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY RParen Comma D
state_8601:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2695;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2695;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY RParen Comma E
state_8602:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2696;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2696;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY RParen Comma H
state_8603:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2697;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2697;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY RParen Comma L
state_8604:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2698;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2698;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr
state_8605:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8606;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr RParen
state_8606:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8607;
	case TType::End: goto action_2707;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2707;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr RParen Comma
state_8607:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8608;
	case Keyword::B: m_lexer.next(); goto state_8609;
	case Keyword::C: m_lexer.next(); goto state_8610;
	case Keyword::D: m_lexer.next(); goto state_8611;
	case Keyword::E: m_lexer.next(); goto state_8612;
	case Keyword::H: m_lexer.next(); goto state_8613;
	case Keyword::L: m_lexer.next(); goto state_8614;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr RParen Comma A
state_8608:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2700;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2700;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr RParen Comma B
state_8609:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2701;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2701;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr RParen Comma C
state_8610:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2702;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr RParen Comma D
state_8611:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2703;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2703;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr RParen Comma E
state_8612:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2704;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2704;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr RParen Comma H
state_8613:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2705;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2705;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SET const_expr Comma LParen IY expr RParen Comma L
state_8614:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2706;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2706;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SETAE
state_8615:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2708;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SETUSR
state_8616:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2709;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2709;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SHLD
state_8617:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8618; }
	/*if (check_expr())*/ goto state_8618;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SHLD expr
state_8618:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2710;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2710;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SHLDE
state_8619:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2196;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SHLX
state_8620:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2196;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SIM
state_8621:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2711;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2711;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA
state_8622:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8623;
	case Keyword::A1: m_lexer.next(); goto state_8624;
	case Keyword::B: m_lexer.next(); goto state_8625;
	case Keyword::B1: m_lexer.next(); goto state_8626;
	case Keyword::C: m_lexer.next(); goto state_8627;
	case Keyword::C1: m_lexer.next(); goto state_8628;
	case Keyword::D: m_lexer.next(); goto state_8629;
	case Keyword::D1: m_lexer.next(); goto state_8630;
	case Keyword::E: m_lexer.next(); goto state_8631;
	case Keyword::E1: m_lexer.next(); goto state_8632;
	case Keyword::H: m_lexer.next(); goto state_8633;
	case Keyword::H1: m_lexer.next(); goto state_8634;
	case Keyword::L: m_lexer.next(); goto state_8635;
	case Keyword::L1: m_lexer.next(); goto state_8636;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8637;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA A
state_8623:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2712;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2712;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA A1
state_8624:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_778;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_778;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA B
state_8625:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2713;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2713;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA B1
state_8626:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_779;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA C
state_8627:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2714;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2714;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA C1
state_8628:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_780;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_780;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA D
state_8629:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2715;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2715;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA D1
state_8630:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_781;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA E
state_8631:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2716;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2716;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA E1
state_8632:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_782;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA H
state_8633:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2717;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2717;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA H1
state_8634:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_783;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_783;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA L
state_8635:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2718;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2718;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA L1
state_8636:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_784;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_784;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen
state_8637:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8638;
	case Keyword::IX: m_lexer.next(); goto state_8640;
	case Keyword::IY: m_lexer.next(); goto state_8660;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen HL
state_8638:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8639;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen HL RParen
state_8639:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2719;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2719;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX
state_8640:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8641;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8650; }
	/*if (check_expr())*/ goto state_8650;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX RParen
state_8641:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8642;
	case TType::End: goto action_2727;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2727;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX RParen Comma
state_8642:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8643;
	case Keyword::B: m_lexer.next(); goto state_8644;
	case Keyword::C: m_lexer.next(); goto state_8645;
	case Keyword::D: m_lexer.next(); goto state_8646;
	case Keyword::E: m_lexer.next(); goto state_8647;
	case Keyword::H: m_lexer.next(); goto state_8648;
	case Keyword::L: m_lexer.next(); goto state_8649;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX RParen Comma A
state_8643:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2720;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2720;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX RParen Comma B
state_8644:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2721;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2721;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX RParen Comma C
state_8645:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2722;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2722;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX RParen Comma D
state_8646:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2723;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2723;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX RParen Comma E
state_8647:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2724;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2724;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX RParen Comma H
state_8648:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2725;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2725;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX RParen Comma L
state_8649:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2726;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2726;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr
state_8650:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8651;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr RParen
state_8651:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8652;
	case TType::End: goto action_2735;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2735;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr RParen Comma
state_8652:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8653;
	case Keyword::B: m_lexer.next(); goto state_8654;
	case Keyword::C: m_lexer.next(); goto state_8655;
	case Keyword::D: m_lexer.next(); goto state_8656;
	case Keyword::E: m_lexer.next(); goto state_8657;
	case Keyword::H: m_lexer.next(); goto state_8658;
	case Keyword::L: m_lexer.next(); goto state_8659;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr RParen Comma A
state_8653:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2728;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2728;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr RParen Comma B
state_8654:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2729;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2729;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr RParen Comma C
state_8655:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2730;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2730;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr RParen Comma D
state_8656:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2731;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2731;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr RParen Comma E
state_8657:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2732;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2732;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr RParen Comma H
state_8658:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2733;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2733;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IX expr RParen Comma L
state_8659:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2734;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2734;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY
state_8660:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8661;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8670; }
	/*if (check_expr())*/ goto state_8670;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY RParen
state_8661:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8662;
	case TType::End: goto action_2743;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2743;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY RParen Comma
state_8662:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8663;
	case Keyword::B: m_lexer.next(); goto state_8664;
	case Keyword::C: m_lexer.next(); goto state_8665;
	case Keyword::D: m_lexer.next(); goto state_8666;
	case Keyword::E: m_lexer.next(); goto state_8667;
	case Keyword::H: m_lexer.next(); goto state_8668;
	case Keyword::L: m_lexer.next(); goto state_8669;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY RParen Comma A
state_8663:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2736;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2736;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY RParen Comma B
state_8664:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2737;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2737;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY RParen Comma C
state_8665:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2738;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2738;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY RParen Comma D
state_8666:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2739;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY RParen Comma E
state_8667:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2740;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2740;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY RParen Comma H
state_8668:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2741;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2741;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY RParen Comma L
state_8669:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2742;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2742;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr
state_8670:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8671;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr RParen
state_8671:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8672;
	case TType::End: goto action_2751;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr RParen Comma
state_8672:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8673;
	case Keyword::B: m_lexer.next(); goto state_8674;
	case Keyword::C: m_lexer.next(); goto state_8675;
	case Keyword::D: m_lexer.next(); goto state_8676;
	case Keyword::E: m_lexer.next(); goto state_8677;
	case Keyword::H: m_lexer.next(); goto state_8678;
	case Keyword::L: m_lexer.next(); goto state_8679;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr RParen Comma A
state_8673:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2744;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2744;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr RParen Comma B
state_8674:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2745;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2745;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr RParen Comma C
state_8675:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2746;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2746;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr RParen Comma D
state_8676:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2747;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2747;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr RParen Comma E
state_8677:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2748;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2748;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr RParen Comma H
state_8678:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2749;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2749;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLA LParen IY expr RParen Comma L
state_8679:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2750;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2750;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI
state_8680:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8681;
	case Keyword::B: m_lexer.next(); goto state_8682;
	case Keyword::C: m_lexer.next(); goto state_8683;
	case Keyword::D: m_lexer.next(); goto state_8684;
	case Keyword::E: m_lexer.next(); goto state_8685;
	case Keyword::H: m_lexer.next(); goto state_8686;
	case Keyword::L: m_lexer.next(); goto state_8687;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8688;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI A
state_8681:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2752;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2752;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI B
state_8682:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2753;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI C
state_8683:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2754;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2754;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI D
state_8684:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2755;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI E
state_8685:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2756;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI H
state_8686:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2757;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI L
state_8687:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2758;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen
state_8688:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8689;
	case Keyword::IX: m_lexer.next(); goto state_8691;
	case Keyword::IY: m_lexer.next(); goto state_8711;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen HL
state_8689:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8690;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen HL RParen
state_8690:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2759;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX
state_8691:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8692;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8701; }
	/*if (check_expr())*/ goto state_8701;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX RParen
state_8692:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8693;
	case TType::End: goto action_2767;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX RParen Comma
state_8693:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8694;
	case Keyword::B: m_lexer.next(); goto state_8695;
	case Keyword::C: m_lexer.next(); goto state_8696;
	case Keyword::D: m_lexer.next(); goto state_8697;
	case Keyword::E: m_lexer.next(); goto state_8698;
	case Keyword::H: m_lexer.next(); goto state_8699;
	case Keyword::L: m_lexer.next(); goto state_8700;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX RParen Comma A
state_8694:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2760;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX RParen Comma B
state_8695:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2761;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX RParen Comma C
state_8696:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2762;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX RParen Comma D
state_8697:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2763;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX RParen Comma E
state_8698:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2764;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX RParen Comma H
state_8699:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2765;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX RParen Comma L
state_8700:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2766;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2766;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr
state_8701:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8702;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr RParen
state_8702:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8703;
	case TType::End: goto action_2775;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2775;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr RParen Comma
state_8703:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8704;
	case Keyword::B: m_lexer.next(); goto state_8705;
	case Keyword::C: m_lexer.next(); goto state_8706;
	case Keyword::D: m_lexer.next(); goto state_8707;
	case Keyword::E: m_lexer.next(); goto state_8708;
	case Keyword::H: m_lexer.next(); goto state_8709;
	case Keyword::L: m_lexer.next(); goto state_8710;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr RParen Comma A
state_8704:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2768;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr RParen Comma B
state_8705:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2769;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2769;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr RParen Comma C
state_8706:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2770;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2770;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr RParen Comma D
state_8707:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2771;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr RParen Comma E
state_8708:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2772;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2772;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr RParen Comma H
state_8709:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2773;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IX expr RParen Comma L
state_8710:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2774;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY
state_8711:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8712;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8721; }
	/*if (check_expr())*/ goto state_8721;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY RParen
state_8712:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8713;
	case TType::End: goto action_2783;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2783;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY RParen Comma
state_8713:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8714;
	case Keyword::B: m_lexer.next(); goto state_8715;
	case Keyword::C: m_lexer.next(); goto state_8716;
	case Keyword::D: m_lexer.next(); goto state_8717;
	case Keyword::E: m_lexer.next(); goto state_8718;
	case Keyword::H: m_lexer.next(); goto state_8719;
	case Keyword::L: m_lexer.next(); goto state_8720;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY RParen Comma A
state_8714:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2776;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2776;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY RParen Comma B
state_8715:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2777;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY RParen Comma C
state_8716:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2778;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2778;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY RParen Comma D
state_8717:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2779;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY RParen Comma E
state_8718:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2780;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2780;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY RParen Comma H
state_8719:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2781;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY RParen Comma L
state_8720:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2782;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr
state_8721:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8722;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr RParen
state_8722:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8723;
	case TType::End: goto action_2791;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr RParen Comma
state_8723:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8724;
	case Keyword::B: m_lexer.next(); goto state_8725;
	case Keyword::C: m_lexer.next(); goto state_8726;
	case Keyword::D: m_lexer.next(); goto state_8727;
	case Keyword::E: m_lexer.next(); goto state_8728;
	case Keyword::H: m_lexer.next(); goto state_8729;
	case Keyword::L: m_lexer.next(); goto state_8730;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr RParen Comma A
state_8724:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2784;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2784;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr RParen Comma B
state_8725:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2785;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr RParen Comma C
state_8726:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2786;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2786;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr RParen Comma D
state_8727:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2787;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2787;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr RParen Comma E
state_8728:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2788;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2788;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr RParen Comma H
state_8729:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2789;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLI LParen IY expr RParen Comma L
state_8730:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2790;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2790;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL
state_8731:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8732;
	case Keyword::B: m_lexer.next(); goto state_8733;
	case Keyword::C: m_lexer.next(); goto state_8734;
	case Keyword::D: m_lexer.next(); goto state_8735;
	case Keyword::E: m_lexer.next(); goto state_8736;
	case Keyword::H: m_lexer.next(); goto state_8737;
	case Keyword::L: m_lexer.next(); goto state_8738;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8739;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL A
state_8732:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2752;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2752;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL B
state_8733:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2753;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL C
state_8734:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2754;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2754;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL D
state_8735:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2755;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL E
state_8736:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2756;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL H
state_8737:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2757;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL L
state_8738:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2758;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen
state_8739:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8740;
	case Keyword::IX: m_lexer.next(); goto state_8742;
	case Keyword::IY: m_lexer.next(); goto state_8762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen HL
state_8740:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8741;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen HL RParen
state_8741:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2759;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX
state_8742:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8743;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8752; }
	/*if (check_expr())*/ goto state_8752;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX RParen
state_8743:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8744;
	case TType::End: goto action_2767;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX RParen Comma
state_8744:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8745;
	case Keyword::B: m_lexer.next(); goto state_8746;
	case Keyword::C: m_lexer.next(); goto state_8747;
	case Keyword::D: m_lexer.next(); goto state_8748;
	case Keyword::E: m_lexer.next(); goto state_8749;
	case Keyword::H: m_lexer.next(); goto state_8750;
	case Keyword::L: m_lexer.next(); goto state_8751;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX RParen Comma A
state_8745:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2760;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX RParen Comma B
state_8746:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2761;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX RParen Comma C
state_8747:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2762;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX RParen Comma D
state_8748:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2763;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX RParen Comma E
state_8749:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2764;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX RParen Comma H
state_8750:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2765;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX RParen Comma L
state_8751:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2766;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2766;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr
state_8752:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr RParen
state_8753:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8754;
	case TType::End: goto action_2775;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2775;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr RParen Comma
state_8754:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8755;
	case Keyword::B: m_lexer.next(); goto state_8756;
	case Keyword::C: m_lexer.next(); goto state_8757;
	case Keyword::D: m_lexer.next(); goto state_8758;
	case Keyword::E: m_lexer.next(); goto state_8759;
	case Keyword::H: m_lexer.next(); goto state_8760;
	case Keyword::L: m_lexer.next(); goto state_8761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr RParen Comma A
state_8755:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2768;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr RParen Comma B
state_8756:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2769;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2769;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr RParen Comma C
state_8757:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2770;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2770;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr RParen Comma D
state_8758:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2771;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr RParen Comma E
state_8759:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2772;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2772;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr RParen Comma H
state_8760:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2773;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IX expr RParen Comma L
state_8761:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2774;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY
state_8762:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8763;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8772; }
	/*if (check_expr())*/ goto state_8772;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY RParen
state_8763:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8764;
	case TType::End: goto action_2783;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2783;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY RParen Comma
state_8764:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8765;
	case Keyword::B: m_lexer.next(); goto state_8766;
	case Keyword::C: m_lexer.next(); goto state_8767;
	case Keyword::D: m_lexer.next(); goto state_8768;
	case Keyword::E: m_lexer.next(); goto state_8769;
	case Keyword::H: m_lexer.next(); goto state_8770;
	case Keyword::L: m_lexer.next(); goto state_8771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY RParen Comma A
state_8765:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2776;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2776;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY RParen Comma B
state_8766:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2777;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY RParen Comma C
state_8767:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2778;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2778;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY RParen Comma D
state_8768:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2779;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY RParen Comma E
state_8769:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2780;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2780;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY RParen Comma H
state_8770:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2781;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY RParen Comma L
state_8771:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2782;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr
state_8772:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr RParen
state_8773:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8774;
	case TType::End: goto action_2791;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr RParen Comma
state_8774:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8775;
	case Keyword::B: m_lexer.next(); goto state_8776;
	case Keyword::C: m_lexer.next(); goto state_8777;
	case Keyword::D: m_lexer.next(); goto state_8778;
	case Keyword::E: m_lexer.next(); goto state_8779;
	case Keyword::H: m_lexer.next(); goto state_8780;
	case Keyword::L: m_lexer.next(); goto state_8781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr RParen Comma A
state_8775:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2784;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2784;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr RParen Comma B
state_8776:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2785;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr RParen Comma C
state_8777:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2786;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2786;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr RParen Comma D
state_8778:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2787;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2787;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr RParen Comma E
state_8779:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2788;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2788;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr RParen Comma H
state_8780:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2789;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLL LParen IY expr RParen Comma L
state_8781:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2790;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2790;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLP
state_8782:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2792;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2792;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS
state_8783:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8784;
	case Keyword::B: m_lexer.next(); goto state_8785;
	case Keyword::C: m_lexer.next(); goto state_8786;
	case Keyword::D: m_lexer.next(); goto state_8787;
	case Keyword::E: m_lexer.next(); goto state_8788;
	case Keyword::H: m_lexer.next(); goto state_8789;
	case Keyword::L: m_lexer.next(); goto state_8790;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS A
state_8784:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2752;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2752;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS B
state_8785:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2753;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2753;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS C
state_8786:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2754;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2754;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS D
state_8787:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2755;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2755;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS E
state_8788:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2756;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2756;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS H
state_8789:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2757;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2757;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS L
state_8790:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2758;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2758;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen
state_8791:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8792;
	case Keyword::IX: m_lexer.next(); goto state_8794;
	case Keyword::IY: m_lexer.next(); goto state_8814;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen HL
state_8792:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8793;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen HL RParen
state_8793:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2759;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2759;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX
state_8794:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8795;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8804; }
	/*if (check_expr())*/ goto state_8804;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX RParen
state_8795:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8796;
	case TType::End: goto action_2767;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2767;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX RParen Comma
state_8796:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8797;
	case Keyword::B: m_lexer.next(); goto state_8798;
	case Keyword::C: m_lexer.next(); goto state_8799;
	case Keyword::D: m_lexer.next(); goto state_8800;
	case Keyword::E: m_lexer.next(); goto state_8801;
	case Keyword::H: m_lexer.next(); goto state_8802;
	case Keyword::L: m_lexer.next(); goto state_8803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX RParen Comma A
state_8797:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2760;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2760;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX RParen Comma B
state_8798:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2761;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2761;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX RParen Comma C
state_8799:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2762;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2762;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX RParen Comma D
state_8800:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2763;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2763;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX RParen Comma E
state_8801:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2764;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2764;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX RParen Comma H
state_8802:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2765;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2765;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX RParen Comma L
state_8803:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2766;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2766;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr
state_8804:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8805;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr RParen
state_8805:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8806;
	case TType::End: goto action_2775;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2775;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr RParen Comma
state_8806:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8807;
	case Keyword::B: m_lexer.next(); goto state_8808;
	case Keyword::C: m_lexer.next(); goto state_8809;
	case Keyword::D: m_lexer.next(); goto state_8810;
	case Keyword::E: m_lexer.next(); goto state_8811;
	case Keyword::H: m_lexer.next(); goto state_8812;
	case Keyword::L: m_lexer.next(); goto state_8813;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr RParen Comma A
state_8807:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2768;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2768;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr RParen Comma B
state_8808:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2769;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2769;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr RParen Comma C
state_8809:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2770;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2770;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr RParen Comma D
state_8810:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2771;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2771;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr RParen Comma E
state_8811:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2772;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2772;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr RParen Comma H
state_8812:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2773;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2773;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IX expr RParen Comma L
state_8813:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2774;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2774;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY
state_8814:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8815;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8824; }
	/*if (check_expr())*/ goto state_8824;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY RParen
state_8815:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8816;
	case TType::End: goto action_2783;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2783;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY RParen Comma
state_8816:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8817;
	case Keyword::B: m_lexer.next(); goto state_8818;
	case Keyword::C: m_lexer.next(); goto state_8819;
	case Keyword::D: m_lexer.next(); goto state_8820;
	case Keyword::E: m_lexer.next(); goto state_8821;
	case Keyword::H: m_lexer.next(); goto state_8822;
	case Keyword::L: m_lexer.next(); goto state_8823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY RParen Comma A
state_8817:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2776;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2776;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY RParen Comma B
state_8818:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2777;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2777;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY RParen Comma C
state_8819:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2778;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2778;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY RParen Comma D
state_8820:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2779;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2779;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY RParen Comma E
state_8821:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2780;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2780;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY RParen Comma H
state_8822:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2781;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2781;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY RParen Comma L
state_8823:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2782;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2782;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr
state_8824:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8825;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr RParen
state_8825:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8826;
	case TType::End: goto action_2791;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr RParen Comma
state_8826:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8827;
	case Keyword::B: m_lexer.next(); goto state_8828;
	case Keyword::C: m_lexer.next(); goto state_8829;
	case Keyword::D: m_lexer.next(); goto state_8830;
	case Keyword::E: m_lexer.next(); goto state_8831;
	case Keyword::H: m_lexer.next(); goto state_8832;
	case Keyword::L: m_lexer.next(); goto state_8833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr RParen Comma A
state_8827:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2784;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2784;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr RParen Comma B
state_8828:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2785;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2785;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr RParen Comma C
state_8829:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2786;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2786;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr RParen Comma D
state_8830:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2787;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2787;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr RParen Comma E
state_8831:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2788;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2788;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr RParen Comma H
state_8832:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2789;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2789;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SLS LParen IY expr RParen Comma L
state_8833:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2790;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2790;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SPHL
state_8834:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2165;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA
state_8835:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8836;
	case Keyword::A1: m_lexer.next(); goto state_8837;
	case Keyword::B: m_lexer.next(); goto state_8838;
	case Keyword::B1: m_lexer.next(); goto state_8839;
	case Keyword::BC: m_lexer.next(); goto state_8840;
	case Keyword::C: m_lexer.next(); goto state_8841;
	case Keyword::C1: m_lexer.next(); goto state_8842;
	case Keyword::D: m_lexer.next(); goto state_8843;
	case Keyword::D1: m_lexer.next(); goto state_8844;
	case Keyword::DE: m_lexer.next(); goto state_8845;
	case Keyword::E: m_lexer.next(); goto state_8846;
	case Keyword::E1: m_lexer.next(); goto state_8847;
	case Keyword::H: m_lexer.next(); goto state_8848;
	case Keyword::H1: m_lexer.next(); goto state_8849;
	case Keyword::HL: m_lexer.next(); goto state_8850;
	case Keyword::L: m_lexer.next(); goto state_8851;
	case Keyword::L1: m_lexer.next(); goto state_8852;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8853;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA A
state_8836:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2793;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2793;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA A1
state_8837:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_790;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_790;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA B
state_8838:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2794;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2794;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA B1
state_8839:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_791;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_791;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA BC
state_8840:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2795;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2795;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA C
state_8841:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2796;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2796;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA C1
state_8842:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_792;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_792;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA D
state_8843:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2797;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2797;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA D1
state_8844:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_793;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_793;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA DE
state_8845:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2798;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2798;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA E
state_8846:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2799;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2799;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA E1
state_8847:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_794;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_794;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA H
state_8848:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2800;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2800;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA H1
state_8849:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_795;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_795;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA HL
state_8850:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_866;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA L
state_8851:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2801;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2801;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA L1
state_8852:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_796;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_796;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen
state_8853:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8854;
	case Keyword::IX: m_lexer.next(); goto state_8856;
	case Keyword::IY: m_lexer.next(); goto state_8876;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen HL
state_8854:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8855;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen HL RParen
state_8855:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2802;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2802;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX
state_8856:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8857;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8866; }
	/*if (check_expr())*/ goto state_8866;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX RParen
state_8857:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8858;
	case TType::End: goto action_2810;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2810;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX RParen Comma
state_8858:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8859;
	case Keyword::B: m_lexer.next(); goto state_8860;
	case Keyword::C: m_lexer.next(); goto state_8861;
	case Keyword::D: m_lexer.next(); goto state_8862;
	case Keyword::E: m_lexer.next(); goto state_8863;
	case Keyword::H: m_lexer.next(); goto state_8864;
	case Keyword::L: m_lexer.next(); goto state_8865;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX RParen Comma A
state_8859:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2803;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX RParen Comma B
state_8860:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2804;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2804;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX RParen Comma C
state_8861:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2805;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2805;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX RParen Comma D
state_8862:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2806;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2806;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX RParen Comma E
state_8863:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2807;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2807;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX RParen Comma H
state_8864:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2808;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2808;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX RParen Comma L
state_8865:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2809;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2809;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr
state_8866:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8867;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr RParen
state_8867:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8868;
	case TType::End: goto action_2818;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2818;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr RParen Comma
state_8868:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8869;
	case Keyword::B: m_lexer.next(); goto state_8870;
	case Keyword::C: m_lexer.next(); goto state_8871;
	case Keyword::D: m_lexer.next(); goto state_8872;
	case Keyword::E: m_lexer.next(); goto state_8873;
	case Keyword::H: m_lexer.next(); goto state_8874;
	case Keyword::L: m_lexer.next(); goto state_8875;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr RParen Comma A
state_8869:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2811;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2811;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr RParen Comma B
state_8870:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2812;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2812;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr RParen Comma C
state_8871:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2813;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2813;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr RParen Comma D
state_8872:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2814;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2814;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr RParen Comma E
state_8873:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2815;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr RParen Comma H
state_8874:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2816;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2816;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IX expr RParen Comma L
state_8875:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2817;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2817;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY
state_8876:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8877;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8886; }
	/*if (check_expr())*/ goto state_8886;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY RParen
state_8877:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8878;
	case TType::End: goto action_2826;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY RParen Comma
state_8878:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8879;
	case Keyword::B: m_lexer.next(); goto state_8880;
	case Keyword::C: m_lexer.next(); goto state_8881;
	case Keyword::D: m_lexer.next(); goto state_8882;
	case Keyword::E: m_lexer.next(); goto state_8883;
	case Keyword::H: m_lexer.next(); goto state_8884;
	case Keyword::L: m_lexer.next(); goto state_8885;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY RParen Comma A
state_8879:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2819;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2819;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY RParen Comma B
state_8880:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2820;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2820;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY RParen Comma C
state_8881:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2821;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2821;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY RParen Comma D
state_8882:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2822;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2822;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY RParen Comma E
state_8883:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2823;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY RParen Comma H
state_8884:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2824;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2824;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY RParen Comma L
state_8885:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2825;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2825;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr
state_8886:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8887;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr RParen
state_8887:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8888;
	case TType::End: goto action_2834;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2834;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr RParen Comma
state_8888:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8889;
	case Keyword::B: m_lexer.next(); goto state_8890;
	case Keyword::C: m_lexer.next(); goto state_8891;
	case Keyword::D: m_lexer.next(); goto state_8892;
	case Keyword::E: m_lexer.next(); goto state_8893;
	case Keyword::H: m_lexer.next(); goto state_8894;
	case Keyword::L: m_lexer.next(); goto state_8895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr RParen Comma A
state_8889:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2827;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2827;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr RParen Comma B
state_8890:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2828;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2828;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr RParen Comma C
state_8891:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2829;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2829;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr RParen Comma D
state_8892:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2830;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2830;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr RParen Comma E
state_8893:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2831;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2831;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr RParen Comma H
state_8894:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2832;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2832;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRA LParen IY expr RParen Comma L
state_8895:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2833;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL
state_8896:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8897;
	case Keyword::A1: m_lexer.next(); goto state_8898;
	case Keyword::B: m_lexer.next(); goto state_8899;
	case Keyword::B1: m_lexer.next(); goto state_8900;
	case Keyword::C: m_lexer.next(); goto state_8901;
	case Keyword::C1: m_lexer.next(); goto state_8902;
	case Keyword::D: m_lexer.next(); goto state_8903;
	case Keyword::D1: m_lexer.next(); goto state_8904;
	case Keyword::E: m_lexer.next(); goto state_8905;
	case Keyword::E1: m_lexer.next(); goto state_8906;
	case Keyword::H: m_lexer.next(); goto state_8907;
	case Keyword::H1: m_lexer.next(); goto state_8908;
	case Keyword::L: m_lexer.next(); goto state_8909;
	case Keyword::L1: m_lexer.next(); goto state_8910;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL A
state_8897:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2835;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL A1
state_8898:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_802;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_802;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL B
state_8899:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2836;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2836;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL B1
state_8900:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_803;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_803;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL C
state_8901:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2837;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2837;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL C1
state_8902:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_804;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_804;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL D
state_8903:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2838;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL D1
state_8904:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_805;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_805;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL E
state_8905:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2839;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2839;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL E1
state_8906:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_806;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_806;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL H
state_8907:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2840;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2840;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL H1
state_8908:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_807;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_807;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL L
state_8909:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2841;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL L1
state_8910:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_808;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_808;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen
state_8911:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8912;
	case Keyword::IX: m_lexer.next(); goto state_8914;
	case Keyword::IY: m_lexer.next(); goto state_8934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen HL
state_8912:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen HL RParen
state_8913:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2842;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2842;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX
state_8914:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8915;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8924; }
	/*if (check_expr())*/ goto state_8924;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX RParen
state_8915:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8916;
	case TType::End: goto action_2850;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2850;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX RParen Comma
state_8916:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8917;
	case Keyword::B: m_lexer.next(); goto state_8918;
	case Keyword::C: m_lexer.next(); goto state_8919;
	case Keyword::D: m_lexer.next(); goto state_8920;
	case Keyword::E: m_lexer.next(); goto state_8921;
	case Keyword::H: m_lexer.next(); goto state_8922;
	case Keyword::L: m_lexer.next(); goto state_8923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX RParen Comma A
state_8917:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2843;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2843;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX RParen Comma B
state_8918:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2844;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2844;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX RParen Comma C
state_8919:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2845;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2845;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX RParen Comma D
state_8920:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2846;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2846;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX RParen Comma E
state_8921:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2847;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2847;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX RParen Comma H
state_8922:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2848;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2848;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX RParen Comma L
state_8923:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2849;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2849;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr
state_8924:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr RParen
state_8925:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8926;
	case TType::End: goto action_2858;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2858;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr RParen Comma
state_8926:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8927;
	case Keyword::B: m_lexer.next(); goto state_8928;
	case Keyword::C: m_lexer.next(); goto state_8929;
	case Keyword::D: m_lexer.next(); goto state_8930;
	case Keyword::E: m_lexer.next(); goto state_8931;
	case Keyword::H: m_lexer.next(); goto state_8932;
	case Keyword::L: m_lexer.next(); goto state_8933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr RParen Comma A
state_8927:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2851;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2851;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr RParen Comma B
state_8928:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2852;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2852;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr RParen Comma C
state_8929:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2853;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2853;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr RParen Comma D
state_8930:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2854;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2854;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr RParen Comma E
state_8931:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2855;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2855;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr RParen Comma H
state_8932:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2856;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2856;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IX expr RParen Comma L
state_8933:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2857;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2857;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY
state_8934:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8935;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8944; }
	/*if (check_expr())*/ goto state_8944;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY RParen
state_8935:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8936;
	case TType::End: goto action_2866;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2866;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY RParen Comma
state_8936:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8937;
	case Keyword::B: m_lexer.next(); goto state_8938;
	case Keyword::C: m_lexer.next(); goto state_8939;
	case Keyword::D: m_lexer.next(); goto state_8940;
	case Keyword::E: m_lexer.next(); goto state_8941;
	case Keyword::H: m_lexer.next(); goto state_8942;
	case Keyword::L: m_lexer.next(); goto state_8943;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY RParen Comma A
state_8937:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2859;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2859;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY RParen Comma B
state_8938:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2860;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2860;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY RParen Comma C
state_8939:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2861;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2861;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY RParen Comma D
state_8940:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2862;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2862;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY RParen Comma E
state_8941:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2863;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2863;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY RParen Comma H
state_8942:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2864;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2864;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY RParen Comma L
state_8943:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2865;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2865;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr
state_8944:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8945;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr RParen
state_8945:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8946;
	case TType::End: goto action_2874;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2874;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr RParen Comma
state_8946:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8947;
	case Keyword::B: m_lexer.next(); goto state_8948;
	case Keyword::C: m_lexer.next(); goto state_8949;
	case Keyword::D: m_lexer.next(); goto state_8950;
	case Keyword::E: m_lexer.next(); goto state_8951;
	case Keyword::H: m_lexer.next(); goto state_8952;
	case Keyword::L: m_lexer.next(); goto state_8953;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr RParen Comma A
state_8947:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2867;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2867;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr RParen Comma B
state_8948:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2868;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2868;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr RParen Comma C
state_8949:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2869;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2869;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr RParen Comma D
state_8950:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2870;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2870;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr RParen Comma E
state_8951:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2871;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2871;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr RParen Comma H
state_8952:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2872;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2872;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SRL LParen IY expr RParen Comma L
state_8953:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2873;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2873;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: STA
state_8954:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8955; }
	/*if (check_expr())*/ goto state_8955;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: STA expr
state_8955:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2875;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2875;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: STAE
state_8956:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2708;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2708;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: STAX
state_8957:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::B: m_lexer.next(); goto state_8958;
	case Keyword::BC: m_lexer.next(); goto state_8959;
	case Keyword::D: m_lexer.next(); goto state_8960;
	case Keyword::DE: m_lexer.next(); goto state_8961;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: STAX B
state_8958:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2172;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2172;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: STAX BC
state_8959:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2172;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2172;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: STAX D
state_8960:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2190;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: STAX DE
state_8961:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2190;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2190;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: STC
state_8962:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2667;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2667;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: STOP
state_8963:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2876;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2876;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB
state_8964:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8965;
	case Keyword::A1: m_lexer.next(); goto state_8994;
	case Keyword::B: m_lexer.next(); goto state_9019;
	case Keyword::C: m_lexer.next(); goto state_9020;
	case Keyword::D: m_lexer.next(); goto state_9021;
	case Keyword::E: m_lexer.next(); goto state_9022;
	case Keyword::H: m_lexer.next(); goto state_9023;
	case Keyword::HL: m_lexer.next(); goto state_9024;
	case Keyword::IXH: m_lexer.next(); goto state_9030;
	case Keyword::IXL: m_lexer.next(); goto state_9031;
	case Keyword::IYH: m_lexer.next(); goto state_9032;
	case Keyword::IYL: m_lexer.next(); goto state_9033;
	case Keyword::L: m_lexer.next(); goto state_9034;
	case Keyword::M: m_lexer.next(); goto state_9035;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_9036;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9051; }
	/*if (check_expr())*/ goto state_9051;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A
state_8965:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8966;
	case TType::End: goto action_2877;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2877;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma
state_8966:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8967;
	case Keyword::B: m_lexer.next(); goto state_8968;
	case Keyword::C: m_lexer.next(); goto state_8969;
	case Keyword::D: m_lexer.next(); goto state_8970;
	case Keyword::E: m_lexer.next(); goto state_8971;
	case Keyword::H: m_lexer.next(); goto state_8972;
	case Keyword::IXH: m_lexer.next(); goto state_8973;
	case Keyword::IXL: m_lexer.next(); goto state_8974;
	case Keyword::IYH: m_lexer.next(); goto state_8975;
	case Keyword::IYL: m_lexer.next(); goto state_8976;
	case Keyword::L: m_lexer.next(); goto state_8977;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_8978;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8993; }
	/*if (check_expr())*/ goto state_8993;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma A
state_8967:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2877;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2877;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma B
state_8968:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2878;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2878;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma C
state_8969:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2879;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2879;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma D
state_8970:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2880;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2880;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma E
state_8971:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2881;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2881;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma H
state_8972:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2882;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2882;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma IXH
state_8973:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2883;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2883;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma IXL
state_8974:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2884;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2884;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma IYH
state_8975:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2885;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2885;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma IYL
state_8976:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2886;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2886;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma L
state_8977:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2887;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2887;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen
state_8978:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_8979;
	case Keyword::IX: m_lexer.next(); goto state_8985;
	case Keyword::IY: m_lexer.next(); goto state_8989;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen HL
state_8979:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_8980;
	case TType::Plus: m_lexer.next(); goto state_8982;
	case TType::RParen: m_lexer.next(); goto state_8984;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen HL Minus
state_8980:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8981;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen HL Minus RParen
state_8981:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2888;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen HL Plus
state_8982:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8983;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen HL Plus RParen
state_8983:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2889;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2889;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen HL RParen
state_8984:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2890;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2890;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen IX
state_8985:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8986;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8987; }
	/*if (check_expr())*/ goto state_8987;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen IX RParen
state_8986:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2891;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2891;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen IX expr
state_8987:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8988;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen IX expr RParen
state_8988:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen IY
state_8989:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8990;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_8991; }
	/*if (check_expr())*/ goto state_8991;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen IY RParen
state_8990:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2893;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2893;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen IY expr
state_8991:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_8992;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma LParen IY expr RParen
state_8992:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2894;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2894;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A Comma expr
state_8993:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1
state_8994:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_8995;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma
state_8995:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_8996;
	case Keyword::B: m_lexer.next(); goto state_8997;
	case Keyword::C: m_lexer.next(); goto state_8998;
	case Keyword::D: m_lexer.next(); goto state_8999;
	case Keyword::E: m_lexer.next(); goto state_9000;
	case Keyword::H: m_lexer.next(); goto state_9001;
	case Keyword::L: m_lexer.next(); goto state_9002;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_9003;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9018; }
	/*if (check_expr())*/ goto state_9018;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma A
state_8996:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_814;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_814;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma B
state_8997:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_815;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_815;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma C
state_8998:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_816;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_816;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma D
state_8999:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_817;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_817;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma E
state_9000:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_818;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_818;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma H
state_9001:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_819;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_819;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma L
state_9002:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_820;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_820;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen
state_9003:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9004;
	case Keyword::IX: m_lexer.next(); goto state_9010;
	case Keyword::IY: m_lexer.next(); goto state_9014;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen HL
state_9004:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_9005;
	case TType::Plus: m_lexer.next(); goto state_9007;
	case TType::RParen: m_lexer.next(); goto state_9009;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen HL Minus
state_9005:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9006;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen HL Minus RParen
state_9006:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_821;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_821;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen HL Plus
state_9007:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9008;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen HL Plus RParen
state_9008:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_822;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_822;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen HL RParen
state_9009:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_823;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_823;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen IX
state_9010:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9011;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9012; }
	/*if (check_expr())*/ goto state_9012;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen IX RParen
state_9011:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_824;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_824;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen IX expr
state_9012:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9013;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen IX expr RParen
state_9013:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_825;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_825;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen IY
state_9014:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9015;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9016; }
	/*if (check_expr())*/ goto state_9016;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen IY RParen
state_9015:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_826;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_826;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen IY expr
state_9016:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9017;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma LParen IY expr RParen
state_9017:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_827;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_827;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB A1 Comma expr
state_9018:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_828;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_828;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB B
state_9019:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2878;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2878;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB C
state_9020:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2879;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2879;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB D
state_9021:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2880;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2880;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB E
state_9022:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2881;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2881;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB H
state_9023:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2882;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2882;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB HL
state_9024:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_9025;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB HL Comma
state_9025:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::BC: m_lexer.next(); goto state_9026;
	case Keyword::DE: m_lexer.next(); goto state_9027;
	case Keyword::HL: m_lexer.next(); goto state_9028;
	case Keyword::SP: m_lexer.next(); goto state_9029;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB HL Comma BC
state_9026:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_950;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_950;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB HL Comma DE
state_9027:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2896;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2896;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB HL Comma HL
state_9028:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2897;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2897;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB HL Comma SP
state_9029:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2898;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2898;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB IXH
state_9030:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2883;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2883;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB IXL
state_9031:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2884;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2884;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB IYH
state_9032:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2885;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2885;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB IYL
state_9033:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2886;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2886;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB L
state_9034:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2887;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2887;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB M
state_9035:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2890;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2890;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen
state_9036:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9037;
	case Keyword::IX: m_lexer.next(); goto state_9043;
	case Keyword::IY: m_lexer.next(); goto state_9047;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen HL
state_9037:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_9038;
	case TType::Plus: m_lexer.next(); goto state_9040;
	case TType::RParen: m_lexer.next(); goto state_9042;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen HL Minus
state_9038:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9039;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen HL Minus RParen
state_9039:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2888;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2888;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen HL Plus
state_9040:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9041;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen HL Plus RParen
state_9041:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2889;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2889;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen HL RParen
state_9042:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2890;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2890;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen IX
state_9043:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9044;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9045; }
	/*if (check_expr())*/ goto state_9045;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen IX RParen
state_9044:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2891;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2891;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen IX expr
state_9045:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9046;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen IX expr RParen
state_9046:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2892;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2892;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen IY
state_9047:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9048;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9049; }
	/*if (check_expr())*/ goto state_9049;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen IY RParen
state_9048:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2893;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2893;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen IY expr
state_9049:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9050;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB LParen IY expr RParen
state_9050:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2894;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2894;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUB expr
state_9051:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUI
state_9052:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9053; }
	/*if (check_expr())*/ goto state_9053;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: SUI expr
state_9053:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2895;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2895;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SURES
state_9054:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2899;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2899;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP
state_9055:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_9056;
	case Keyword::B: m_lexer.next(); goto state_9057;
	case Keyword::C: m_lexer.next(); goto state_9058;
	case Keyword::D: m_lexer.next(); goto state_9059;
	case Keyword::E: m_lexer.next(); goto state_9060;
	case Keyword::H: m_lexer.next(); goto state_9061;
	case Keyword::L: m_lexer.next(); goto state_9062;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2907;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2907;
	case TType::LParen: m_lexer.next(); goto state_9063;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP A
state_9056:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2900;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2900;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP B
state_9057:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2901;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2901;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP C
state_9058:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2902;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2902;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP D
state_9059:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2903;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2903;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP E
state_9060:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2904;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2904;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP H
state_9061:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2905;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2905;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP L
state_9062:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2906;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2906;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP LParen
state_9063:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9064;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP LParen HL
state_9064:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9065;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAP LParen HL RParen
state_9065:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2908;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2908;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SWAPNIB
state_9066:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2907;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2907;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: SYSCALL
state_9067:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2909;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2909;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST
state_9068:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_9069;
	case Keyword::B: m_lexer.next(); goto state_9082;
	case Keyword::C: m_lexer.next(); goto state_9083;
	case Keyword::D: m_lexer.next(); goto state_9084;
	case Keyword::E: m_lexer.next(); goto state_9085;
	case Keyword::H: m_lexer.next(); goto state_9086;
	case Keyword::L: m_lexer.next(); goto state_9087;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_9088;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9091; }
	/*if (check_expr())*/ goto state_9091;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A
state_9069:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_9070;
	case TType::End: goto action_2910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma
state_9070:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_9071;
	case Keyword::B: m_lexer.next(); goto state_9072;
	case Keyword::C: m_lexer.next(); goto state_9073;
	case Keyword::D: m_lexer.next(); goto state_9074;
	case Keyword::E: m_lexer.next(); goto state_9075;
	case Keyword::H: m_lexer.next(); goto state_9076;
	case Keyword::L: m_lexer.next(); goto state_9077;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_9078;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9081; }
	/*if (check_expr())*/ goto state_9081;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma A
state_9071:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma B
state_9072:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma C
state_9073:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma D
state_9074:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma E
state_9075:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma H
state_9076:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma L
state_9077:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma LParen
state_9078:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9079;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma LParen HL
state_9079:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9080;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma LParen HL RParen
state_9080:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST A Comma expr
state_9081:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST B
state_9082:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST C
state_9083:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST D
state_9084:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST E
state_9085:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST H
state_9086:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST L
state_9087:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST LParen
state_9088:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9089;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST LParen HL
state_9089:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9090;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST LParen HL RParen
state_9090:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TEST expr
state_9091:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST
state_9092:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_9093;
	case Keyword::B: m_lexer.next(); goto state_9106;
	case Keyword::C: m_lexer.next(); goto state_9107;
	case Keyword::D: m_lexer.next(); goto state_9108;
	case Keyword::E: m_lexer.next(); goto state_9109;
	case Keyword::H: m_lexer.next(); goto state_9110;
	case Keyword::L: m_lexer.next(); goto state_9111;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_9112;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9115; }
	/*if (check_expr())*/ goto state_9115;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A
state_9093:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_9094;
	case TType::End: goto action_2910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma
state_9094:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_9095;
	case Keyword::B: m_lexer.next(); goto state_9096;
	case Keyword::C: m_lexer.next(); goto state_9097;
	case Keyword::D: m_lexer.next(); goto state_9098;
	case Keyword::E: m_lexer.next(); goto state_9099;
	case Keyword::H: m_lexer.next(); goto state_9100;
	case Keyword::L: m_lexer.next(); goto state_9101;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_9102;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9105; }
	/*if (check_expr())*/ goto state_9105;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma A
state_9095:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2910;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2910;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma B
state_9096:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma C
state_9097:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma D
state_9098:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma E
state_9099:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma H
state_9100:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma L
state_9101:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma LParen
state_9102:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9103;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma LParen HL
state_9103:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9104;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma LParen HL RParen
state_9104:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST A Comma expr
state_9105:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST B
state_9106:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2911;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2911;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST C
state_9107:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2912;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2912;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST D
state_9108:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2913;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2913;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST E
state_9109:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2914;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2914;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST H
state_9110:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2915;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2915;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST L
state_9111:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2916;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2916;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST LParen
state_9112:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9113;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST LParen HL
state_9113:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9114;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST LParen HL RParen
state_9114:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2917;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2917;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TST expr
state_9115:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2918;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2918;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: TSTIO
state_9116:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9117; }
	/*if (check_expr())*/ goto state_9117;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: TSTIO expr
state_9117:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2919;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2919;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: UMA
state_9118:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2920;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2920;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: UMS
state_9119:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2921;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2921;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XCHG
state_9120:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_953;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_953;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR
state_9121:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_9122;
	case Keyword::A1: m_lexer.next(); goto state_9151;
	case Keyword::B: m_lexer.next(); goto state_9176;
	case Keyword::C: m_lexer.next(); goto state_9177;
	case Keyword::D: m_lexer.next(); goto state_9178;
	case Keyword::E: m_lexer.next(); goto state_9179;
	case Keyword::H: m_lexer.next(); goto state_9180;
	case Keyword::IXH: m_lexer.next(); goto state_9181;
	case Keyword::IXL: m_lexer.next(); goto state_9182;
	case Keyword::IYH: m_lexer.next(); goto state_9183;
	case Keyword::IYL: m_lexer.next(); goto state_9184;
	case Keyword::L: m_lexer.next(); goto state_9185;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_9186;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9201; }
	/*if (check_expr())*/ goto state_9201;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A
state_9122:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_9123;
	case TType::End: goto action_2922;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2922;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma
state_9123:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_9124;
	case Keyword::B: m_lexer.next(); goto state_9125;
	case Keyword::C: m_lexer.next(); goto state_9126;
	case Keyword::D: m_lexer.next(); goto state_9127;
	case Keyword::E: m_lexer.next(); goto state_9128;
	case Keyword::H: m_lexer.next(); goto state_9129;
	case Keyword::IXH: m_lexer.next(); goto state_9130;
	case Keyword::IXL: m_lexer.next(); goto state_9131;
	case Keyword::IYH: m_lexer.next(); goto state_9132;
	case Keyword::IYL: m_lexer.next(); goto state_9133;
	case Keyword::L: m_lexer.next(); goto state_9134;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_9135;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9150; }
	/*if (check_expr())*/ goto state_9150;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma A
state_9124:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2922;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2922;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma B
state_9125:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2923;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma C
state_9126:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2924;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma D
state_9127:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2925;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma E
state_9128:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2926;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma H
state_9129:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2927;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2927;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma IXH
state_9130:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2928;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2928;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma IXL
state_9131:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2929;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2929;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma IYH
state_9132:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2930;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma IYL
state_9133:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2931;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma L
state_9134:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2932;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen
state_9135:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9136;
	case Keyword::IX: m_lexer.next(); goto state_9142;
	case Keyword::IY: m_lexer.next(); goto state_9146;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen HL
state_9136:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_9137;
	case TType::Plus: m_lexer.next(); goto state_9139;
	case TType::RParen: m_lexer.next(); goto state_9141;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen HL Minus
state_9137:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9138;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen HL Minus RParen
state_9138:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2933;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen HL Plus
state_9139:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9140;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen HL Plus RParen
state_9140:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2934;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen HL RParen
state_9141:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2935;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen IX
state_9142:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9143;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9144; }
	/*if (check_expr())*/ goto state_9144;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen IX RParen
state_9143:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2936;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2936;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen IX expr
state_9144:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9145;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen IX expr RParen
state_9145:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2937;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2937;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen IY
state_9146:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9147;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9148; }
	/*if (check_expr())*/ goto state_9148;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen IY RParen
state_9147:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2938;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2938;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen IY expr
state_9148:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9149;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma LParen IY expr RParen
state_9149:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2939;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2939;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A Comma expr
state_9150:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2940;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2940;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1
state_9151:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Comma: m_lexer.next(); goto state_9152;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma
state_9152:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_9153;
	case Keyword::B: m_lexer.next(); goto state_9154;
	case Keyword::C: m_lexer.next(); goto state_9155;
	case Keyword::D: m_lexer.next(); goto state_9156;
	case Keyword::E: m_lexer.next(); goto state_9157;
	case Keyword::H: m_lexer.next(); goto state_9158;
	case Keyword::L: m_lexer.next(); goto state_9159;
	default:;
	}

	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::LParen: m_lexer.next(); goto state_9160;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9175; }
	/*if (check_expr())*/ goto state_9175;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma A
state_9153:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_829;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_829;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma B
state_9154:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_830;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_830;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma C
state_9155:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_831;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_831;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma D
state_9156:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_832;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_832;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma E
state_9157:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_833;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_833;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma H
state_9158:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_834;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_834;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma L
state_9159:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_835;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_835;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen
state_9160:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9161;
	case Keyword::IX: m_lexer.next(); goto state_9167;
	case Keyword::IY: m_lexer.next(); goto state_9171;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen HL
state_9161:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_9162;
	case TType::Plus: m_lexer.next(); goto state_9164;
	case TType::RParen: m_lexer.next(); goto state_9166;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen HL Minus
state_9162:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9163;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen HL Minus RParen
state_9163:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_836;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_836;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen HL Plus
state_9164:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9165;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen HL Plus RParen
state_9165:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_837;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_837;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen HL RParen
state_9166:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_838;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_838;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen IX
state_9167:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9168;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9169; }
	/*if (check_expr())*/ goto state_9169;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen IX RParen
state_9168:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_839;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_839;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen IX expr
state_9169:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9170;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen IX expr RParen
state_9170:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_840;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_840;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen IY
state_9171:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9172;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9173; }
	/*if (check_expr())*/ goto state_9173;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen IY RParen
state_9172:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_841;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_841;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen IY expr
state_9173:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9174;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma LParen IY expr RParen
state_9174:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_842;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_842;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR A1 Comma expr
state_9175:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_843;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_843;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR B
state_9176:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2923;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR C
state_9177:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2924;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR D
state_9178:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2925;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR E
state_9179:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2926;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR H
state_9180:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2927;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2927;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR IXH
state_9181:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2928;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2928;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR IXL
state_9182:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2929;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2929;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR IYH
state_9183:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2930;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2930;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR IYL
state_9184:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2931;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2931;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR L
state_9185:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2932;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen
state_9186:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::HL: m_lexer.next(); goto state_9187;
	case Keyword::IX: m_lexer.next(); goto state_9193;
	case Keyword::IY: m_lexer.next(); goto state_9197;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen HL
state_9187:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::Minus: m_lexer.next(); goto state_9188;
	case TType::Plus: m_lexer.next(); goto state_9190;
	case TType::RParen: m_lexer.next(); goto state_9192;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen HL Minus
state_9188:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9189;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen HL Minus RParen
state_9189:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2933;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2933;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen HL Plus
state_9190:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9191;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen HL Plus RParen
state_9191:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2934;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2934;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen HL RParen
state_9192:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2935;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen IX
state_9193:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9194;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9195; }
	/*if (check_expr())*/ goto state_9195;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen IX RParen
state_9194:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2936;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2936;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen IX expr
state_9195:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9196;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen IX expr RParen
state_9196:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2937;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2937;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen IY
state_9197:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9198;
	default:;
	}

	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9199; }
	/*if (check_expr())*/ goto state_9199;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen IY RParen
state_9198:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2938;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2938;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen IY expr
state_9199:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::RParen: m_lexer.next(); goto state_9200;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR LParen IY expr RParen
state_9200:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2939;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2939;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XOR expr
state_9201:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2940;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2940;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRA
state_9202:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::A: m_lexer.next(); goto state_9203;
	case Keyword::B: m_lexer.next(); goto state_9204;
	case Keyword::C: m_lexer.next(); goto state_9205;
	case Keyword::D: m_lexer.next(); goto state_9206;
	case Keyword::E: m_lexer.next(); goto state_9207;
	case Keyword::H: m_lexer.next(); goto state_9208;
	case Keyword::L: m_lexer.next(); goto state_9209;
	case Keyword::M: m_lexer.next(); goto state_9210;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRA A
state_9203:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2922;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2922;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRA B
state_9204:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2923;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2923;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRA C
state_9205:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2924;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2924;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRA D
state_9206:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2925;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2925;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRA E
state_9207:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2926;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2926;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRA H
state_9208:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2927;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2927;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRA L
state_9209:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2932;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2932;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRA M
state_9210:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2935;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2935;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRI
state_9211:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9212; }
	/*if (check_expr())*/ goto state_9212;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: XRI expr
state_9212:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2940;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2940;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: XTHL
state_9213:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_2941;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_2941;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: Label
state_9214:
	// check keywords
	switch (m_lexer.peek().keyword) {
	case Keyword::EQU: m_lexer.next(); goto state_9215;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// state: Label EQU
state_9215:
	// check expression
	{ Expr e(m_lexer, *this); if (e.parse()) goto state_9216; }
	/*if (check_expr())*/ goto state_9216;
	g_errors.error(ErrCode::Syntax);
	return false;

// state: Label EQU expr
state_9216:
	// check tokens
	switch (m_lexer.peek().ttype) {
	case TType::End: goto action_958;
	case TType::Backslash:
	case TType::Newline: m_lexer.next(); goto action_958;
	default:;
	}

	g_errors.error(ErrCode::Syntax);
	return false;

// action for: ACI expr End | ADC A Comma expr End | ADC expr End
action_0:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xCE)*/;
return true;

// action for: ADC A Comma A End | ADC A End
action_1:
/*DO_stmt(0x8F)*/;
return true;

// action for: ADC A Comma B End | ADC B End
action_2:
/*DO_stmt(0x88)*/;
return true;

// action for: ADC A Comma C End | ADC C End
action_3:
/*DO_stmt(0x89)*/;
return true;

// action for: ADC A Comma D End | ADC D End
action_4:
/*DO_stmt(0x8A)*/;
return true;

// action for: ADC A Comma E End | ADC E End
action_5:
/*DO_stmt(0x8B)*/;
return true;

// action for: ADC A Comma H End | ADC H End
action_6:
/*DO_stmt(0x8C)*/;
return true;

// action for: ADC A Comma IXH End | ADC IXH End
action_7:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD8C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A Comma IXL End | ADC IXL End
action_8:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD8D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A Comma IYH End | ADC IYH End
action_9:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD8C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A Comma IYL End | ADC IYL End
action_10:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD8D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A Comma L End | ADC L End
action_11:
/*DO_stmt(0x8D)*/;
return true;

// action for: ADC A Comma LParen HL Minus RParen End | ADC LParen HL Minus RParen End
action_12:
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: ADC A Comma LParen HL Plus RParen End | ADC LParen HL Plus RParen End
action_13:
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: ADC A Comma LParen HL RParen End | ADC M End | ADC LParen HL RParen End
action_14:
/*DO_stmt(0x8E)*/;
return true;

// action for: ADC A Comma LParen IX RParen End | ADC LParen IX RParen End
action_15:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A Comma LParen IX expr RParen End | ADC LParen IX expr RParen End
action_16:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A Comma LParen IY RParen End | ADC LParen IY RParen End
action_17:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A Comma LParen IY expr RParen End | ADC LParen IY expr RParen End
action_18:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma A End | ALTD ADC A Comma A End | ALTD ADC A End
action_19:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma B End | ALTD ADC A Comma B End | ALTD ADC B End
action_20:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x88)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma C End | ALTD ADC A Comma C End | ALTD ADC C End
action_21:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x89)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma D End | ALTD ADC A Comma D End | ALTD ADC D End
action_22:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma E End | ALTD ADC A Comma E End | ALTD ADC E End
action_23:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma H End | ALTD ADC A Comma H End | ALTD ADC H End
action_24:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma L End | ALTD ADC A Comma L End | ALTD ADC L End
action_25:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma LParen HL Minus RParen End | ALTD ADC A Comma LParen HL Minus RParen End | ALTD ADC LParen HL Minus RParen End
action_26:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma LParen HL Plus RParen End | ALTD ADC A Comma LParen HL Plus RParen End | ALTD ADC LParen HL Plus RParen End
action_27:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma LParen HL RParen End | ALTD ADC A Comma LParen HL RParen End | ALTD ADC LParen HL RParen End
action_28:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma LParen IX RParen End | ALTD ADC A Comma LParen IX RParen End | ALTD ADC LParen IX RParen End
action_29:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma LParen IX expr RParen End | ALTD ADC A Comma LParen IX expr RParen End | ALTD ADC LParen IX expr RParen End
action_30:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma LParen IY RParen End | ALTD ADC A Comma LParen IY RParen End | ALTD ADC LParen IY RParen End
action_31:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma LParen IY expr RParen End | ALTD ADC A Comma LParen IY expr RParen End | ALTD ADC LParen IY expr RParen End
action_32:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC A1 Comma expr End | ALTD ADC A Comma expr End | ALTD ADC expr End
action_33:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0xCE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC HL Comma BC End
action_34:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__adc_hl_bc")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED4A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC HL Comma DE End
action_35:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__adc_hl_de")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED5A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC HL Comma HL End
action_36:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__adc_hl_hl")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED6A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC HL Comma SP End
action_37:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__adc_hl_sp")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED7A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC HL1 Comma BC End | ALTD ADC HL Comma BC End
action_38:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED4A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC HL1 Comma DE End | ALTD ADC HL Comma DE End
action_39:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED5A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC HL1 Comma HL End | ALTD ADC HL Comma HL End
action_40:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED6A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADC HL1 Comma SP End | ALTD ADC HL Comma SP End
action_41:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED7A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A Comma A End | ADD A End
action_42:
/*DO_stmt(0x87)*/;
return true;

// action for: ADD A Comma B End | ADD B End
action_43:
/*DO_stmt(0x80)*/;
return true;

// action for: ADD A Comma C End | ADD C End
action_44:
/*DO_stmt(0x81)*/;
return true;

// action for: ADD A Comma D End | ADD D End
action_45:
/*DO_stmt(0x82)*/;
return true;

// action for: ADD A Comma E End | ADD E End
action_46:
/*DO_stmt(0x83)*/;
return true;

// action for: ADD A Comma H End | ADD H End
action_47:
/*DO_stmt(0x84)*/;
return true;

// action for: ADD A Comma IXH End | ADD IXH End
action_48:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD84)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A Comma IXL End | ADD IXL End
action_49:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD85)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A Comma IYH End | ADD IYH End
action_50:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD84)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A Comma IYL End | ADD IYL End
action_51:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD85)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A Comma L End | ADD L End
action_52:
/*DO_stmt(0x85)*/;
return true;

// action for: ADD A Comma LParen HL Minus RParen End | ADD LParen HL Minus RParen End
action_53:
/*DO_stmt(0x86)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: ADD A Comma LParen HL Plus RParen End | ADD LParen HL Plus RParen End
action_54:
/*DO_stmt(0x86)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: ADD A Comma LParen HL RParen End | ADD M End | ADD LParen HL RParen End
action_55:
/*DO_stmt(0x86)*/;
return true;

// action for: ADD A Comma LParen IX RParen End | ADD LParen IX RParen End
action_56:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A Comma LParen IX expr RParen End | ADD LParen IX expr RParen End
action_57:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A Comma LParen IY RParen End | ADD LParen IY RParen End
action_58:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A Comma LParen IY expr RParen End | ADD LParen IY expr RParen End
action_59:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A Comma expr End | ADD expr End | ADI expr End
action_60:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xC6)*/;
return true;

// action for: ADD A1 Comma A End | ALTD ADD A Comma A End | ALTD ADD A End
action_61:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x87)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma B End | ALTD ADD A Comma B End | ALTD ADD B End
action_62:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x80)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma C End | ALTD ADD A Comma C End | ALTD ADD C End
action_63:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x81)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma D End | ALTD ADD A Comma D End | ALTD ADD D End
action_64:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x82)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma E End | ALTD ADD A Comma E End | ALTD ADD E End
action_65:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x83)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma H End | ALTD ADD A Comma H End | ALTD ADD H End
action_66:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x84)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma L End | ALTD ADD A Comma L End | ALTD ADD L End
action_67:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x85)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma LParen HL Minus RParen End | ALTD ADD A Comma LParen HL Minus RParen End | ALTD ADD LParen HL Minus RParen End
action_68:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma LParen HL Plus RParen End | ALTD ADD A Comma LParen HL Plus RParen End | ALTD ADD LParen HL Plus RParen End
action_69:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma LParen HL RParen End | ALTD ADD A Comma LParen HL RParen End | ALTD ADD LParen HL RParen End
action_70:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma LParen IX RParen End | ALTD ADD A Comma LParen IX RParen End | ALTD ADD LParen IX RParen End
action_71:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma LParen IX expr RParen End | ALTD ADD A Comma LParen IX expr RParen End | ALTD ADD LParen IX expr RParen End
action_72:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma LParen IY RParen End | ALTD ADD A Comma LParen IY RParen End | ALTD ADD LParen IY RParen End
action_73:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma LParen IY expr RParen End | ALTD ADD A Comma LParen IY expr RParen End | ALTD ADD LParen IY expr RParen End
action_74:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD A1 Comma expr End | ALTD ADD A Comma expr End | ALTD ADD expr End
action_75:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0xC6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD BC Comma A End
action_76:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__add_bc_a")*/;
break;
case CPU_Z80N: 
/*DO_stmt(0xED33)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD BC Comma expr End
action_77:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xE5)*/;
/*DO_stmt_nn(0x21)*/;
/*DO_stmt(0x09)*/;
/*DO_stmt(0x44)*/;
/*DO_stmt(0x4D)*/;
/*DO_stmt(0xE1)*/;
break;
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xED36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD DE Comma A End
action_78:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__add_de_a")*/;
break;
case CPU_Z80N: 
/*DO_stmt(0xED32)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD DE Comma expr End
action_79:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xE5)*/;
/*DO_stmt_nn(0x21)*/;
/*DO_stmt(0x19)*/;
/*DO_stmt(0x54)*/;
/*DO_stmt(0x5D)*/;
/*DO_stmt(0xE1)*/;
break;
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xED35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD HL Comma A End
action_80:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__add_hl_a")*/;
break;
case CPU_Z80N: 
/*DO_stmt(0xED31)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD HL Comma BC End | DAD B End | DAD BC End
action_81:
/*DO_stmt(0x09)*/;
return true;

// action for: ADD HL Comma DE End | DAD D End | DAD DE End
action_82:
/*DO_stmt(0x19)*/;
return true;

// action for: ADD HL Comma HL End | DAD H End | DAD HL End
action_83:
/*DO_stmt(0x29)*/;
return true;

// action for: ADD HL Comma SP End | DAD SP End
action_84:
/*DO_stmt(0x39)*/;
return true;

// action for: ADD HL Comma expr End
action_85:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD5)*/;
/*DO_stmt_nn(0x11)*/;
/*DO_stmt(0x19)*/;
/*DO_stmt(0xD1)*/;
break;
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xED34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD HL1 Comma BC End | ALTD ADD HL Comma BC End
action_86:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x09)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD HL1 Comma DE End | ALTD ADD HL Comma DE End
action_87:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD HL1 Comma HL End | ALTD ADD HL Comma HL End
action_88:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x29)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD HL1 Comma SP End | ALTD ADD HL Comma SP End
action_89:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x39)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD IX Comma BC End
action_90:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD09)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD IX Comma DE End
action_91:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD IX Comma IX End
action_92:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD29)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD IX Comma SP End
action_93:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD39)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD IY Comma BC End
action_94:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD09)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD IY Comma DE End
action_95:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD IY Comma IY End
action_96:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD29)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD IY Comma SP End
action_97:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD39)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADD SP Comma expr End
action_98:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_d(0x27)*/;
break;
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_d(0xE8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADI HL Comma expr End | LDHI expr End
action_99:
switch (option_cpu()) {
case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x28)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ADI SP Comma expr End | LDSI expr End
action_100:
switch (option_cpu()) {
case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x38)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma A End | ALTD AND A End | AND A1 Comma A End
action_101:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA7)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma B End | ALTD AND B End | AND A1 Comma B End
action_102:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma C End | ALTD AND C End | AND A1 Comma C End
action_103:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma D End | ALTD AND D End | AND A1 Comma D End
action_104:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma E End | ALTD AND E End | AND A1 Comma E End
action_105:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma H End | ALTD AND H End | AND A1 Comma H End
action_106:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma L End | ALTD AND L End | AND A1 Comma L End
action_107:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA5)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma LParen HL Minus RParen End | ALTD AND LParen HL Minus RParen End | AND A1 Comma LParen HL Minus RParen End
action_108:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma LParen HL Plus RParen End | ALTD AND LParen HL Plus RParen End | AND A1 Comma LParen HL Plus RParen End
action_109:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma LParen HL RParen End | ALTD AND LParen HL RParen End | AND A1 Comma LParen HL RParen End
action_110:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma LParen IX RParen End | ALTD AND LParen IX RParen End | AND A1 Comma LParen IX RParen End
action_111:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma LParen IX expr RParen End | ALTD AND LParen IX expr RParen End | AND A1 Comma LParen IX expr RParen End
action_112:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma LParen IY RParen End | ALTD AND LParen IY RParen End | AND A1 Comma LParen IY RParen End
action_113:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma LParen IY expr RParen End | ALTD AND LParen IY expr RParen End | AND A1 Comma LParen IY expr RParen End
action_114:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND A Comma expr End | ALTD AND expr End | AND A1 Comma expr End
action_115:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0xE6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD AND HL Comma DE End | AND HL1 Comma DE End
action_116:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma A End
action_117:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB47+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma B End
action_118:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB40+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma C End
action_119:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB41+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma D End
action_120:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB42+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma E End
action_121:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB43+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma H End
action_122:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB44+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma L End
action_123:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB45+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma LParen HL RParen End
action_124:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma LParen IX RParen End
action_125:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma LParen IX expr RParen End
action_126:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma LParen IY RParen End
action_127:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BIT const_expr Comma LParen IY expr RParen End
action_128:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD BOOL HL End | BOOL HL1 End
action_129:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CCF End | CCF1 End
action_130:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x3F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma A End | ALTD CP A End
action_131:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBF)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma B End | ALTD CP B End
action_132:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma C End | ALTD CP C End
action_133:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma D End | ALTD CP D End
action_134:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma E End | ALTD CP E End
action_135:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma H End | ALTD CP H End
action_136:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma L End | ALTD CP L End
action_137:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBD)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma LParen HL Minus RParen End | ALTD CP LParen HL Minus RParen End
action_138:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma LParen HL Plus RParen End | ALTD CP LParen HL Plus RParen End
action_139:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma LParen HL RParen End | ALTD CP LParen HL RParen End
action_140:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma LParen IX RParen End | ALTD CP LParen IX RParen End
action_141:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma LParen IX expr RParen End | ALTD CP LParen IX expr RParen End
action_142:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma LParen IY RParen End | ALTD CP LParen IY RParen End
action_143:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma LParen IY expr RParen End | ALTD CP LParen IY expr RParen End
action_144:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CP A Comma expr End | ALTD CP expr End
action_145:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0xFE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD CPL A End | ALTD CPL End | CPL A1 End
action_146:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x2F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC A End | DEC A1 End
action_147:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x3D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC B End | DEC B1 End
action_148:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x05)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC BC End | DEC BC1 End
action_149:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC C End | DEC C1 End
action_150:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC D End | DEC D1 End
action_151:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x15)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC DE End | DEC DE1 End
action_152:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC E End | DEC E1 End
action_153:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC H End | DEC H1 End
action_154:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x25)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC HL End | DEC HL1 End
action_155:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC L End | DEC L1 End
action_156:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x2D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC LParen HL Minus RParen End
action_157:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC LParen HL Plus RParen End
action_158:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC LParen HL RParen End
action_159:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC LParen IX RParen End
action_160:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC LParen IX expr RParen End
action_161:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC LParen IY RParen End
action_162:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DEC LParen IY expr RParen End
action_163:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD DJNZ B Comma expr End | ALTD DJNZ expr End | DJNZ B1 Comma expr End
action_164:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_jr(0x10)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD EX DE Comma HL End | EX DE Comma HL1 End
action_165:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD EX DE1 Comma HL End | EX DE1 Comma HL1 End
action_166:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xE3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD EX LParen SP RParen Comma HL End | EX LParen SP RParen Comma HL1 End
action_167:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED54)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC A End | INC A1 End
action_168:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x3C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC B End | INC B1 End
action_169:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x04)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC BC End | INC BC1 End
action_170:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC C End | INC C1 End
action_171:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC D End | INC D1 End
action_172:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x14)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC DE End | INC DE1 End
action_173:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC E End | INC E1 End
action_174:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC H End | INC H1 End
action_175:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x24)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC HL End | INC HL1 End
action_176:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC L End | INC L1 End
action_177:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x2C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC LParen HL Minus RParen End
action_178:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC LParen HL Plus RParen End
action_179:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC LParen HL RParen End
action_180:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC LParen IX RParen End
action_181:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC LParen IX expr RParen End
action_182:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC LParen IY RParen End
action_183:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD INC LParen IY expr RParen End
action_184:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADC A Comma LParen HL Minus RParen End | ALTD IOE ADC LParen HL Minus RParen End
action_185:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADC A Comma LParen HL Plus RParen End | ALTD IOE ADC LParen HL Plus RParen End
action_186:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADC A Comma LParen HL RParen End | ALTD IOE ADC LParen HL RParen End
action_187:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADC A Comma LParen IX RParen End | ALTD IOE ADC LParen IX RParen End
action_188:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADC A Comma LParen IX expr RParen End | ALTD IOE ADC LParen IX expr RParen End
action_189:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADC A Comma LParen IY RParen End | ALTD IOE ADC LParen IY RParen End
action_190:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADC A Comma LParen IY expr RParen End | ALTD IOE ADC LParen IY expr RParen End
action_191:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADD A Comma LParen HL Minus RParen End | ALTD IOE ADD LParen HL Minus RParen End
action_192:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADD A Comma LParen HL Plus RParen End | ALTD IOE ADD LParen HL Plus RParen End
action_193:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADD A Comma LParen HL RParen End | ALTD IOE ADD LParen HL RParen End
action_194:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADD A Comma LParen IX RParen End | ALTD IOE ADD LParen IX RParen End
action_195:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADD A Comma LParen IX expr RParen End | ALTD IOE ADD LParen IX expr RParen End
action_196:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADD A Comma LParen IY RParen End | ALTD IOE ADD LParen IY RParen End
action_197:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE ADD A Comma LParen IY expr RParen End | ALTD IOE ADD LParen IY expr RParen End
action_198:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE AND A Comma LParen HL Minus RParen End | ALTD IOE AND LParen HL Minus RParen End
action_199:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE AND A Comma LParen HL Plus RParen End | ALTD IOE AND LParen HL Plus RParen End
action_200:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE AND A Comma LParen HL RParen End | ALTD IOE AND LParen HL RParen End
action_201:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE AND A Comma LParen IX RParen End | ALTD IOE AND LParen IX RParen End
action_202:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE AND A Comma LParen IX expr RParen End | ALTD IOE AND LParen IX expr RParen End
action_203:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE AND A Comma LParen IY RParen End | ALTD IOE AND LParen IY RParen End
action_204:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE AND A Comma LParen IY expr RParen End | ALTD IOE AND LParen IY expr RParen End
action_205:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE BIT const_expr Comma LParen HL RParen End
action_206:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE BIT const_expr Comma LParen IX RParen End
action_207:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE BIT const_expr Comma LParen IX expr RParen End
action_208:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE BIT const_expr Comma LParen IY RParen End
action_209:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE BIT const_expr Comma LParen IY expr RParen End
action_210:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE CP A Comma LParen HL Minus RParen End | ALTD IOE CP LParen HL Minus RParen End
action_211:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE CP A Comma LParen HL Plus RParen End | ALTD IOE CP LParen HL Plus RParen End
action_212:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE CP A Comma LParen HL RParen End | ALTD IOE CP LParen HL RParen End
action_213:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE CP A Comma LParen IX RParen End | ALTD IOE CP LParen IX RParen End
action_214:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE CP A Comma LParen IX expr RParen End | ALTD IOE CP LParen IX expr RParen End
action_215:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE CP A Comma LParen IY RParen End | ALTD IOE CP LParen IY RParen End
action_216:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE CP A Comma LParen IY expr RParen End | ALTD IOE CP LParen IY expr RParen End
action_217:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE DEC LParen HL Minus RParen End
action_218:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE DEC LParen HL Plus RParen End
action_219:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE DEC LParen HL RParen End
action_220:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE DEC LParen IX RParen End
action_221:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE DEC LParen IX expr RParen End
action_222:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE DEC LParen IY RParen End
action_223:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE DEC LParen IY expr RParen End
action_224:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE INC LParen HL Minus RParen End
action_225:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE INC LParen HL Plus RParen End
action_226:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE INC LParen HL RParen End
action_227:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE INC LParen IX RParen End
action_228:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE INC LParen IX expr RParen End
action_229:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE INC LParen IY RParen End
action_230:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE INC LParen IY expr RParen End
action_231:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen BC Minus RParen End
action_232:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen BC Plus RParen End
action_233:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen BC RParen End
action_234:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen DE Minus RParen End
action_235:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen DE Plus RParen End
action_236:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen DE RParen End
action_237:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen HL Minus RParen End | ALTD IOE LD A Comma LParen HLD RParen End
action_238:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen HL Plus RParen End | ALTD IOE LD A Comma LParen HLI RParen End
action_239:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen HL RParen End
action_240:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen IX RParen End
action_241:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen IX expr RParen End
action_242:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen IY RParen End
action_243:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma LParen IY expr RParen End
action_244:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD A Comma expr End
action_245:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0x3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD B Comma LParen HL Minus RParen End | ALTD IOE LD B Comma LParen HLD RParen End
action_246:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD B Comma LParen HL Plus RParen End | ALTD IOE LD B Comma LParen HLI RParen End
action_247:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD B Comma LParen HL RParen End
action_248:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD B Comma LParen IX RParen End
action_249:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD B Comma LParen IX expr RParen End
action_250:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD B Comma LParen IY RParen End
action_251:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD B Comma LParen IY expr RParen End
action_252:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD BC Comma expr End
action_253:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xED4B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD C Comma LParen HL Minus RParen End | ALTD IOE LD C Comma LParen HLD RParen End
action_254:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD C Comma LParen HL Plus RParen End | ALTD IOE LD C Comma LParen HLI RParen End
action_255:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD C Comma LParen HL RParen End
action_256:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD C Comma LParen IX RParen End
action_257:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD C Comma LParen IX expr RParen End
action_258:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD C Comma LParen IY RParen End
action_259:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD C Comma LParen IY expr RParen End
action_260:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD D Comma LParen HL Minus RParen End | ALTD IOE LD D Comma LParen HLD RParen End
action_261:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD D Comma LParen HL Plus RParen End | ALTD IOE LD D Comma LParen HLI RParen End
action_262:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD D Comma LParen HL RParen End
action_263:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD D Comma LParen IX RParen End
action_264:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD D Comma LParen IX expr RParen End
action_265:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD D Comma LParen IY RParen End
action_266:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD D Comma LParen IY expr RParen End
action_267:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD DE Comma expr End
action_268:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xED5B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD E Comma LParen HL Minus RParen End | ALTD IOE LD E Comma LParen HLD RParen End
action_269:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD E Comma LParen HL Plus RParen End | ALTD IOE LD E Comma LParen HLI RParen End
action_270:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD E Comma LParen HL RParen End
action_271:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD E Comma LParen IX RParen End
action_272:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD E Comma LParen IX expr RParen End
action_273:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD E Comma LParen IY RParen End
action_274:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD E Comma LParen IY expr RParen End
action_275:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD H Comma LParen HL Minus RParen End | ALTD IOE LD H Comma LParen HLD RParen End
action_276:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD H Comma LParen HL Plus RParen End | ALTD IOE LD H Comma LParen HLI RParen End
action_277:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD H Comma LParen HL RParen End
action_278:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD H Comma LParen IX RParen End
action_279:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD H Comma LParen IX expr RParen End
action_280:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD H Comma LParen IY RParen End
action_281:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD H Comma LParen IY expr RParen End
action_282:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD HL Comma LParen HL RParen End
action_283:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD HL Comma LParen HL expr RParen End
action_284:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD HL Comma LParen IX RParen End
action_285:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD HL Comma LParen IX expr RParen End
action_286:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD HL Comma LParen IY RParen End
action_287:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD HL Comma LParen IY expr RParen End
action_288:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD HL Comma expr End
action_289:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0x2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD L Comma LParen HL Minus RParen End | ALTD IOE LD L Comma LParen HLD RParen End
action_290:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD L Comma LParen HL Plus RParen End | ALTD IOE LD L Comma LParen HLI RParen End
action_291:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD L Comma LParen HL RParen End
action_292:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD L Comma LParen IX RParen End
action_293:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD L Comma LParen IX expr RParen End
action_294:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD L Comma LParen IY RParen End
action_295:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE LD L Comma LParen IY expr RParen End
action_296:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE OR A Comma LParen HL Minus RParen End | ALTD IOE OR LParen HL Minus RParen End
action_297:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE OR A Comma LParen HL Plus RParen End | ALTD IOE OR LParen HL Plus RParen End
action_298:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE OR A Comma LParen HL RParen End | ALTD IOE OR LParen HL RParen End
action_299:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE OR A Comma LParen IX RParen End | ALTD IOE OR LParen IX RParen End
action_300:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE OR A Comma LParen IX expr RParen End | ALTD IOE OR LParen IX expr RParen End
action_301:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE OR A Comma LParen IY RParen End | ALTD IOE OR LParen IY RParen End
action_302:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE OR A Comma LParen IY expr RParen End | ALTD IOE OR LParen IY expr RParen End
action_303:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RL LParen HL RParen End
action_304:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RL LParen IX RParen End
action_305:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RL LParen IX expr RParen End
action_306:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RL LParen IY RParen End
action_307:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RL LParen IY expr RParen End
action_308:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RLC LParen HL RParen End
action_309:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RLC LParen IX RParen End
action_310:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RLC LParen IX expr RParen End
action_311:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RLC LParen IY RParen End
action_312:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RLC LParen IY expr RParen End
action_313:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RR LParen HL RParen End
action_314:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RR LParen IX RParen End
action_315:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RR LParen IX expr RParen End
action_316:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RR LParen IY RParen End
action_317:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RR LParen IY expr RParen End
action_318:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RRC LParen HL RParen End
action_319:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RRC LParen IX RParen End
action_320:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RRC LParen IX expr RParen End
action_321:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RRC LParen IY RParen End
action_322:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE RRC LParen IY expr RParen End
action_323:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SBC A Comma LParen HL Minus RParen End | ALTD IOE SBC LParen HL Minus RParen End
action_324:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SBC A Comma LParen HL Plus RParen End | ALTD IOE SBC LParen HL Plus RParen End
action_325:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SBC A Comma LParen HL RParen End | ALTD IOE SBC LParen HL RParen End
action_326:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SBC A Comma LParen IX RParen End | ALTD IOE SBC LParen IX RParen End
action_327:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SBC A Comma LParen IX expr RParen End | ALTD IOE SBC LParen IX expr RParen End
action_328:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SBC A Comma LParen IY RParen End | ALTD IOE SBC LParen IY RParen End
action_329:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SBC A Comma LParen IY expr RParen End | ALTD IOE SBC LParen IY expr RParen End
action_330:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SLA LParen HL RParen End
action_331:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SLA LParen IX RParen End
action_332:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SLA LParen IX expr RParen End
action_333:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SLA LParen IY RParen End
action_334:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SLA LParen IY expr RParen End
action_335:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRA LParen HL RParen End
action_336:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRA LParen IX RParen End
action_337:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRA LParen IX expr RParen End
action_338:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRA LParen IY RParen End
action_339:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRA LParen IY expr RParen End
action_340:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRL LParen HL RParen End
action_341:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRL LParen IX RParen End
action_342:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRL LParen IX expr RParen End
action_343:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRL LParen IY RParen End
action_344:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SRL LParen IY expr RParen End
action_345:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SUB A Comma LParen HL Minus RParen End | ALTD IOE SUB LParen HL Minus RParen End
action_346:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SUB A Comma LParen HL Plus RParen End | ALTD IOE SUB LParen HL Plus RParen End
action_347:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SUB A Comma LParen HL RParen End | ALTD IOE SUB LParen HL RParen End
action_348:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SUB A Comma LParen IX RParen End | ALTD IOE SUB LParen IX RParen End
action_349:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SUB A Comma LParen IX expr RParen End | ALTD IOE SUB LParen IX expr RParen End
action_350:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SUB A Comma LParen IY RParen End | ALTD IOE SUB LParen IY RParen End
action_351:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE SUB A Comma LParen IY expr RParen End | ALTD IOE SUB LParen IY expr RParen End
action_352:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE XOR A Comma LParen HL Minus RParen End | ALTD IOE XOR LParen HL Minus RParen End
action_353:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE XOR A Comma LParen HL Plus RParen End | ALTD IOE XOR LParen HL Plus RParen End
action_354:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE XOR A Comma LParen HL RParen End | ALTD IOE XOR LParen HL RParen End
action_355:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE XOR A Comma LParen IX RParen End | ALTD IOE XOR LParen IX RParen End
action_356:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE XOR A Comma LParen IX expr RParen End | ALTD IOE XOR LParen IX expr RParen End
action_357:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE XOR A Comma LParen IY RParen End | ALTD IOE XOR LParen IY RParen End
action_358:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOE XOR A Comma LParen IY expr RParen End | ALTD IOE XOR LParen IY expr RParen End
action_359:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADC A Comma LParen HL Minus RParen End | ALTD IOI ADC LParen HL Minus RParen End
action_360:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADC A Comma LParen HL Plus RParen End | ALTD IOI ADC LParen HL Plus RParen End
action_361:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADC A Comma LParen HL RParen End | ALTD IOI ADC LParen HL RParen End
action_362:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADC A Comma LParen IX RParen End | ALTD IOI ADC LParen IX RParen End
action_363:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADC A Comma LParen IX expr RParen End | ALTD IOI ADC LParen IX expr RParen End
action_364:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADC A Comma LParen IY RParen End | ALTD IOI ADC LParen IY RParen End
action_365:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADC A Comma LParen IY expr RParen End | ALTD IOI ADC LParen IY expr RParen End
action_366:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADD A Comma LParen HL Minus RParen End | ALTD IOI ADD LParen HL Minus RParen End
action_367:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADD A Comma LParen HL Plus RParen End | ALTD IOI ADD LParen HL Plus RParen End
action_368:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADD A Comma LParen HL RParen End | ALTD IOI ADD LParen HL RParen End
action_369:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADD A Comma LParen IX RParen End | ALTD IOI ADD LParen IX RParen End
action_370:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADD A Comma LParen IX expr RParen End | ALTD IOI ADD LParen IX expr RParen End
action_371:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADD A Comma LParen IY RParen End | ALTD IOI ADD LParen IY RParen End
action_372:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI ADD A Comma LParen IY expr RParen End | ALTD IOI ADD LParen IY expr RParen End
action_373:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI AND A Comma LParen HL Minus RParen End | ALTD IOI AND LParen HL Minus RParen End
action_374:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI AND A Comma LParen HL Plus RParen End | ALTD IOI AND LParen HL Plus RParen End
action_375:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI AND A Comma LParen HL RParen End | ALTD IOI AND LParen HL RParen End
action_376:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI AND A Comma LParen IX RParen End | ALTD IOI AND LParen IX RParen End
action_377:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI AND A Comma LParen IX expr RParen End | ALTD IOI AND LParen IX expr RParen End
action_378:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI AND A Comma LParen IY RParen End | ALTD IOI AND LParen IY RParen End
action_379:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI AND A Comma LParen IY expr RParen End | ALTD IOI AND LParen IY expr RParen End
action_380:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI BIT const_expr Comma LParen HL RParen End
action_381:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI BIT const_expr Comma LParen IX RParen End
action_382:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI BIT const_expr Comma LParen IX expr RParen End
action_383:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI BIT const_expr Comma LParen IY RParen End
action_384:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI BIT const_expr Comma LParen IY expr RParen End
action_385:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI CP A Comma LParen HL Minus RParen End | ALTD IOI CP LParen HL Minus RParen End
action_386:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI CP A Comma LParen HL Plus RParen End | ALTD IOI CP LParen HL Plus RParen End
action_387:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI CP A Comma LParen HL RParen End | ALTD IOI CP LParen HL RParen End
action_388:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI CP A Comma LParen IX RParen End | ALTD IOI CP LParen IX RParen End
action_389:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI CP A Comma LParen IX expr RParen End | ALTD IOI CP LParen IX expr RParen End
action_390:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI CP A Comma LParen IY RParen End | ALTD IOI CP LParen IY RParen End
action_391:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI CP A Comma LParen IY expr RParen End | ALTD IOI CP LParen IY expr RParen End
action_392:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI DEC LParen HL Minus RParen End
action_393:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI DEC LParen HL Plus RParen End
action_394:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI DEC LParen HL RParen End
action_395:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI DEC LParen IX RParen End
action_396:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI DEC LParen IX expr RParen End
action_397:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI DEC LParen IY RParen End
action_398:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI DEC LParen IY expr RParen End
action_399:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI INC LParen HL Minus RParen End
action_400:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI INC LParen HL Plus RParen End
action_401:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI INC LParen HL RParen End
action_402:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI INC LParen IX RParen End
action_403:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI INC LParen IX expr RParen End
action_404:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI INC LParen IY RParen End
action_405:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI INC LParen IY expr RParen End
action_406:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen BC Minus RParen End
action_407:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen BC Plus RParen End
action_408:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen BC RParen End
action_409:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen DE Minus RParen End
action_410:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen DE Plus RParen End
action_411:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen DE RParen End
action_412:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen HL Minus RParen End | ALTD IOI LD A Comma LParen HLD RParen End
action_413:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen HL Plus RParen End | ALTD IOI LD A Comma LParen HLI RParen End
action_414:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen HL RParen End
action_415:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen IX RParen End
action_416:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen IX expr RParen End
action_417:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen IY RParen End
action_418:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma LParen IY expr RParen End
action_419:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD A Comma expr End
action_420:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0x3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD B Comma LParen HL Minus RParen End | ALTD IOI LD B Comma LParen HLD RParen End
action_421:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD B Comma LParen HL Plus RParen End | ALTD IOI LD B Comma LParen HLI RParen End
action_422:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD B Comma LParen HL RParen End
action_423:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD B Comma LParen IX RParen End
action_424:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD B Comma LParen IX expr RParen End
action_425:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD B Comma LParen IY RParen End
action_426:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD B Comma LParen IY expr RParen End
action_427:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD BC Comma expr End
action_428:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xED4B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD C Comma LParen HL Minus RParen End | ALTD IOI LD C Comma LParen HLD RParen End
action_429:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD C Comma LParen HL Plus RParen End | ALTD IOI LD C Comma LParen HLI RParen End
action_430:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD C Comma LParen HL RParen End
action_431:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD C Comma LParen IX RParen End
action_432:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD C Comma LParen IX expr RParen End
action_433:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD C Comma LParen IY RParen End
action_434:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD C Comma LParen IY expr RParen End
action_435:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD D Comma LParen HL Minus RParen End | ALTD IOI LD D Comma LParen HLD RParen End
action_436:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD D Comma LParen HL Plus RParen End | ALTD IOI LD D Comma LParen HLI RParen End
action_437:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD D Comma LParen HL RParen End
action_438:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD D Comma LParen IX RParen End
action_439:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD D Comma LParen IX expr RParen End
action_440:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD D Comma LParen IY RParen End
action_441:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD D Comma LParen IY expr RParen End
action_442:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD DE Comma expr End
action_443:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xED5B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD E Comma LParen HL Minus RParen End | ALTD IOI LD E Comma LParen HLD RParen End
action_444:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD E Comma LParen HL Plus RParen End | ALTD IOI LD E Comma LParen HLI RParen End
action_445:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD E Comma LParen HL RParen End
action_446:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD E Comma LParen IX RParen End
action_447:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD E Comma LParen IX expr RParen End
action_448:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD E Comma LParen IY RParen End
action_449:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD E Comma LParen IY expr RParen End
action_450:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD H Comma LParen HL Minus RParen End | ALTD IOI LD H Comma LParen HLD RParen End
action_451:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD H Comma LParen HL Plus RParen End | ALTD IOI LD H Comma LParen HLI RParen End
action_452:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD H Comma LParen HL RParen End
action_453:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD H Comma LParen IX RParen End
action_454:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD H Comma LParen IX expr RParen End
action_455:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD H Comma LParen IY RParen End
action_456:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD H Comma LParen IY expr RParen End
action_457:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD HL Comma LParen HL RParen End
action_458:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD HL Comma LParen HL expr RParen End
action_459:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD HL Comma LParen IX RParen End
action_460:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD HL Comma LParen IX expr RParen End
action_461:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD HL Comma LParen IY RParen End
action_462:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD HL Comma LParen IY expr RParen End
action_463:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD HL Comma expr End
action_464:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0x2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD L Comma LParen HL Minus RParen End | ALTD IOI LD L Comma LParen HLD RParen End
action_465:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD L Comma LParen HL Plus RParen End | ALTD IOI LD L Comma LParen HLI RParen End
action_466:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD L Comma LParen HL RParen End
action_467:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD L Comma LParen IX RParen End
action_468:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD L Comma LParen IX expr RParen End
action_469:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD L Comma LParen IY RParen End
action_470:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI LD L Comma LParen IY expr RParen End
action_471:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI OR A Comma LParen HL Minus RParen End | ALTD IOI OR LParen HL Minus RParen End
action_472:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI OR A Comma LParen HL Plus RParen End | ALTD IOI OR LParen HL Plus RParen End
action_473:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI OR A Comma LParen HL RParen End | ALTD IOI OR LParen HL RParen End
action_474:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI OR A Comma LParen IX RParen End | ALTD IOI OR LParen IX RParen End
action_475:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI OR A Comma LParen IX expr RParen End | ALTD IOI OR LParen IX expr RParen End
action_476:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI OR A Comma LParen IY RParen End | ALTD IOI OR LParen IY RParen End
action_477:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI OR A Comma LParen IY expr RParen End | ALTD IOI OR LParen IY expr RParen End
action_478:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RL LParen HL RParen End
action_479:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RL LParen IX RParen End
action_480:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RL LParen IX expr RParen End
action_481:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RL LParen IY RParen End
action_482:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RL LParen IY expr RParen End
action_483:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RLC LParen HL RParen End
action_484:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RLC LParen IX RParen End
action_485:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RLC LParen IX expr RParen End
action_486:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RLC LParen IY RParen End
action_487:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RLC LParen IY expr RParen End
action_488:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RR LParen HL RParen End
action_489:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RR LParen IX RParen End
action_490:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RR LParen IX expr RParen End
action_491:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RR LParen IY RParen End
action_492:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RR LParen IY expr RParen End
action_493:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RRC LParen HL RParen End
action_494:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RRC LParen IX RParen End
action_495:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RRC LParen IX expr RParen End
action_496:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RRC LParen IY RParen End
action_497:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI RRC LParen IY expr RParen End
action_498:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SBC A Comma LParen HL Minus RParen End | ALTD IOI SBC LParen HL Minus RParen End
action_499:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SBC A Comma LParen HL Plus RParen End | ALTD IOI SBC LParen HL Plus RParen End
action_500:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SBC A Comma LParen HL RParen End | ALTD IOI SBC LParen HL RParen End
action_501:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SBC A Comma LParen IX RParen End | ALTD IOI SBC LParen IX RParen End
action_502:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SBC A Comma LParen IX expr RParen End | ALTD IOI SBC LParen IX expr RParen End
action_503:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SBC A Comma LParen IY RParen End | ALTD IOI SBC LParen IY RParen End
action_504:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SBC A Comma LParen IY expr RParen End | ALTD IOI SBC LParen IY expr RParen End
action_505:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SLA LParen HL RParen End
action_506:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SLA LParen IX RParen End
action_507:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SLA LParen IX expr RParen End
action_508:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SLA LParen IY RParen End
action_509:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SLA LParen IY expr RParen End
action_510:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRA LParen HL RParen End
action_511:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRA LParen IX RParen End
action_512:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRA LParen IX expr RParen End
action_513:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRA LParen IY RParen End
action_514:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRA LParen IY expr RParen End
action_515:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRL LParen HL RParen End
action_516:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRL LParen IX RParen End
action_517:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRL LParen IX expr RParen End
action_518:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRL LParen IY RParen End
action_519:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SRL LParen IY expr RParen End
action_520:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SUB A Comma LParen HL Minus RParen End | ALTD IOI SUB LParen HL Minus RParen End
action_521:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SUB A Comma LParen HL Plus RParen End | ALTD IOI SUB LParen HL Plus RParen End
action_522:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SUB A Comma LParen HL RParen End | ALTD IOI SUB LParen HL RParen End
action_523:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SUB A Comma LParen IX RParen End | ALTD IOI SUB LParen IX RParen End
action_524:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SUB A Comma LParen IX expr RParen End | ALTD IOI SUB LParen IX expr RParen End
action_525:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SUB A Comma LParen IY RParen End | ALTD IOI SUB LParen IY RParen End
action_526:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI SUB A Comma LParen IY expr RParen End | ALTD IOI SUB LParen IY expr RParen End
action_527:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI XOR A Comma LParen HL Minus RParen End | ALTD IOI XOR LParen HL Minus RParen End
action_528:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI XOR A Comma LParen HL Plus RParen End | ALTD IOI XOR LParen HL Plus RParen End
action_529:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI XOR A Comma LParen HL RParen End | ALTD IOI XOR LParen HL RParen End
action_530:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI XOR A Comma LParen IX RParen End | ALTD IOI XOR LParen IX RParen End
action_531:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI XOR A Comma LParen IX expr RParen End | ALTD IOI XOR LParen IX expr RParen End
action_532:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI XOR A Comma LParen IY RParen End | ALTD IOI XOR LParen IY RParen End
action_533:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD IOI XOR A Comma LParen IY expr RParen End | ALTD IOI XOR LParen IY expr RParen End
action_534:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma A End | LD A1 Comma A End
action_535:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma B End | LD A1 Comma B End
action_536:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x78)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma C End | LD A1 Comma C End
action_537:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x79)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma D End | LD A1 Comma D End
action_538:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma E End | LD A1 Comma E End
action_539:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma EIR End | LD A1 Comma EIR End
action_540:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED57)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma H End | LD A1 Comma H End
action_541:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma IIR End | LD A1 Comma IIR End
action_542:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED5F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma L End | LD A1 Comma L End
action_543:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma XPC End | LD A1 Comma XPC End
action_544:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen BC Minus RParen End | LD A1 Comma LParen BC Minus RParen End
action_545:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen BC Plus RParen End | LD A1 Comma LParen BC Plus RParen End
action_546:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen BC RParen End | LD A1 Comma LParen BC RParen End
action_547:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen DE Minus RParen End | LD A1 Comma LParen DE Minus RParen End
action_548:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen DE Plus RParen End | LD A1 Comma LParen DE Plus RParen End
action_549:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen DE RParen End | LD A1 Comma LParen DE RParen End
action_550:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen HL Minus RParen End | ALTD LD A Comma LParen HLD RParen End | LD A1 Comma LParen HL Minus RParen End | LD A1 Comma LParen HLD RParen End
action_551:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen HL Plus RParen End | ALTD LD A Comma LParen HLI RParen End | LD A1 Comma LParen HL Plus RParen End | LD A1 Comma LParen HLI RParen End
action_552:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen HL RParen End | LD A1 Comma LParen HL RParen End
action_553:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen IX RParen End | LD A1 Comma LParen IX RParen End
action_554:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen IX expr RParen End | LD A1 Comma LParen IX expr RParen End
action_555:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen IY RParen End | LD A1 Comma LParen IY RParen End
action_556:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma LParen IY expr RParen End | LD A1 Comma LParen IY expr RParen End
action_557:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD A Comma expr End | LD A1 Comma expr End
action_558:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
#if 0
if (expr_in_parens) { 
/*DO_stmt_nn(0x3A)*/; } else { 
/*DO_stmt_n(0x3E)*/; }
#endif

break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma A End | LD B1 Comma A End
action_559:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x47)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma B End | LD B1 Comma B End
action_560:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x40)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma C End | LD B1 Comma C End
action_561:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x41)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma D End | LD B1 Comma D End
action_562:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x42)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma E End | LD B1 Comma E End
action_563:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x43)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma H End | LD B1 Comma H End
action_564:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x44)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma L End | LD B1 Comma L End
action_565:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x45)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma LParen HL Minus RParen End | ALTD LD B Comma LParen HLD RParen End | LD B1 Comma LParen HL Minus RParen End | LD B1 Comma LParen HLD RParen End
action_566:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma LParen HL Plus RParen End | ALTD LD B Comma LParen HLI RParen End | LD B1 Comma LParen HL Plus RParen End | LD B1 Comma LParen HLI RParen End
action_567:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma LParen HL RParen End | LD B1 Comma LParen HL RParen End
action_568:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma LParen IX RParen End | LD B1 Comma LParen IX RParen End
action_569:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma LParen IX expr RParen End | LD B1 Comma LParen IX expr RParen End
action_570:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma LParen IY RParen End | LD B1 Comma LParen IY RParen End
action_571:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma LParen IY expr RParen End | LD B1 Comma LParen IY expr RParen End
action_572:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD B Comma expr End | LD B1 Comma expr End
action_573:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0x06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD BC Comma BC End | LD BC1 Comma BC End
action_574:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED49)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD BC Comma DE End | LD BC1 Comma DE End
action_575:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED41)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD BC Comma expr End | LD BC1 Comma expr End
action_576:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
#if 0
if (expr_in_parens) { 
/*DO_stmt_nn(0xED4B)*/; } else { 
/*DO_stmt_nn(0x01)*/; }
#endif

break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma A End | LD C1 Comma A End
action_577:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma B End | LD C1 Comma B End
action_578:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x48)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma C End | LD C1 Comma C End
action_579:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x49)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma D End | LD C1 Comma D End
action_580:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma E End | LD C1 Comma E End
action_581:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma H End | LD C1 Comma H End
action_582:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma L End | LD C1 Comma L End
action_583:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma LParen HL Minus RParen End | ALTD LD C Comma LParen HLD RParen End | LD C1 Comma LParen HL Minus RParen End | LD C1 Comma LParen HLD RParen End
action_584:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma LParen HL Plus RParen End | ALTD LD C Comma LParen HLI RParen End | LD C1 Comma LParen HL Plus RParen End | LD C1 Comma LParen HLI RParen End
action_585:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma LParen HL RParen End | LD C1 Comma LParen HL RParen End
action_586:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma LParen IX RParen End | LD C1 Comma LParen IX RParen End
action_587:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma LParen IX expr RParen End | LD C1 Comma LParen IX expr RParen End
action_588:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma LParen IY RParen End | LD C1 Comma LParen IY RParen End
action_589:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma LParen IY expr RParen End | LD C1 Comma LParen IY expr RParen End
action_590:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD C Comma expr End | LD C1 Comma expr End
action_591:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0x0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma A End | LD D1 Comma A End
action_592:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x57)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma B End | LD D1 Comma B End
action_593:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x50)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma C End | LD D1 Comma C End
action_594:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x51)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma D End | LD D1 Comma D End
action_595:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x52)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma E End | LD D1 Comma E End
action_596:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x53)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma H End | LD D1 Comma H End
action_597:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x54)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma L End | LD D1 Comma L End
action_598:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x55)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma LParen HL Minus RParen End | ALTD LD D Comma LParen HLD RParen End | LD D1 Comma LParen HL Minus RParen End | LD D1 Comma LParen HLD RParen End
action_599:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma LParen HL Plus RParen End | ALTD LD D Comma LParen HLI RParen End | LD D1 Comma LParen HL Plus RParen End | LD D1 Comma LParen HLI RParen End
action_600:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma LParen HL RParen End | LD D1 Comma LParen HL RParen End
action_601:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma LParen IX RParen End | LD D1 Comma LParen IX RParen End
action_602:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma LParen IX expr RParen End | LD D1 Comma LParen IX expr RParen End
action_603:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma LParen IY RParen End | LD D1 Comma LParen IY RParen End
action_604:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma LParen IY expr RParen End | LD D1 Comma LParen IY expr RParen End
action_605:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD D Comma expr End | LD D1 Comma expr End
action_606:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0x16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD DE Comma BC End | LD DE1 Comma BC End
action_607:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED59)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD DE Comma DE End | LD DE1 Comma DE End
action_608:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED51)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD DE Comma expr End | LD DE1 Comma expr End
action_609:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
#if 0
if (expr_in_parens) { 
/*DO_stmt_nn(0xED5B)*/; } else { 
/*DO_stmt_nn(0x11)*/; }
#endif

break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma A End | LD E1 Comma A End
action_610:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma B End | LD E1 Comma B End
action_611:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x58)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma C End | LD E1 Comma C End
action_612:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x59)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma D End | LD E1 Comma D End
action_613:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma E End | LD E1 Comma E End
action_614:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma H End | LD E1 Comma H End
action_615:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma L End | LD E1 Comma L End
action_616:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma LParen HL Minus RParen End | ALTD LD E Comma LParen HLD RParen End | LD E1 Comma LParen HL Minus RParen End | LD E1 Comma LParen HLD RParen End
action_617:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma LParen HL Plus RParen End | ALTD LD E Comma LParen HLI RParen End | LD E1 Comma LParen HL Plus RParen End | LD E1 Comma LParen HLI RParen End
action_618:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma LParen HL RParen End | LD E1 Comma LParen HL RParen End
action_619:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma LParen IX RParen End | LD E1 Comma LParen IX RParen End
action_620:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma LParen IX expr RParen End | LD E1 Comma LParen IX expr RParen End
action_621:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma LParen IY RParen End | LD E1 Comma LParen IY RParen End
action_622:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma LParen IY expr RParen End | LD E1 Comma LParen IY expr RParen End
action_623:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD E Comma expr End | LD E1 Comma expr End
action_624:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0x1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma A End | LD H1 Comma A End
action_625:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x67)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma B End | LD H1 Comma B End
action_626:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x60)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma C End | LD H1 Comma C End
action_627:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x61)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma D End | LD H1 Comma D End
action_628:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x62)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma E End | LD H1 Comma E End
action_629:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x63)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma H End | LD H1 Comma H End
action_630:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x64)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma L End | LD H1 Comma L End
action_631:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x65)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma LParen HL Minus RParen End | ALTD LD H Comma LParen HLD RParen End | LD H1 Comma LParen HL Minus RParen End | LD H1 Comma LParen HLD RParen End
action_632:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma LParen HL Plus RParen End | ALTD LD H Comma LParen HLI RParen End | LD H1 Comma LParen HL Plus RParen End | LD H1 Comma LParen HLI RParen End
action_633:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma LParen HL RParen End | LD H1 Comma LParen HL RParen End
action_634:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma LParen IX RParen End | LD H1 Comma LParen IX RParen End
action_635:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma LParen IX expr RParen End | LD H1 Comma LParen IX expr RParen End
action_636:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma LParen IY RParen End | LD H1 Comma LParen IY RParen End
action_637:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma LParen IY expr RParen End | LD H1 Comma LParen IY expr RParen End
action_638:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD H Comma expr End | LD H1 Comma expr End
action_639:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0x26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma BC End | LD HL1 Comma BC End
action_640:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED69)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma DE End | LD HL1 Comma DE End
action_641:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED61)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma IX End | LD HL1 Comma IX End
action_642:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD7C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma IY End | LD HL1 Comma IY End
action_643:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD7C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma LParen HL RParen End | LD HL1 Comma LParen HL RParen End
action_644:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma LParen HL expr RParen End | LD HL1 Comma LParen HL expr RParen End
action_645:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma LParen IX RParen End | LD HL1 Comma LParen IX RParen End
action_646:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma LParen IX expr RParen End | LD HL1 Comma LParen IX expr RParen End
action_647:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma LParen IY RParen End | LD HL1 Comma LParen IY RParen End
action_648:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma LParen IY expr RParen End | LD HL1 Comma LParen IY expr RParen End
action_649:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma LParen SP RParen End | LD HL1 Comma LParen SP RParen End
action_650:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xC400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma LParen SP expr RParen End | LD HL1 Comma LParen SP expr RParen End
action_651:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0xC4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD HL Comma expr End | LD HL1 Comma expr End
action_652:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
#if 0
if (expr_in_parens) { 
/*DO_stmt_nn(0x2A)*/; } else { 
/*DO_stmt_nn(0x21)*/; }
#endif

break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma A End | LD L1 Comma A End
action_653:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma B End | LD L1 Comma B End
action_654:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x68)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma C End | LD L1 Comma C End
action_655:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x69)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma D End | LD L1 Comma D End
action_656:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma E End | LD L1 Comma E End
action_657:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma H End | LD L1 Comma H End
action_658:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma L End | LD L1 Comma L End
action_659:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma LParen HL Minus RParen End | ALTD LD L Comma LParen HLD RParen End | LD L1 Comma LParen HL Minus RParen End | LD L1 Comma LParen HLD RParen End
action_660:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma LParen HL Plus RParen End | ALTD LD L Comma LParen HLI RParen End | LD L1 Comma LParen HL Plus RParen End | LD L1 Comma LParen HLI RParen End
action_661:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma LParen HL RParen End | LD L1 Comma LParen HL RParen End
action_662:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma LParen IX RParen End | LD L1 Comma LParen IX RParen End
action_663:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma LParen IX expr RParen End | LD L1 Comma LParen IX expr RParen End
action_664:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma LParen IY RParen End | LD L1 Comma LParen IY RParen End
action_665:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma LParen IY expr RParen End | LD L1 Comma LParen IY expr RParen End
action_666:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD LD L Comma expr End | LD L1 Comma expr End
action_667:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0x2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD NEG A End | ALTD NEG End | NEG A1 End
action_668:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED44)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma A End | ALTD OR A End | OR A1 Comma A End
action_669:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB7)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma B End | ALTD OR B End | OR A1 Comma B End
action_670:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma C End | ALTD OR C End | OR A1 Comma C End
action_671:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma D End | ALTD OR D End | OR A1 Comma D End
action_672:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma E End | ALTD OR E End | OR A1 Comma E End
action_673:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma H End | ALTD OR H End | OR A1 Comma H End
action_674:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma L End | ALTD OR L End | OR A1 Comma L End
action_675:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB5)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma LParen HL Minus RParen End | ALTD OR LParen HL Minus RParen End | OR A1 Comma LParen HL Minus RParen End
action_676:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma LParen HL Plus RParen End | ALTD OR LParen HL Plus RParen End | OR A1 Comma LParen HL Plus RParen End
action_677:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma LParen HL RParen End | ALTD OR LParen HL RParen End | OR A1 Comma LParen HL RParen End
action_678:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma LParen IX RParen End | ALTD OR LParen IX RParen End | OR A1 Comma LParen IX RParen End
action_679:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma LParen IX expr RParen End | ALTD OR LParen IX expr RParen End | OR A1 Comma LParen IX expr RParen End
action_680:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma LParen IY RParen End | ALTD OR LParen IY RParen End | OR A1 Comma LParen IY RParen End
action_681:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma LParen IY expr RParen End | ALTD OR LParen IY expr RParen End | OR A1 Comma LParen IY expr RParen End
action_682:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR A Comma expr End | ALTD OR expr End | OR A1 Comma expr End
action_683:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0xF6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD OR HL Comma DE End | OR HL1 Comma DE End
action_684:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xEC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD POP AF End | POP AF1 End
action_685:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xF1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD POP BC End | POP BC1 End
action_686:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xC1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD POP DE End | POP DE1 End
action_687:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xD1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD POP HL End | POP HL1 End
action_688:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xE1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RES const_expr Comma A End | RES const_expr Comma A1 End
action_689:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB87+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RES const_expr Comma B End | RES const_expr Comma B1 End
action_690:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB80+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RES const_expr Comma C End | RES const_expr Comma C1 End
action_691:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB81+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RES const_expr Comma D End | RES const_expr Comma D1 End
action_692:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB82+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RES const_expr Comma E End | RES const_expr Comma E1 End
action_693:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB83+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RES const_expr Comma H End | RES const_expr Comma H1 End
action_694:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB84+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RES const_expr Comma L End | RES const_expr Comma L1 End
action_695:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB85+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL A End | RL A1 End
action_696:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB17)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL B End | RL B1 End
action_697:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB10)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL C End | RL C1 End
action_698:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB11)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL D End | RL D1 End
action_699:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB12)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL DE End | RL DE1 End
action_700:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xF3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL E End | RL E1 End
action_701:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL H End | RL H1 End
action_702:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB14)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL L End | RL L1 End
action_703:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB15)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL LParen HL RParen End
action_704:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL LParen IX RParen End
action_705:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL LParen IX expr RParen End
action_706:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL LParen IY RParen End
action_707:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RL LParen IY expr RParen End
action_708:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLA End | RLA1 End
action_709:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x17)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC A End | RLC A1 End
action_710:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB07)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC B End | RLC B1 End
action_711:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC C End | RLC C1 End
action_712:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB01)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC D End | RLC D1 End
action_713:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB02)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC E End | RLC E1 End
action_714:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC H End | RLC H1 End
action_715:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB04)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC L End | RLC L1 End
action_716:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB05)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC LParen HL RParen End
action_717:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC LParen IX RParen End
action_718:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC LParen IX expr RParen End
action_719:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC LParen IY RParen End
action_720:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLC LParen IY expr RParen End
action_721:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RLCA End | RLCA1 End
action_722:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x07)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR A End | RR A1 End
action_723:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB1F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR B End | RR B1 End
action_724:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB18)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR C End | RR C1 End
action_725:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR D End | RR D1 End
action_726:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR DE End | RR DE1 End
action_727:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR E End | RR E1 End
action_728:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR H End | RR H1 End
action_729:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB1C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR HL End | RR HL1 End
action_730:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR L End | RR L1 End
action_731:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB1D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR LParen HL RParen End
action_732:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR LParen IX RParen End
action_733:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR LParen IX expr RParen End
action_734:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR LParen IY RParen End
action_735:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RR LParen IY expr RParen End
action_736:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRA End | RRA1 End
action_737:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC A End | RRC A1 End
action_738:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB0F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC B End | RRC B1 End
action_739:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB08)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC C End | RRC C1 End
action_740:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB09)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC D End | RRC D1 End
action_741:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC E End | RRC E1 End
action_742:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC H End | RRC H1 End
action_743:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB0C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC L End | RRC L1 End
action_744:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB0D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC LParen HL RParen End
action_745:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC LParen IX RParen End
action_746:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC LParen IX expr RParen End
action_747:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC LParen IY RParen End
action_748:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRC LParen IY expr RParen End
action_749:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD RRCA End | RRCA1 End
action_750:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma A End | ALTD SBC A End | SBC A1 Comma A End
action_751:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma B End | ALTD SBC B End | SBC A1 Comma B End
action_752:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x98)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma C End | ALTD SBC C End | SBC A1 Comma C End
action_753:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x99)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma D End | ALTD SBC D End | SBC A1 Comma D End
action_754:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma E End | ALTD SBC E End | SBC A1 Comma E End
action_755:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma H End | ALTD SBC H End | SBC A1 Comma H End
action_756:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma L End | ALTD SBC L End | SBC A1 Comma L End
action_757:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma LParen HL Minus RParen End | ALTD SBC LParen HL Minus RParen End | SBC A1 Comma LParen HL Minus RParen End
action_758:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma LParen HL Plus RParen End | ALTD SBC LParen HL Plus RParen End | SBC A1 Comma LParen HL Plus RParen End
action_759:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma LParen HL RParen End | ALTD SBC LParen HL RParen End | SBC A1 Comma LParen HL RParen End
action_760:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma LParen IX RParen End | ALTD SBC LParen IX RParen End | SBC A1 Comma LParen IX RParen End
action_761:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma LParen IX expr RParen End | ALTD SBC LParen IX expr RParen End | SBC A1 Comma LParen IX expr RParen End
action_762:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma LParen IY RParen End | ALTD SBC LParen IY RParen End | SBC A1 Comma LParen IY RParen End
action_763:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma LParen IY expr RParen End | ALTD SBC LParen IY expr RParen End | SBC A1 Comma LParen IY expr RParen End
action_764:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC A Comma expr End | ALTD SBC expr End | SBC A1 Comma expr End
action_765:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0xDE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC HL Comma BC End | SBC HL1 Comma BC End
action_766:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED42)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC HL Comma DE End | SBC HL1 Comma DE End
action_767:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED52)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC HL Comma HL End | SBC HL1 Comma HL End
action_768:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED62)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SBC HL Comma SP End | SBC HL1 Comma SP End
action_769:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xED72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SCF End | SCF1 End
action_770:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x37)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SET const_expr Comma A End | SET const_expr Comma A1 End
action_771:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC7+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SET const_expr Comma B End | SET const_expr Comma B1 End
action_772:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC0+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SET const_expr Comma C End | SET const_expr Comma C1 End
action_773:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC1+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SET const_expr Comma D End | SET const_expr Comma D1 End
action_774:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC2+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SET const_expr Comma E End | SET const_expr Comma E1 End
action_775:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC3+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SET const_expr Comma H End | SET const_expr Comma H1 End
action_776:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC4+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SET const_expr Comma L End | SET const_expr Comma L1 End
action_777:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC5+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA A End | SLA A1 End
action_778:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB27)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA B End | SLA B1 End
action_779:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB20)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA C End | SLA C1 End
action_780:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB21)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA D End | SLA D1 End
action_781:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA E End | SLA E1 End
action_782:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA H End | SLA H1 End
action_783:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB24)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA L End | SLA L1 End
action_784:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB25)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA LParen HL RParen End
action_785:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA LParen IX RParen End
action_786:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA LParen IX expr RParen End
action_787:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA LParen IY RParen End
action_788:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SLA LParen IY expr RParen End
action_789:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA A End | SRA A1 End
action_790:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB2F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA B End | SRA B1 End
action_791:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB28)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA C End | SRA C1 End
action_792:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB29)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA D End | SRA D1 End
action_793:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA E End | SRA E1 End
action_794:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA H End | SRA H1 End
action_795:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB2C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA L End | SRA L1 End
action_796:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB2D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA LParen HL RParen End
action_797:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA LParen IX RParen End
action_798:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA LParen IX expr RParen End
action_799:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA LParen IY RParen End
action_800:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRA LParen IY expr RParen End
action_801:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL A End | SRL A1 End
action_802:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB3F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL B End | SRL B1 End
action_803:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB38)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL C End | SRL C1 End
action_804:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB39)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL D End | SRL D1 End
action_805:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL E End | SRL E1 End
action_806:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB3B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL H End | SRL H1 End
action_807:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB3C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL L End | SRL L1 End
action_808:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB3D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL LParen HL RParen End
action_809:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL LParen IX RParen End
action_810:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL LParen IX expr RParen End
action_811:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL LParen IY RParen End
action_812:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SRL LParen IY expr RParen End
action_813:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma A End | ALTD SUB A End | SUB A1 Comma A End
action_814:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x97)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma B End | ALTD SUB B End | SUB A1 Comma B End
action_815:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x90)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma C End | ALTD SUB C End | SUB A1 Comma C End
action_816:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x91)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma D End | ALTD SUB D End | SUB A1 Comma D End
action_817:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x92)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma E End | ALTD SUB E End | SUB A1 Comma E End
action_818:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x93)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma H End | ALTD SUB H End | SUB A1 Comma H End
action_819:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x94)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma L End | ALTD SUB L End | SUB A1 Comma L End
action_820:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x95)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma LParen HL Minus RParen End | ALTD SUB LParen HL Minus RParen End | SUB A1 Comma LParen HL Minus RParen End
action_821:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma LParen HL Plus RParen End | ALTD SUB LParen HL Plus RParen End | SUB A1 Comma LParen HL Plus RParen End
action_822:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma LParen HL RParen End | ALTD SUB LParen HL RParen End | SUB A1 Comma LParen HL RParen End
action_823:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0x96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma LParen IX RParen End | ALTD SUB LParen IX RParen End | SUB A1 Comma LParen IX RParen End
action_824:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma LParen IX expr RParen End | ALTD SUB LParen IX expr RParen End | SUB A1 Comma LParen IX expr RParen End
action_825:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma LParen IY RParen End | ALTD SUB LParen IY RParen End | SUB A1 Comma LParen IY RParen End
action_826:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma LParen IY expr RParen End | ALTD SUB LParen IY expr RParen End | SUB A1 Comma LParen IY expr RParen End
action_827:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD SUB A Comma expr End | ALTD SUB expr End | SUB A1 Comma expr End
action_828:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0xD6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma A End | ALTD XOR A End | XOR A1 Comma A End
action_829:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAF)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma B End | ALTD XOR B End | XOR A1 Comma B End
action_830:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma C End | ALTD XOR C End | XOR A1 Comma C End
action_831:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma D End | ALTD XOR D End | XOR A1 Comma D End
action_832:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma E End | ALTD XOR E End | XOR A1 Comma E End
action_833:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma H End | ALTD XOR H End | XOR A1 Comma H End
action_834:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma L End | ALTD XOR L End | XOR A1 Comma L End
action_835:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAD)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma LParen HL Minus RParen End | ALTD XOR LParen HL Minus RParen End | XOR A1 Comma LParen HL Minus RParen End
action_836:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma LParen HL Plus RParen End | ALTD XOR LParen HL Plus RParen End | XOR A1 Comma LParen HL Plus RParen End
action_837:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma LParen HL RParen End | ALTD XOR LParen HL RParen End | XOR A1 Comma LParen HL RParen End
action_838:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma LParen IX RParen End | ALTD XOR LParen IX RParen End | XOR A1 Comma LParen IX RParen End
action_839:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma LParen IX expr RParen End | ALTD XOR LParen IX expr RParen End | XOR A1 Comma LParen IX expr RParen End
action_840:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma LParen IY RParen End | ALTD XOR LParen IY RParen End | XOR A1 Comma LParen IY RParen End
action_841:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma LParen IY expr RParen End | ALTD XOR LParen IY expr RParen End | XOR A1 Comma LParen IY expr RParen End
action_842:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ALTD XOR A Comma expr End | ALTD XOR expr End | XOR A1 Comma expr End
action_843:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x76)*/;
/*DO_stmt_n(0xEE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ANA A End | AND A Comma A End | AND A End
action_844:
/*DO_stmt(0xA7)*/;
return true;

// action for: ANA B End | AND A Comma B End | AND B End
action_845:
/*DO_stmt(0xA0)*/;
return true;

// action for: ANA C End | AND A Comma C End | AND C End
action_846:
/*DO_stmt(0xA1)*/;
return true;

// action for: ANA D End | AND A Comma D End | AND D End
action_847:
/*DO_stmt(0xA2)*/;
return true;

// action for: ANA E End | AND A Comma E End | AND E End
action_848:
/*DO_stmt(0xA3)*/;
return true;

// action for: ANA H End | AND A Comma H End | AND H End
action_849:
/*DO_stmt(0xA4)*/;
return true;

// action for: ANA L End | AND A Comma L End | AND L End
action_850:
/*DO_stmt(0xA5)*/;
return true;

// action for: ANA M End | AND A Comma LParen HL RParen End | AND LParen HL RParen End
action_851:
/*DO_stmt(0xA6)*/;
return true;

// action for: AND A Comma IXH End | AND IXH End
action_852:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDA4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND A Comma IXL End | AND IXL End
action_853:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDA5)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND A Comma IYH End | AND IYH End
action_854:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDA4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND A Comma IYL End | AND IYL End
action_855:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDA5)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND A Comma LParen HL Minus RParen End | AND LParen HL Minus RParen End
action_856:
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: AND A Comma LParen HL Plus RParen End | AND LParen HL Plus RParen End
action_857:
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: AND A Comma LParen IX RParen End | AND LParen IX RParen End
action_858:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND A Comma LParen IX expr RParen End | AND LParen IX expr RParen End
action_859:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND A Comma LParen IY RParen End | AND LParen IY RParen End
action_860:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND A Comma LParen IY expr RParen End | AND LParen IY expr RParen End
action_861:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND A Comma expr End | AND expr End | ANI expr End
action_862:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xE6)*/;
return true;

// action for: AND HL Comma DE End
action_863:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND IX Comma DE End
action_864:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDDDC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: AND IY Comma DE End
action_865:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFDDC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: ARHL End | RRHL End | SRA HL End
action_866:
switch (option_cpu()) {
case CPU_8080: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sra_hl")*/;
break;
case CPU_8085: 
/*DO_stmt(0x10)*/;
break;
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB2C)*/;
/*DO_stmt(0xCB1D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma A End
action_867:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB47+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma B End
action_868:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB40+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma C End
action_869:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB41+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma D End
action_870:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB42+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma E End
action_871:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB43+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma H End
action_872:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB44+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma L End
action_873:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB45+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma LParen HL RParen End
action_874:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma LParen IX RParen End
action_875:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma LParen IX expr RParen End
action_876:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma LParen IY RParen End
action_877:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BIT const_expr Comma LParen IY expr RParen End
action_878:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BOOL HL End
action_879:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xCC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BOOL IX End
action_880:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDDCC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BOOL IY End
action_881:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFDCC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BRLC DE Comma B End
action_882:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED2C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BSLA DE Comma B End
action_883:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED28)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BSRA DE Comma B End
action_884:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED29)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BSRF DE Comma B End
action_885:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: BSRL DE Comma B End
action_886:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL C Comma expr End | CC expr End | C_C expr End
action_887:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x3003)*/;
/*DO_stmt_nn(0xCD)*/;
break;
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xDC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL LO Comma expr End | CLO expr End | C_LO expr End
action_888:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_STMT_LABEL();
Expr1 *target_expr = pop_expr(ctx);
const char *end_label = autolabel();
Expr1 *end_label_expr = parse_expr(end_label);
add_opcode_nn(0xE2, end_label_expr);
add_opcode_nn(0xCD, target_expr);
asm_LABEL_offset(end_label, 6);*/
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL LZ Comma expr End | CLZ expr End | C_LZ expr End
action_889:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_STMT_LABEL();
Expr1 *target_expr = pop_expr(ctx);
const char *end_label = autolabel();
Expr1 *end_label_expr = parse_expr(end_label);
add_opcode_nn(0xEA, end_label_expr);
add_opcode_nn(0xCD, target_expr);
asm_LABEL_offset(end_label, 6);*/
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL M Comma expr End | CM expr End | C_M expr End
action_890:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_STMT_LABEL();
Expr1 *target_expr = pop_expr(ctx);
const char *end_label = autolabel();
Expr1 *end_label_expr = parse_expr(end_label);
add_opcode_nn(0xF2, end_label_expr);
add_opcode_nn(0xCD, target_expr);
asm_LABEL_offset(end_label, 6);*/
break;
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xFC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL NC Comma expr End | CNC expr End | C_NC expr End
action_891:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x3803)*/;
/*DO_stmt_nn(0xCD)*/;
break;
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xD4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL NV Comma expr End | CALL PO Comma expr End | CNV expr End | CPO expr End | C_NV expr End | C_PO expr End
action_892:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_STMT_LABEL();
Expr1 *target_expr = pop_expr(ctx);
const char *end_label = autolabel();
Expr1 *end_label_expr = parse_expr(end_label);
add_opcode_nn(0xEA, end_label_expr);
add_opcode_nn(0xCD, target_expr);
asm_LABEL_offset(end_label, 6);*/
break;
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL NZ Comma expr End | CNZ expr End | C_NZ expr End
action_893:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x2803)*/;
/*DO_stmt_nn(0xCD)*/;
break;
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xC4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL P Comma expr End | C_P expr End
action_894:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_STMT_LABEL();
Expr1 *target_expr = pop_expr(ctx);
const char *end_label = autolabel();
Expr1 *end_label_expr = parse_expr(end_label);
add_opcode_nn(0xFA, end_label_expr);
add_opcode_nn(0xCD, target_expr);
asm_LABEL_offset(end_label, 6);*/
break;
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL PE Comma expr End | CALL V Comma expr End | CPE expr End | CV expr End | C_PE expr End | C_V expr End
action_895:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_STMT_LABEL();
Expr1 *target_expr = pop_expr(ctx);
const char *end_label = autolabel();
Expr1 *end_label_expr = parse_expr(end_label);
add_opcode_nn(0xE2, end_label_expr);
add_opcode_nn(0xCD, target_expr);
asm_LABEL_offset(end_label, 6);*/
break;
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xEC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL Z Comma expr End | CZ expr End | C_Z expr End
action_896:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x2003)*/;
/*DO_stmt_nn(0xCD)*/;
break;
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xCC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CALL expr End
action_897:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xCD)*/;
return true;

// action for: CCF End | CMC End
action_898:
/*DO_stmt(0x3F)*/;
return true;

// action for: CMA End | CPL A End | CPL End
action_899:
/*DO_stmt(0x2F)*/;
return true;

// action for: CMP A Comma A End | CMP A End | CP A Comma A End | CP A End
action_900:
/*DO_stmt(0xBF)*/;
return true;

// action for: CMP A Comma B End | CMP B End | CP A Comma B End | CP B End
action_901:
/*DO_stmt(0xB8)*/;
return true;

// action for: CMP A Comma C End | CMP C End | CP A Comma C End | CP C End
action_902:
/*DO_stmt(0xB9)*/;
return true;

// action for: CMP A Comma D End | CMP D End | CP A Comma D End | CP D End
action_903:
/*DO_stmt(0xBA)*/;
return true;

// action for: CMP A Comma E End | CMP E End | CP A Comma E End | CP E End
action_904:
/*DO_stmt(0xBB)*/;
return true;

// action for: CMP A Comma H End | CMP H End | CP A Comma H End | CP H End
action_905:
/*DO_stmt(0xBC)*/;
return true;

// action for: CMP A Comma IXH End | CMP IXH End | CP A Comma IXH End | CP IXH End
action_906:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDBC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CMP A Comma IXL End | CMP IXL End | CP A Comma IXL End | CP IXL End
action_907:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDBD)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CMP A Comma IYH End | CMP IYH End | CP A Comma IYH End | CP IYH End
action_908:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDBC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CMP A Comma IYL End | CMP IYL End | CP A Comma IYL End | CP IYL End
action_909:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDBD)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CMP A Comma L End | CMP L End | CP A Comma L End | CP L End
action_910:
/*DO_stmt(0xBD)*/;
return true;

// action for: CMP A Comma LParen HL Minus RParen End | CMP LParen HL Minus RParen End | CP A Comma LParen HL Minus RParen End | CP LParen HL Minus RParen End
action_911:
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: CMP A Comma LParen HL Plus RParen End | CMP LParen HL Plus RParen End | CP A Comma LParen HL Plus RParen End | CP LParen HL Plus RParen End
action_912:
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: CMP A Comma LParen HL RParen End | CMP M End | CMP LParen HL RParen End | CP A Comma LParen HL RParen End | CP LParen HL RParen End
action_913:
/*DO_stmt(0xBE)*/;
return true;

// action for: CMP A Comma LParen IX RParen End | CMP LParen IX RParen End | CP A Comma LParen IX RParen End | CP LParen IX RParen End
action_914:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CMP A Comma LParen IX expr RParen End | CMP LParen IX expr RParen End | CP A Comma LParen IX expr RParen End | CP LParen IX expr RParen End
action_915:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CMP A Comma LParen IY RParen End | CMP LParen IY RParen End | CP A Comma LParen IY RParen End | CP LParen IY RParen End
action_916:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CMP A Comma LParen IY expr RParen End | CMP LParen IY expr RParen End | CP A Comma LParen IY expr RParen End | CP LParen IY expr RParen End
action_917:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CMP A Comma expr End | CMP expr End | CP A Comma expr End | CP expr End | CPI expr End
action_918:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xFE)*/;
return true;

// action for: CPD End
action_919:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__cpd")*/;
break;
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDA9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CPDR End
action_920:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__cpdr")*/;
break;
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDB9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CPI End
action_921:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__cpi")*/;
break;
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDA1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: CPIR End
action_922:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__cpir")*/;
break;
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDB1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DAA End
action_923:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__daa")*/;
break;
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0x27)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DCR A End | DEC A End
action_924:
/*DO_stmt(0x3D)*/;
return true;

// action for: DCR B End | DEC B End
action_925:
/*DO_stmt(0x05)*/;
return true;

// action for: DCR C End | DEC C End
action_926:
/*DO_stmt(0x0D)*/;
return true;

// action for: DCR D End | DEC D End
action_927:
/*DO_stmt(0x15)*/;
return true;

// action for: DCR E End | DEC E End
action_928:
/*DO_stmt(0x1D)*/;
return true;

// action for: DCR H End | DEC H End
action_929:
/*DO_stmt(0x25)*/;
return true;

// action for: DCR L End | DEC L End
action_930:
/*DO_stmt(0x2D)*/;
return true;

// action for: DCR M End | DEC LParen HL RParen End
action_931:
/*DO_stmt(0x35)*/;
return true;

// action for: DCX B End | DCX BC End | DEC BC End
action_932:
/*DO_stmt(0x0B)*/;
return true;

// action for: DCX D End | DCX DE End | DEC DE End
action_933:
/*DO_stmt(0x1B)*/;
return true;

// action for: DCX H End | DCX HL End | DEC HL End
action_934:
/*DO_stmt(0x2B)*/;
return true;

// action for: DCX SP End | DEC SP End
action_935:
/*DO_stmt(0x3B)*/;
return true;

// action for: DEC IX End
action_936:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DEC IXH End
action_937:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD25)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DEC IXL End
action_938:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD2D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DEC IY End
action_939:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DEC IYH End
action_940:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD25)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DEC IYL End
action_941:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD2D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DEC LParen HL Minus RParen End
action_942:
/*DO_stmt(0x35)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: DEC LParen HL Plus RParen End
action_943:
/*DO_stmt(0x35)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: DEC LParen IX RParen End
action_944:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DEC LParen IX expr RParen End
action_945:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DEC LParen IY RParen End
action_946:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DEC LParen IY expr RParen End
action_947:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DI End
action_948:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xF3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DJNZ B Comma expr End | DJNZ expr End
action_949:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x05)*/;
/*DO_stmt_nn(0xC2)*/;
break;
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0x05)*/;
/*add_opcode_jr_n(0x20, pop_expr(ctx), 1)*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_jr(0x10)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: DSUB End | SUB HL Comma BC End
action_950:
switch (option_cpu()) {
case CPU_8080: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sub_hl_bc")*/;
break;
case CPU_8085: 
/*DO_stmt(0x08)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: EI End
action_951:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: EX AF Comma AF End | EX AF Comma AF1 End
action_952:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0x08)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: EX DE Comma HL End | XCHG End
action_953:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xE5)*/;
/*DO_stmt(0xD5)*/;
/*DO_stmt(0xE1)*/;
/*DO_stmt(0xD1)*/;
break;
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: EX DE1 Comma HL End
action_954:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xE3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: EX LParen SP RParen Comma HL End
action_955:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__ex_sp_hl")*/;
break;
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xE3)*/;
break;
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED54)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: EX LParen SP RParen Comma IX End
action_956:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDE3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: EX LParen SP RParen Comma IY End
action_957:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDE3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: EXTERN | GLOBAL | ORG expr End | PUBLIC | SECTION | Label EQU expr End
action_958:
	while (!m_lexer.at_end()) m_lexer.next();
return true;

// action for: EXX End
action_959:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xD9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: HALT End | HLT End
action_960:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0x76)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IDET End
action_961:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0x5B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IM const_expr End
action_962:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xED00+((expr_value==0?0x46:expr_value==1?0x56:0x5E)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN A Comma LParen C RParen End
action_963:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED78)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN A Comma expr End
action_964:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xDB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN B Comma LParen C RParen End
action_965:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED40)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN C Comma LParen C RParen End
action_966:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED48)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN D Comma LParen C RParen End
action_967:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED50)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN E Comma LParen C RParen End
action_968:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED58)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN F Comma LParen C RParen End | IN LParen C RParen End
action_969:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED70)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN H Comma LParen C RParen End
action_970:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED60)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN L Comma LParen C RParen End
action_971:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED68)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN expr End
action_972:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xDB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN0 A Comma expr End
action_973:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED38)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN0 B Comma expr End
action_974:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN0 C Comma expr End
action_975:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED08)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN0 D Comma expr End
action_976:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED10)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN0 E Comma expr End
action_977:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED18)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN0 F Comma expr End | IN0 expr End
action_978:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED30)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN0 H Comma expr End
action_979:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED20)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IN0 L Comma expr End
action_980:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED28)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC A End | INR A End
action_981:
/*DO_stmt(0x3C)*/;
return true;

// action for: INC B End | INR B End
action_982:
/*DO_stmt(0x04)*/;
return true;

// action for: INC BC End | INX B End | INX BC End
action_983:
/*DO_stmt(0x03)*/;
return true;

// action for: INC C End | INR C End
action_984:
/*DO_stmt(0x0C)*/;
return true;

// action for: INC D End | INR D End
action_985:
/*DO_stmt(0x14)*/;
return true;

// action for: INC DE End | INX D End | INX DE End
action_986:
/*DO_stmt(0x13)*/;
return true;

// action for: INC E End | INR E End
action_987:
/*DO_stmt(0x1C)*/;
return true;

// action for: INC H End | INR H End
action_988:
/*DO_stmt(0x24)*/;
return true;

// action for: INC HL End | INX H End | INX HL End
action_989:
/*DO_stmt(0x23)*/;
return true;

// action for: INC IX End
action_990:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC IXH End
action_991:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD24)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC IXL End
action_992:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD2C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC IY End
action_993:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC IYH End
action_994:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD24)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC IYL End
action_995:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD2C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC L End | INR L End
action_996:
/*DO_stmt(0x2C)*/;
return true;

// action for: INC SP End | INX SP End
action_997:
/*DO_stmt(0x33)*/;
return true;

// action for: INC LParen HL Minus RParen End
action_998:
/*DO_stmt(0x34)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: INC LParen HL Plus RParen End
action_999:
/*DO_stmt(0x34)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: INC LParen HL RParen End | INR M End
action_1000:
/*DO_stmt(0x34)*/;
return true;

// action for: INC LParen IX RParen End
action_1001:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC LParen IX expr RParen End
action_1002:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC LParen IY RParen End
action_1003:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INC LParen IY expr RParen End
action_1004:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IND End
action_1005:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDAA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INDR End
action_1006:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDBA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INI End
action_1007:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDA2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: INIR End
action_1008:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDB2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A Comma LParen HL Minus RParen End | IOE ADC LParen HL Minus RParen End
action_1009:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A Comma LParen HL Plus RParen End | IOE ADC LParen HL Plus RParen End
action_1010:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A Comma LParen HL RParen End | IOE ADC LParen HL RParen End
action_1011:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A Comma LParen IX RParen End | IOE ADC LParen IX RParen End
action_1012:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A Comma LParen IX expr RParen End | IOE ADC LParen IX expr RParen End
action_1013:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A Comma LParen IY RParen End | IOE ADC LParen IY RParen End
action_1014:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A Comma LParen IY expr RParen End | IOE ADC LParen IY expr RParen End
action_1015:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A1 Comma LParen HL Minus RParen End | IOE ALTD ADC A Comma LParen HL Minus RParen End | IOE ALTD ADC LParen HL Minus RParen End
action_1016:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A1 Comma LParen HL Plus RParen End | IOE ALTD ADC A Comma LParen HL Plus RParen End | IOE ALTD ADC LParen HL Plus RParen End
action_1017:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A1 Comma LParen HL RParen End | IOE ALTD ADC A Comma LParen HL RParen End | IOE ALTD ADC LParen HL RParen End
action_1018:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A1 Comma LParen IX RParen End | IOE ALTD ADC A Comma LParen IX RParen End | IOE ALTD ADC LParen IX RParen End
action_1019:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A1 Comma LParen IX expr RParen End | IOE ALTD ADC A Comma LParen IX expr RParen End | IOE ALTD ADC LParen IX expr RParen End
action_1020:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A1 Comma LParen IY RParen End | IOE ALTD ADC A Comma LParen IY RParen End | IOE ALTD ADC LParen IY RParen End
action_1021:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADC A1 Comma LParen IY expr RParen End | IOE ALTD ADC A Comma LParen IY expr RParen End | IOE ALTD ADC LParen IY expr RParen End
action_1022:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A Comma LParen HL Minus RParen End | IOE ADD LParen HL Minus RParen End
action_1023:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A Comma LParen HL Plus RParen End | IOE ADD LParen HL Plus RParen End
action_1024:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A Comma LParen HL RParen End | IOE ADD LParen HL RParen End
action_1025:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A Comma LParen IX RParen End | IOE ADD LParen IX RParen End
action_1026:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A Comma LParen IX expr RParen End | IOE ADD LParen IX expr RParen End
action_1027:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A Comma LParen IY RParen End | IOE ADD LParen IY RParen End
action_1028:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A Comma LParen IY expr RParen End | IOE ADD LParen IY expr RParen End
action_1029:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A1 Comma LParen HL Minus RParen End | IOE ALTD ADD A Comma LParen HL Minus RParen End | IOE ALTD ADD LParen HL Minus RParen End
action_1030:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A1 Comma LParen HL Plus RParen End | IOE ALTD ADD A Comma LParen HL Plus RParen End | IOE ALTD ADD LParen HL Plus RParen End
action_1031:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A1 Comma LParen HL RParen End | IOE ALTD ADD A Comma LParen HL RParen End | IOE ALTD ADD LParen HL RParen End
action_1032:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A1 Comma LParen IX RParen End | IOE ALTD ADD A Comma LParen IX RParen End | IOE ALTD ADD LParen IX RParen End
action_1033:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A1 Comma LParen IX expr RParen End | IOE ALTD ADD A Comma LParen IX expr RParen End | IOE ALTD ADD LParen IX expr RParen End
action_1034:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A1 Comma LParen IY RParen End | IOE ALTD ADD A Comma LParen IY RParen End | IOE ALTD ADD LParen IY RParen End
action_1035:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ADD A1 Comma LParen IY expr RParen End | IOE ALTD ADD A Comma LParen IY expr RParen End | IOE ALTD ADD LParen IY expr RParen End
action_1036:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD AND A Comma LParen HL Minus RParen End | IOE ALTD AND LParen HL Minus RParen End | IOE AND A1 Comma LParen HL Minus RParen End
action_1037:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD AND A Comma LParen HL Plus RParen End | IOE ALTD AND LParen HL Plus RParen End | IOE AND A1 Comma LParen HL Plus RParen End
action_1038:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD AND A Comma LParen HL RParen End | IOE ALTD AND LParen HL RParen End | IOE AND A1 Comma LParen HL RParen End
action_1039:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD AND A Comma LParen IX RParen End | IOE ALTD AND LParen IX RParen End | IOE AND A1 Comma LParen IX RParen End
action_1040:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD AND A Comma LParen IX expr RParen End | IOE ALTD AND LParen IX expr RParen End | IOE AND A1 Comma LParen IX expr RParen End
action_1041:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD AND A Comma LParen IY RParen End | IOE ALTD AND LParen IY RParen End | IOE AND A1 Comma LParen IY RParen End
action_1042:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD AND A Comma LParen IY expr RParen End | IOE ALTD AND LParen IY expr RParen End | IOE AND A1 Comma LParen IY expr RParen End
action_1043:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD BIT const_expr Comma LParen HL RParen End
action_1044:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD BIT const_expr Comma LParen IX RParen End
action_1045:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD BIT const_expr Comma LParen IX expr RParen End
action_1046:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD BIT const_expr Comma LParen IY RParen End
action_1047:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD BIT const_expr Comma LParen IY expr RParen End
action_1048:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD CP A Comma LParen HL Minus RParen End | IOE ALTD CP LParen HL Minus RParen End
action_1049:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD CP A Comma LParen HL Plus RParen End | IOE ALTD CP LParen HL Plus RParen End
action_1050:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD CP A Comma LParen HL RParen End | IOE ALTD CP LParen HL RParen End
action_1051:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD CP A Comma LParen IX RParen End | IOE ALTD CP LParen IX RParen End
action_1052:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD CP A Comma LParen IX expr RParen End | IOE ALTD CP LParen IX expr RParen End
action_1053:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD CP A Comma LParen IY RParen End | IOE ALTD CP LParen IY RParen End
action_1054:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD CP A Comma LParen IY expr RParen End | IOE ALTD CP LParen IY expr RParen End
action_1055:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD DEC LParen HL Minus RParen End
action_1056:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD DEC LParen HL Plus RParen End
action_1057:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD DEC LParen HL RParen End
action_1058:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD DEC LParen IX RParen End
action_1059:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD DEC LParen IX expr RParen End
action_1060:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD DEC LParen IY RParen End
action_1061:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD DEC LParen IY expr RParen End
action_1062:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD INC LParen HL Minus RParen End
action_1063:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD INC LParen HL Plus RParen End
action_1064:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD INC LParen HL RParen End
action_1065:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD INC LParen IX RParen End
action_1066:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD INC LParen IX expr RParen End
action_1067:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD INC LParen IY RParen End
action_1068:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD INC LParen IY expr RParen End
action_1069:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen BC Minus RParen End | IOE LD A1 Comma LParen BC Minus RParen End
action_1070:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen BC Plus RParen End | IOE LD A1 Comma LParen BC Plus RParen End
action_1071:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen BC RParen End | IOE LD A1 Comma LParen BC RParen End
action_1072:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen DE Minus RParen End | IOE LD A1 Comma LParen DE Minus RParen End
action_1073:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen DE Plus RParen End | IOE LD A1 Comma LParen DE Plus RParen End
action_1074:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen DE RParen End | IOE LD A1 Comma LParen DE RParen End
action_1075:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen HL Minus RParen End | IOE ALTD LD A Comma LParen HLD RParen End | IOE LD A1 Comma LParen HL Minus RParen End | IOE LD A1 Comma LParen HLD RParen End
action_1076:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen HL Plus RParen End | IOE ALTD LD A Comma LParen HLI RParen End | IOE LD A1 Comma LParen HL Plus RParen End | IOE LD A1 Comma LParen HLI RParen End
action_1077:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen HL RParen End | IOE LD A1 Comma LParen HL RParen End
action_1078:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen IX RParen End | IOE LD A1 Comma LParen IX RParen End
action_1079:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen IX expr RParen End | IOE LD A1 Comma LParen IX expr RParen End
action_1080:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen IY RParen End | IOE LD A1 Comma LParen IY RParen End
action_1081:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma LParen IY expr RParen End | IOE LD A1 Comma LParen IY expr RParen End
action_1082:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD A Comma expr End | IOE LD A1 Comma expr End
action_1083:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_nn(0x3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD B Comma LParen HL Minus RParen End | IOE ALTD LD B Comma LParen HLD RParen End | IOE LD B1 Comma LParen HL Minus RParen End | IOE LD B1 Comma LParen HLD RParen End
action_1084:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD B Comma LParen HL Plus RParen End | IOE ALTD LD B Comma LParen HLI RParen End | IOE LD B1 Comma LParen HL Plus RParen End | IOE LD B1 Comma LParen HLI RParen End
action_1085:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD B Comma LParen HL RParen End | IOE LD B1 Comma LParen HL RParen End
action_1086:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD B Comma LParen IX RParen End | IOE LD B1 Comma LParen IX RParen End
action_1087:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD B Comma LParen IX expr RParen End | IOE LD B1 Comma LParen IX expr RParen End
action_1088:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD B Comma LParen IY RParen End | IOE LD B1 Comma LParen IY RParen End
action_1089:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD B Comma LParen IY expr RParen End | IOE LD B1 Comma LParen IY expr RParen End
action_1090:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD BC Comma expr End | IOE LD BC1 Comma expr End
action_1091:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_nn(0xED4B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD C Comma LParen HL Minus RParen End | IOE ALTD LD C Comma LParen HLD RParen End | IOE LD C1 Comma LParen HL Minus RParen End | IOE LD C1 Comma LParen HLD RParen End
action_1092:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD C Comma LParen HL Plus RParen End | IOE ALTD LD C Comma LParen HLI RParen End | IOE LD C1 Comma LParen HL Plus RParen End | IOE LD C1 Comma LParen HLI RParen End
action_1093:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD C Comma LParen HL RParen End | IOE LD C1 Comma LParen HL RParen End
action_1094:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD C Comma LParen IX RParen End | IOE LD C1 Comma LParen IX RParen End
action_1095:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD C Comma LParen IX expr RParen End | IOE LD C1 Comma LParen IX expr RParen End
action_1096:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD C Comma LParen IY RParen End | IOE LD C1 Comma LParen IY RParen End
action_1097:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD C Comma LParen IY expr RParen End | IOE LD C1 Comma LParen IY expr RParen End
action_1098:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD D Comma LParen HL Minus RParen End | IOE ALTD LD D Comma LParen HLD RParen End | IOE LD D1 Comma LParen HL Minus RParen End | IOE LD D1 Comma LParen HLD RParen End
action_1099:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD D Comma LParen HL Plus RParen End | IOE ALTD LD D Comma LParen HLI RParen End | IOE LD D1 Comma LParen HL Plus RParen End | IOE LD D1 Comma LParen HLI RParen End
action_1100:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD D Comma LParen HL RParen End | IOE LD D1 Comma LParen HL RParen End
action_1101:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD D Comma LParen IX RParen End | IOE LD D1 Comma LParen IX RParen End
action_1102:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD D Comma LParen IX expr RParen End | IOE LD D1 Comma LParen IX expr RParen End
action_1103:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD D Comma LParen IY RParen End | IOE LD D1 Comma LParen IY RParen End
action_1104:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD D Comma LParen IY expr RParen End | IOE LD D1 Comma LParen IY expr RParen End
action_1105:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD DE Comma expr End | IOE LD DE1 Comma expr End
action_1106:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_nn(0xED5B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD E Comma LParen HL Minus RParen End | IOE ALTD LD E Comma LParen HLD RParen End | IOE LD E1 Comma LParen HL Minus RParen End | IOE LD E1 Comma LParen HLD RParen End
action_1107:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD E Comma LParen HL Plus RParen End | IOE ALTD LD E Comma LParen HLI RParen End | IOE LD E1 Comma LParen HL Plus RParen End | IOE LD E1 Comma LParen HLI RParen End
action_1108:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD E Comma LParen HL RParen End | IOE LD E1 Comma LParen HL RParen End
action_1109:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD E Comma LParen IX RParen End | IOE LD E1 Comma LParen IX RParen End
action_1110:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD E Comma LParen IX expr RParen End | IOE LD E1 Comma LParen IX expr RParen End
action_1111:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD E Comma LParen IY RParen End | IOE LD E1 Comma LParen IY RParen End
action_1112:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD E Comma LParen IY expr RParen End | IOE LD E1 Comma LParen IY expr RParen End
action_1113:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD H Comma LParen HL Minus RParen End | IOE ALTD LD H Comma LParen HLD RParen End | IOE LD H1 Comma LParen HL Minus RParen End | IOE LD H1 Comma LParen HLD RParen End
action_1114:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD H Comma LParen HL Plus RParen End | IOE ALTD LD H Comma LParen HLI RParen End | IOE LD H1 Comma LParen HL Plus RParen End | IOE LD H1 Comma LParen HLI RParen End
action_1115:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD H Comma LParen HL RParen End | IOE LD H1 Comma LParen HL RParen End
action_1116:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD H Comma LParen IX RParen End | IOE LD H1 Comma LParen IX RParen End
action_1117:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD H Comma LParen IX expr RParen End | IOE LD H1 Comma LParen IX expr RParen End
action_1118:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD H Comma LParen IY RParen End | IOE LD H1 Comma LParen IY RParen End
action_1119:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD H Comma LParen IY expr RParen End | IOE LD H1 Comma LParen IY expr RParen End
action_1120:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD HL Comma LParen HL RParen End | IOE LD HL1 Comma LParen HL RParen End
action_1121:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD HL Comma LParen HL expr RParen End | IOE LD HL1 Comma LParen HL expr RParen End
action_1122:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD HL Comma LParen IX RParen End | IOE LD HL1 Comma LParen IX RParen End
action_1123:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD HL Comma LParen IX expr RParen End | IOE LD HL1 Comma LParen IX expr RParen End
action_1124:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD HL Comma LParen IY RParen End | IOE LD HL1 Comma LParen IY RParen End
action_1125:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD HL Comma LParen IY expr RParen End | IOE LD HL1 Comma LParen IY expr RParen End
action_1126:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD HL Comma expr End | IOE LD HL1 Comma expr End
action_1127:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_nn(0x2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD L Comma LParen HL Minus RParen End | IOE ALTD LD L Comma LParen HLD RParen End | IOE LD L1 Comma LParen HL Minus RParen End | IOE LD L1 Comma LParen HLD RParen End
action_1128:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD L Comma LParen HL Plus RParen End | IOE ALTD LD L Comma LParen HLI RParen End | IOE LD L1 Comma LParen HL Plus RParen End | IOE LD L1 Comma LParen HLI RParen End
action_1129:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD L Comma LParen HL RParen End | IOE LD L1 Comma LParen HL RParen End
action_1130:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD L Comma LParen IX RParen End | IOE LD L1 Comma LParen IX RParen End
action_1131:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD L Comma LParen IX expr RParen End | IOE LD L1 Comma LParen IX expr RParen End
action_1132:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD L Comma LParen IY RParen End | IOE LD L1 Comma LParen IY RParen End
action_1133:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD LD L Comma LParen IY expr RParen End | IOE LD L1 Comma LParen IY expr RParen End
action_1134:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD OR A Comma LParen HL Minus RParen End | IOE ALTD OR LParen HL Minus RParen End | IOE OR A1 Comma LParen HL Minus RParen End
action_1135:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD OR A Comma LParen HL Plus RParen End | IOE ALTD OR LParen HL Plus RParen End | IOE OR A1 Comma LParen HL Plus RParen End
action_1136:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD OR A Comma LParen HL RParen End | IOE ALTD OR LParen HL RParen End | IOE OR A1 Comma LParen HL RParen End
action_1137:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD OR A Comma LParen IX RParen End | IOE ALTD OR LParen IX RParen End | IOE OR A1 Comma LParen IX RParen End
action_1138:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD OR A Comma LParen IX expr RParen End | IOE ALTD OR LParen IX expr RParen End | IOE OR A1 Comma LParen IX expr RParen End
action_1139:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD OR A Comma LParen IY RParen End | IOE ALTD OR LParen IY RParen End | IOE OR A1 Comma LParen IY RParen End
action_1140:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD OR A Comma LParen IY expr RParen End | IOE ALTD OR LParen IY expr RParen End | IOE OR A1 Comma LParen IY expr RParen End
action_1141:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RL LParen HL RParen End
action_1142:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RL LParen IX RParen End
action_1143:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RL LParen IX expr RParen End
action_1144:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RL LParen IY RParen End
action_1145:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RL LParen IY expr RParen End
action_1146:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RLC LParen HL RParen End
action_1147:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RLC LParen IX RParen End
action_1148:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RLC LParen IX expr RParen End
action_1149:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RLC LParen IY RParen End
action_1150:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RLC LParen IY expr RParen End
action_1151:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RR LParen HL RParen End
action_1152:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RR LParen IX RParen End
action_1153:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RR LParen IX expr RParen End
action_1154:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RR LParen IY RParen End
action_1155:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RR LParen IY expr RParen End
action_1156:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RRC LParen HL RParen End
action_1157:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RRC LParen IX RParen End
action_1158:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RRC LParen IX expr RParen End
action_1159:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RRC LParen IY RParen End
action_1160:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD RRC LParen IY expr RParen End
action_1161:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SBC A Comma LParen HL Minus RParen End | IOE ALTD SBC LParen HL Minus RParen End | IOE SBC A1 Comma LParen HL Minus RParen End
action_1162:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SBC A Comma LParen HL Plus RParen End | IOE ALTD SBC LParen HL Plus RParen End | IOE SBC A1 Comma LParen HL Plus RParen End
action_1163:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SBC A Comma LParen HL RParen End | IOE ALTD SBC LParen HL RParen End | IOE SBC A1 Comma LParen HL RParen End
action_1164:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SBC A Comma LParen IX RParen End | IOE ALTD SBC LParen IX RParen End | IOE SBC A1 Comma LParen IX RParen End
action_1165:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SBC A Comma LParen IX expr RParen End | IOE ALTD SBC LParen IX expr RParen End | IOE SBC A1 Comma LParen IX expr RParen End
action_1166:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SBC A Comma LParen IY RParen End | IOE ALTD SBC LParen IY RParen End | IOE SBC A1 Comma LParen IY RParen End
action_1167:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SBC A Comma LParen IY expr RParen End | IOE ALTD SBC LParen IY expr RParen End | IOE SBC A1 Comma LParen IY expr RParen End
action_1168:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SLA LParen HL RParen End
action_1169:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SLA LParen IX RParen End
action_1170:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SLA LParen IX expr RParen End
action_1171:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SLA LParen IY RParen End
action_1172:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SLA LParen IY expr RParen End
action_1173:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRA LParen HL RParen End
action_1174:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRA LParen IX RParen End
action_1175:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRA LParen IX expr RParen End
action_1176:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRA LParen IY RParen End
action_1177:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRA LParen IY expr RParen End
action_1178:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRL LParen HL RParen End
action_1179:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRL LParen IX RParen End
action_1180:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRL LParen IX expr RParen End
action_1181:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRL LParen IY RParen End
action_1182:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SRL LParen IY expr RParen End
action_1183:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SUB A Comma LParen HL Minus RParen End | IOE ALTD SUB LParen HL Minus RParen End | IOE SUB A1 Comma LParen HL Minus RParen End
action_1184:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SUB A Comma LParen HL Plus RParen End | IOE ALTD SUB LParen HL Plus RParen End | IOE SUB A1 Comma LParen HL Plus RParen End
action_1185:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SUB A Comma LParen HL RParen End | IOE ALTD SUB LParen HL RParen End | IOE SUB A1 Comma LParen HL RParen End
action_1186:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SUB A Comma LParen IX RParen End | IOE ALTD SUB LParen IX RParen End | IOE SUB A1 Comma LParen IX RParen End
action_1187:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SUB A Comma LParen IX expr RParen End | IOE ALTD SUB LParen IX expr RParen End | IOE SUB A1 Comma LParen IX expr RParen End
action_1188:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SUB A Comma LParen IY RParen End | IOE ALTD SUB LParen IY RParen End | IOE SUB A1 Comma LParen IY RParen End
action_1189:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD SUB A Comma LParen IY expr RParen End | IOE ALTD SUB LParen IY expr RParen End | IOE SUB A1 Comma LParen IY expr RParen End
action_1190:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD XOR A Comma LParen HL Minus RParen End | IOE ALTD XOR LParen HL Minus RParen End | IOE XOR A1 Comma LParen HL Minus RParen End
action_1191:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD XOR A Comma LParen HL Plus RParen End | IOE ALTD XOR LParen HL Plus RParen End | IOE XOR A1 Comma LParen HL Plus RParen End
action_1192:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD XOR A Comma LParen HL RParen End | IOE ALTD XOR LParen HL RParen End | IOE XOR A1 Comma LParen HL RParen End
action_1193:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD XOR A Comma LParen IX RParen End | IOE ALTD XOR LParen IX RParen End | IOE XOR A1 Comma LParen IX RParen End
action_1194:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD XOR A Comma LParen IX expr RParen End | IOE ALTD XOR LParen IX expr RParen End | IOE XOR A1 Comma LParen IX expr RParen End
action_1195:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD XOR A Comma LParen IY RParen End | IOE ALTD XOR LParen IY RParen End | IOE XOR A1 Comma LParen IY RParen End
action_1196:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE ALTD XOR A Comma LParen IY expr RParen End | IOE ALTD XOR LParen IY expr RParen End | IOE XOR A1 Comma LParen IY expr RParen End
action_1197:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE AND A Comma LParen HL Minus RParen End | IOE AND LParen HL Minus RParen End
action_1198:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE AND A Comma LParen HL Plus RParen End | IOE AND LParen HL Plus RParen End
action_1199:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE AND A Comma LParen HL RParen End | IOE AND LParen HL RParen End
action_1200:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE AND A Comma LParen IX RParen End | IOE AND LParen IX RParen End
action_1201:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE AND A Comma LParen IX expr RParen End | IOE AND LParen IX expr RParen End
action_1202:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE AND A Comma LParen IY RParen End | IOE AND LParen IY RParen End
action_1203:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE AND A Comma LParen IY expr RParen End | IOE AND LParen IY expr RParen End
action_1204:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE BIT const_expr Comma LParen HL RParen End
action_1205:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE BIT const_expr Comma LParen IX RParen End
action_1206:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE BIT const_expr Comma LParen IX expr RParen End
action_1207:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE BIT const_expr Comma LParen IY RParen End
action_1208:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE BIT const_expr Comma LParen IY expr RParen End
action_1209:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE CMP A Comma LParen HL Minus RParen End | IOE CMP LParen HL Minus RParen End | IOE CP A Comma LParen HL Minus RParen End | IOE CP LParen HL Minus RParen End
action_1210:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE CMP A Comma LParen HL Plus RParen End | IOE CMP LParen HL Plus RParen End | IOE CP A Comma LParen HL Plus RParen End | IOE CP LParen HL Plus RParen End
action_1211:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE CMP A Comma LParen HL RParen End | IOE CMP LParen HL RParen End | IOE CP A Comma LParen HL RParen End | IOE CP LParen HL RParen End
action_1212:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE CMP A Comma LParen IX RParen End | IOE CMP LParen IX RParen End | IOE CP A Comma LParen IX RParen End | IOE CP LParen IX RParen End
action_1213:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE CMP A Comma LParen IX expr RParen End | IOE CMP LParen IX expr RParen End | IOE CP A Comma LParen IX expr RParen End | IOE CP LParen IX expr RParen End
action_1214:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE CMP A Comma LParen IY RParen End | IOE CMP LParen IY RParen End | IOE CP A Comma LParen IY RParen End | IOE CP LParen IY RParen End
action_1215:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE CMP A Comma LParen IY expr RParen End | IOE CMP LParen IY expr RParen End | IOE CP A Comma LParen IY expr RParen End | IOE CP LParen IY expr RParen End
action_1216:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE DEC LParen HL Minus RParen End
action_1217:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE DEC LParen HL Plus RParen End
action_1218:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE DEC LParen HL RParen End
action_1219:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE DEC LParen IX RParen End
action_1220:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE DEC LParen IX expr RParen End
action_1221:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE DEC LParen IY RParen End
action_1222:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE DEC LParen IY expr RParen End
action_1223:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE INC LParen HL Minus RParen End
action_1224:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE INC LParen HL Plus RParen End
action_1225:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE INC LParen HL RParen End
action_1226:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE INC LParen IX RParen End
action_1227:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE INC LParen IX expr RParen End
action_1228:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE INC LParen IY RParen End
action_1229:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE INC LParen IY expr RParen End
action_1230:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen BC Minus RParen End | IOE LDD A Comma LParen BC RParen End
action_1231:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen BC Plus RParen End | IOE LDI A Comma LParen BC RParen End
action_1232:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen BC RParen End
action_1233:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen DE Minus RParen End | IOE LDD A Comma LParen DE RParen End
action_1234:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen DE Plus RParen End | IOE LDI A Comma LParen DE RParen End
action_1235:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen DE RParen End
action_1236:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen HL Minus RParen End | IOE LD A Comma LParen HLD RParen End | IOE LDD A Comma LParen HL RParen End
action_1237:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen HL Plus RParen End | IOE LD A Comma LParen HLI RParen End | IOE LDI A Comma LParen HL RParen End
action_1238:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen HL RParen End
action_1239:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen IX RParen End
action_1240:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen IX expr RParen End
action_1241:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen IY RParen End
action_1242:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma LParen IY expr RParen End
action_1243:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD A Comma expr End
action_1244:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0x3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD B Comma LParen HL Minus RParen End | IOE LD B Comma LParen HLD RParen End | IOE LDD B Comma LParen HL RParen End
action_1245:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD B Comma LParen HL Plus RParen End | IOE LD B Comma LParen HLI RParen End | IOE LDI B Comma LParen HL RParen End
action_1246:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD B Comma LParen HL RParen End
action_1247:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD B Comma LParen IX RParen End
action_1248:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD B Comma LParen IX expr RParen End
action_1249:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD B Comma LParen IY RParen End
action_1250:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD B Comma LParen IY expr RParen End
action_1251:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD BC Comma expr End
action_1252:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xED4B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD C Comma LParen HL Minus RParen End | IOE LD C Comma LParen HLD RParen End | IOE LDD C Comma LParen HL RParen End
action_1253:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD C Comma LParen HL Plus RParen End | IOE LD C Comma LParen HLI RParen End | IOE LDI C Comma LParen HL RParen End
action_1254:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD C Comma LParen HL RParen End
action_1255:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD C Comma LParen IX RParen End
action_1256:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD C Comma LParen IX expr RParen End
action_1257:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD C Comma LParen IY RParen End
action_1258:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD C Comma LParen IY expr RParen End
action_1259:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD D Comma LParen HL Minus RParen End | IOE LD D Comma LParen HLD RParen End | IOE LDD D Comma LParen HL RParen End
action_1260:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD D Comma LParen HL Plus RParen End | IOE LD D Comma LParen HLI RParen End | IOE LDI D Comma LParen HL RParen End
action_1261:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD D Comma LParen HL RParen End
action_1262:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD D Comma LParen IX RParen End
action_1263:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD D Comma LParen IX expr RParen End
action_1264:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD D Comma LParen IY RParen End
action_1265:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD D Comma LParen IY expr RParen End
action_1266:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD DE Comma expr End
action_1267:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xED5B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD E Comma LParen HL Minus RParen End | IOE LD E Comma LParen HLD RParen End | IOE LDD E Comma LParen HL RParen End
action_1268:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD E Comma LParen HL Plus RParen End | IOE LD E Comma LParen HLI RParen End | IOE LDI E Comma LParen HL RParen End
action_1269:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD E Comma LParen HL RParen End
action_1270:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD E Comma LParen IX RParen End
action_1271:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD E Comma LParen IX expr RParen End
action_1272:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD E Comma LParen IY RParen End
action_1273:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD E Comma LParen IY expr RParen End
action_1274:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD H Comma LParen HL Minus RParen End | IOE LD H Comma LParen HLD RParen End | IOE LDD H Comma LParen HL RParen End
action_1275:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD H Comma LParen HL Plus RParen End | IOE LD H Comma LParen HLI RParen End | IOE LDI H Comma LParen HL RParen End
action_1276:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD H Comma LParen HL RParen End
action_1277:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD H Comma LParen IX RParen End
action_1278:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD H Comma LParen IX expr RParen End
action_1279:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD H Comma LParen IY RParen End
action_1280:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD H Comma LParen IY expr RParen End
action_1281:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD HL Comma LParen HL RParen End
action_1282:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD HL Comma LParen HL expr RParen End
action_1283:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD HL Comma LParen IX RParen End
action_1284:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD HL Comma LParen IX expr RParen End
action_1285:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD HL Comma LParen IY RParen End
action_1286:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD HL Comma LParen IY expr RParen End
action_1287:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD HL Comma expr End
action_1288:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0x2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD IX Comma expr End
action_1289:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xDD2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD IY Comma expr End
action_1290:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xFD2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD L Comma LParen HL Minus RParen End | IOE LD L Comma LParen HLD RParen End | IOE LDD L Comma LParen HL RParen End
action_1291:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD L Comma LParen HL Plus RParen End | IOE LD L Comma LParen HLI RParen End | IOE LDI L Comma LParen HL RParen End
action_1292:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD L Comma LParen HL RParen End
action_1293:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD L Comma LParen IX RParen End
action_1294:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD L Comma LParen IX expr RParen End
action_1295:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD L Comma LParen IY RParen End
action_1296:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD L Comma LParen IY expr RParen End
action_1297:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD SP Comma expr End
action_1298:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xED7B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen BC Minus RParen Comma A End | IOE LDD LParen BC RParen Comma A End
action_1299:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x02)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen BC Plus RParen Comma A End | IOE LDI LParen BC RParen Comma A End
action_1300:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x02)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen BC RParen Comma A End
action_1301:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x02)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen DE Minus RParen Comma A End | IOE LDD LParen DE RParen Comma A End
action_1302:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x12)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen DE Plus RParen Comma A End | IOE LDI LParen DE RParen Comma A End
action_1303:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x12)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen DE RParen Comma A End
action_1304:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x12)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Minus RParen Comma A End | IOE LD LParen HLD RParen Comma A End | IOE LDD LParen HL RParen Comma A End
action_1305:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x77)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Minus RParen Comma B End | IOE LD LParen HLD RParen Comma B End | IOE LDD LParen HL RParen Comma B End
action_1306:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x70)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Minus RParen Comma C End | IOE LD LParen HLD RParen Comma C End | IOE LDD LParen HL RParen Comma C End
action_1307:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x71)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Minus RParen Comma D End | IOE LD LParen HLD RParen Comma D End | IOE LDD LParen HL RParen Comma D End
action_1308:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x72)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Minus RParen Comma E End | IOE LD LParen HLD RParen Comma E End | IOE LDD LParen HL RParen Comma E End
action_1309:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x73)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Minus RParen Comma H End | IOE LD LParen HLD RParen Comma H End | IOE LDD LParen HL RParen Comma H End
action_1310:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x74)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Minus RParen Comma L End | IOE LD LParen HLD RParen Comma L End | IOE LDD LParen HL RParen Comma L End
action_1311:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x75)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Minus RParen Comma expr End | IOE LDD LParen HL RParen Comma expr End
action_1312:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_n(0x36)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Plus RParen Comma A End | IOE LD LParen HLI RParen Comma A End | IOE LDI LParen HL RParen Comma A End
action_1313:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x77)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Plus RParen Comma B End | IOE LD LParen HLI RParen Comma B End | IOE LDI LParen HL RParen Comma B End
action_1314:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x70)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Plus RParen Comma C End | IOE LD LParen HLI RParen Comma C End | IOE LDI LParen HL RParen Comma C End
action_1315:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x71)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Plus RParen Comma D End | IOE LD LParen HLI RParen Comma D End | IOE LDI LParen HL RParen Comma D End
action_1316:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x72)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Plus RParen Comma E End | IOE LD LParen HLI RParen Comma E End | IOE LDI LParen HL RParen Comma E End
action_1317:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x73)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Plus RParen Comma H End | IOE LD LParen HLI RParen Comma H End | IOE LDI LParen HL RParen Comma H End
action_1318:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x74)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Plus RParen Comma L End | IOE LD LParen HLI RParen Comma L End | IOE LDI LParen HL RParen Comma L End
action_1319:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x75)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL Plus RParen Comma expr End | IOE LDI LParen HL RParen Comma expr End
action_1320:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_n(0x36)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL RParen Comma A End
action_1321:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL RParen Comma B End
action_1322:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x70)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL RParen Comma C End
action_1323:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x71)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL RParen Comma D End
action_1324:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL RParen Comma E End
action_1325:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL RParen Comma H End
action_1326:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x74)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL RParen Comma HL End
action_1327:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDF400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL RParen Comma L End
action_1328:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x75)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL RParen Comma expr End
action_1329:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_n(0x36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen HL expr RParen Comma HL End
action_1330:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX RParen Comma A End
action_1331:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD7700)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX RParen Comma B End
action_1332:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD7000)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX RParen Comma C End
action_1333:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD7100)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX RParen Comma D End
action_1334:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD7200)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX RParen Comma E End
action_1335:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD7300)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX RParen Comma H End
action_1336:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD7400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX RParen Comma HL End
action_1337:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xF400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX RParen Comma L End
action_1338:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD7500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX RParen Comma expr End
action_1339:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_n(0xDD3600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX expr RParen Comma A End
action_1340:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX expr RParen Comma B End
action_1341:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD70)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX expr RParen Comma C End
action_1342:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD71)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX expr RParen Comma D End
action_1343:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX expr RParen Comma E End
action_1344:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX expr RParen Comma H End
action_1345:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD74)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX expr RParen Comma HL End
action_1346:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX expr RParen Comma L End
action_1347:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD75)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IX expr RParen Comma expr End
action_1348:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx_n(0xDD36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY RParen Comma A End
action_1349:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD7700)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY RParen Comma B End
action_1350:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD7000)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY RParen Comma C End
action_1351:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD7100)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY RParen Comma D End
action_1352:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD7200)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY RParen Comma E End
action_1353:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD7300)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY RParen Comma H End
action_1354:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD7400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY RParen Comma HL End
action_1355:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDF400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY RParen Comma L End
action_1356:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD7500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY RParen Comma expr End
action_1357:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_n(0xFD3600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY expr RParen Comma A End
action_1358:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY expr RParen Comma B End
action_1359:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD70)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY expr RParen Comma C End
action_1360:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD71)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY expr RParen Comma D End
action_1361:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY expr RParen Comma E End
action_1362:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY expr RParen Comma H End
action_1363:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD74)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY expr RParen Comma HL End
action_1364:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY expr RParen Comma L End
action_1365:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD75)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD LParen IY expr RParen Comma expr End
action_1366:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx_n(0xFD36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD expr Comma A End
action_1367:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0x32)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD expr Comma BC End
action_1368:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xED43)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD expr Comma DE End
action_1369:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xED53)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD expr Comma HL End
action_1370:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0x22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD expr Comma IX End
action_1371:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xDD22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD expr Comma IY End
action_1372:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xFD22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LD expr Comma SP End
action_1373:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xDB)*/;
/*DO_stmt_nn(0xED73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LDD End
action_1374:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xEDA8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LDDR End
action_1375:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xEDB8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LDDSR End
action_1376:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xED98)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LDI End
action_1377:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xEDA0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LDIR End
action_1378:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xEDB0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LDISR End
action_1379:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xED90)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LSDDR End
action_1380:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xEDD8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LSDR End
action_1381:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xEDF8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LSIDR End
action_1382:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xEDD0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE LSIR End
action_1383:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xEDF0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE OR A Comma LParen HL Minus RParen End | IOE OR LParen HL Minus RParen End
action_1384:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE OR A Comma LParen HL Plus RParen End | IOE OR LParen HL Plus RParen End
action_1385:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE OR A Comma LParen HL RParen End | IOE OR LParen HL RParen End
action_1386:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE OR A Comma LParen IX RParen End | IOE OR LParen IX RParen End
action_1387:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE OR A Comma LParen IX expr RParen End | IOE OR LParen IX expr RParen End
action_1388:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE OR A Comma LParen IY RParen End | IOE OR LParen IY RParen End
action_1389:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE OR A Comma LParen IY expr RParen End | IOE OR LParen IY expr RParen End
action_1390:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RES const_expr Comma LParen HL RParen End
action_1391:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB86+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RES const_expr Comma LParen IX RParen End
action_1392:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0086+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RES const_expr Comma LParen IX expr RParen End
action_1393:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB86+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RES const_expr Comma LParen IY RParen End
action_1394:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0086+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RES const_expr Comma LParen IY expr RParen End
action_1395:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB86+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RL LParen HL RParen End
action_1396:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RL LParen IX RParen End
action_1397:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RL LParen IX expr RParen End
action_1398:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RL LParen IY RParen End
action_1399:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RL LParen IY expr RParen End
action_1400:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RLC LParen HL RParen End
action_1401:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RLC LParen IX RParen End
action_1402:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RLC LParen IX expr RParen End
action_1403:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RLC LParen IY RParen End
action_1404:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RLC LParen IY expr RParen End
action_1405:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RR LParen HL RParen End
action_1406:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RR LParen IX RParen End
action_1407:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RR LParen IX expr RParen End
action_1408:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RR LParen IY RParen End
action_1409:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RR LParen IY expr RParen End
action_1410:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RRC LParen HL RParen End
action_1411:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RRC LParen IX RParen End
action_1412:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RRC LParen IX expr RParen End
action_1413:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RRC LParen IY RParen End
action_1414:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE RRC LParen IY expr RParen End
action_1415:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SBC A Comma LParen HL Minus RParen End | IOE SBC LParen HL Minus RParen End
action_1416:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SBC A Comma LParen HL Plus RParen End | IOE SBC LParen HL Plus RParen End
action_1417:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SBC A Comma LParen HL RParen End | IOE SBC LParen HL RParen End
action_1418:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SBC A Comma LParen IX RParen End | IOE SBC LParen IX RParen End
action_1419:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SBC A Comma LParen IX expr RParen End | IOE SBC LParen IX expr RParen End
action_1420:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SBC A Comma LParen IY RParen End | IOE SBC LParen IY RParen End
action_1421:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SBC A Comma LParen IY expr RParen End | IOE SBC LParen IY expr RParen End
action_1422:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SET const_expr Comma LParen HL RParen End
action_1423:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SET const_expr Comma LParen IX RParen End
action_1424:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SET const_expr Comma LParen IX expr RParen End
action_1425:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SET const_expr Comma LParen IY RParen End
action_1426:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SET const_expr Comma LParen IY expr RParen End
action_1427:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xDB)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SLA LParen HL RParen End
action_1428:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SLA LParen IX RParen End
action_1429:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SLA LParen IX expr RParen End
action_1430:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SLA LParen IY RParen End
action_1431:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SLA LParen IY expr RParen End
action_1432:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRA LParen HL RParen End
action_1433:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRA LParen IX RParen End
action_1434:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRA LParen IX expr RParen End
action_1435:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRA LParen IY RParen End
action_1436:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRA LParen IY expr RParen End
action_1437:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRL LParen HL RParen End
action_1438:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRL LParen IX RParen End
action_1439:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRL LParen IX expr RParen End
action_1440:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRL LParen IY RParen End
action_1441:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SRL LParen IY expr RParen End
action_1442:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SUB A Comma LParen HL Minus RParen End | IOE SUB LParen HL Minus RParen End
action_1443:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SUB A Comma LParen HL Plus RParen End | IOE SUB LParen HL Plus RParen End
action_1444:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SUB A Comma LParen HL RParen End | IOE SUB LParen HL RParen End
action_1445:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0x96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SUB A Comma LParen IX RParen End | IOE SUB LParen IX RParen End
action_1446:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SUB A Comma LParen IX expr RParen End | IOE SUB LParen IX expr RParen End
action_1447:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SUB A Comma LParen IY RParen End | IOE SUB LParen IY RParen End
action_1448:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE SUB A Comma LParen IY expr RParen End | IOE SUB LParen IY expr RParen End
action_1449:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE XOR A Comma LParen HL Minus RParen End | IOE XOR LParen HL Minus RParen End
action_1450:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE XOR A Comma LParen HL Plus RParen End | IOE XOR LParen HL Plus RParen End
action_1451:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE XOR A Comma LParen HL RParen End | IOE XOR LParen HL RParen End
action_1452:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE XOR A Comma LParen IX RParen End | IOE XOR LParen IX RParen End
action_1453:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xDDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE XOR A Comma LParen IX expr RParen End | IOE XOR LParen IX expr RParen End
action_1454:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xDDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE XOR A Comma LParen IY RParen End | IOE XOR LParen IY RParen End
action_1455:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt(0xFDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOE XOR A Comma LParen IY expr RParen End | IOE XOR LParen IY expr RParen End
action_1456:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDB)*/;
/*DO_stmt_idx(0xFDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A Comma LParen HL Minus RParen End | IOI ADC LParen HL Minus RParen End
action_1457:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A Comma LParen HL Plus RParen End | IOI ADC LParen HL Plus RParen End
action_1458:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A Comma LParen HL RParen End | IOI ADC LParen HL RParen End
action_1459:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A Comma LParen IX RParen End | IOI ADC LParen IX RParen End
action_1460:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A Comma LParen IX expr RParen End | IOI ADC LParen IX expr RParen End
action_1461:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A Comma LParen IY RParen End | IOI ADC LParen IY RParen End
action_1462:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A Comma LParen IY expr RParen End | IOI ADC LParen IY expr RParen End
action_1463:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A1 Comma LParen HL Minus RParen End | IOI ALTD ADC A Comma LParen HL Minus RParen End | IOI ALTD ADC LParen HL Minus RParen End
action_1464:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A1 Comma LParen HL Plus RParen End | IOI ALTD ADC A Comma LParen HL Plus RParen End | IOI ALTD ADC LParen HL Plus RParen End
action_1465:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A1 Comma LParen HL RParen End | IOI ALTD ADC A Comma LParen HL RParen End | IOI ALTD ADC LParen HL RParen End
action_1466:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A1 Comma LParen IX RParen End | IOI ALTD ADC A Comma LParen IX RParen End | IOI ALTD ADC LParen IX RParen End
action_1467:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A1 Comma LParen IX expr RParen End | IOI ALTD ADC A Comma LParen IX expr RParen End | IOI ALTD ADC LParen IX expr RParen End
action_1468:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A1 Comma LParen IY RParen End | IOI ALTD ADC A Comma LParen IY RParen End | IOI ALTD ADC LParen IY RParen End
action_1469:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD8E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADC A1 Comma LParen IY expr RParen End | IOI ALTD ADC A Comma LParen IY expr RParen End | IOI ALTD ADC LParen IY expr RParen End
action_1470:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD8E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A Comma LParen HL Minus RParen End | IOI ADD LParen HL Minus RParen End
action_1471:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A Comma LParen HL Plus RParen End | IOI ADD LParen HL Plus RParen End
action_1472:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A Comma LParen HL RParen End | IOI ADD LParen HL RParen End
action_1473:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A Comma LParen IX RParen End | IOI ADD LParen IX RParen End
action_1474:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A Comma LParen IX expr RParen End | IOI ADD LParen IX expr RParen End
action_1475:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A Comma LParen IY RParen End | IOI ADD LParen IY RParen End
action_1476:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A Comma LParen IY expr RParen End | IOI ADD LParen IY expr RParen End
action_1477:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A1 Comma LParen HL Minus RParen End | IOI ALTD ADD A Comma LParen HL Minus RParen End | IOI ALTD ADD LParen HL Minus RParen End
action_1478:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A1 Comma LParen HL Plus RParen End | IOI ALTD ADD A Comma LParen HL Plus RParen End | IOI ALTD ADD LParen HL Plus RParen End
action_1479:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x86)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A1 Comma LParen HL RParen End | IOI ALTD ADD A Comma LParen HL RParen End | IOI ALTD ADD LParen HL RParen End
action_1480:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A1 Comma LParen IX RParen End | IOI ALTD ADD A Comma LParen IX RParen End | IOI ALTD ADD LParen IX RParen End
action_1481:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A1 Comma LParen IX expr RParen End | IOI ALTD ADD A Comma LParen IX expr RParen End | IOI ALTD ADD LParen IX expr RParen End
action_1482:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A1 Comma LParen IY RParen End | IOI ALTD ADD A Comma LParen IY RParen End | IOI ALTD ADD LParen IY RParen End
action_1483:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD8600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ADD A1 Comma LParen IY expr RParen End | IOI ALTD ADD A Comma LParen IY expr RParen End | IOI ALTD ADD LParen IY expr RParen End
action_1484:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD86)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD AND A Comma LParen HL Minus RParen End | IOI ALTD AND LParen HL Minus RParen End | IOI AND A1 Comma LParen HL Minus RParen End
action_1485:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD AND A Comma LParen HL Plus RParen End | IOI ALTD AND LParen HL Plus RParen End | IOI AND A1 Comma LParen HL Plus RParen End
action_1486:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD AND A Comma LParen HL RParen End | IOI ALTD AND LParen HL RParen End | IOI AND A1 Comma LParen HL RParen End
action_1487:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD AND A Comma LParen IX RParen End | IOI ALTD AND LParen IX RParen End | IOI AND A1 Comma LParen IX RParen End
action_1488:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD AND A Comma LParen IX expr RParen End | IOI ALTD AND LParen IX expr RParen End | IOI AND A1 Comma LParen IX expr RParen End
action_1489:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD AND A Comma LParen IY RParen End | IOI ALTD AND LParen IY RParen End | IOI AND A1 Comma LParen IY RParen End
action_1490:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD AND A Comma LParen IY expr RParen End | IOI ALTD AND LParen IY expr RParen End | IOI AND A1 Comma LParen IY expr RParen End
action_1491:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD BIT const_expr Comma LParen HL RParen End
action_1492:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD BIT const_expr Comma LParen IX RParen End
action_1493:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD BIT const_expr Comma LParen IX expr RParen End
action_1494:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD BIT const_expr Comma LParen IY RParen End
action_1495:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD BIT const_expr Comma LParen IY expr RParen End
action_1496:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD CP A Comma LParen HL Minus RParen End | IOI ALTD CP LParen HL Minus RParen End
action_1497:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD CP A Comma LParen HL Plus RParen End | IOI ALTD CP LParen HL Plus RParen End
action_1498:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD CP A Comma LParen HL RParen End | IOI ALTD CP LParen HL RParen End
action_1499:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD CP A Comma LParen IX RParen End | IOI ALTD CP LParen IX RParen End
action_1500:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD CP A Comma LParen IX expr RParen End | IOI ALTD CP LParen IX expr RParen End
action_1501:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD CP A Comma LParen IY RParen End | IOI ALTD CP LParen IY RParen End
action_1502:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD CP A Comma LParen IY expr RParen End | IOI ALTD CP LParen IY expr RParen End
action_1503:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD DEC LParen HL Minus RParen End
action_1504:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD DEC LParen HL Plus RParen End
action_1505:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD DEC LParen HL RParen End
action_1506:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD DEC LParen IX RParen End
action_1507:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD DEC LParen IX expr RParen End
action_1508:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD DEC LParen IY RParen End
action_1509:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD DEC LParen IY expr RParen End
action_1510:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD INC LParen HL Minus RParen End
action_1511:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD INC LParen HL Plus RParen End
action_1512:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD INC LParen HL RParen End
action_1513:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD INC LParen IX RParen End
action_1514:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD INC LParen IX expr RParen End
action_1515:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD INC LParen IY RParen End
action_1516:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD INC LParen IY expr RParen End
action_1517:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen BC Minus RParen End | IOI LD A1 Comma LParen BC Minus RParen End
action_1518:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen BC Plus RParen End | IOI LD A1 Comma LParen BC Plus RParen End
action_1519:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen BC RParen End | IOI LD A1 Comma LParen BC RParen End
action_1520:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen DE Minus RParen End | IOI LD A1 Comma LParen DE Minus RParen End
action_1521:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen DE Plus RParen End | IOI LD A1 Comma LParen DE Plus RParen End
action_1522:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen DE RParen End | IOI LD A1 Comma LParen DE RParen End
action_1523:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen HL Minus RParen End | IOI ALTD LD A Comma LParen HLD RParen End | IOI LD A1 Comma LParen HL Minus RParen End | IOI LD A1 Comma LParen HLD RParen End
action_1524:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen HL Plus RParen End | IOI ALTD LD A Comma LParen HLI RParen End | IOI LD A1 Comma LParen HL Plus RParen End | IOI LD A1 Comma LParen HLI RParen End
action_1525:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen HL RParen End | IOI LD A1 Comma LParen HL RParen End
action_1526:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen IX RParen End | IOI LD A1 Comma LParen IX RParen End
action_1527:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen IX expr RParen End | IOI LD A1 Comma LParen IX expr RParen End
action_1528:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen IY RParen End | IOI LD A1 Comma LParen IY RParen End
action_1529:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma LParen IY expr RParen End | IOI LD A1 Comma LParen IY expr RParen End
action_1530:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD A Comma expr End | IOI LD A1 Comma expr End
action_1531:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_nn(0x3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD B Comma LParen HL Minus RParen End | IOI ALTD LD B Comma LParen HLD RParen End | IOI LD B1 Comma LParen HL Minus RParen End | IOI LD B1 Comma LParen HLD RParen End
action_1532:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD B Comma LParen HL Plus RParen End | IOI ALTD LD B Comma LParen HLI RParen End | IOI LD B1 Comma LParen HL Plus RParen End | IOI LD B1 Comma LParen HLI RParen End
action_1533:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD B Comma LParen HL RParen End | IOI LD B1 Comma LParen HL RParen End
action_1534:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD B Comma LParen IX RParen End | IOI LD B1 Comma LParen IX RParen End
action_1535:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD B Comma LParen IX expr RParen End | IOI LD B1 Comma LParen IX expr RParen End
action_1536:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD B Comma LParen IY RParen End | IOI LD B1 Comma LParen IY RParen End
action_1537:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD B Comma LParen IY expr RParen End | IOI LD B1 Comma LParen IY expr RParen End
action_1538:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD BC Comma expr End | IOI LD BC1 Comma expr End
action_1539:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_nn(0xED4B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD C Comma LParen HL Minus RParen End | IOI ALTD LD C Comma LParen HLD RParen End | IOI LD C1 Comma LParen HL Minus RParen End | IOI LD C1 Comma LParen HLD RParen End
action_1540:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD C Comma LParen HL Plus RParen End | IOI ALTD LD C Comma LParen HLI RParen End | IOI LD C1 Comma LParen HL Plus RParen End | IOI LD C1 Comma LParen HLI RParen End
action_1541:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD C Comma LParen HL RParen End | IOI LD C1 Comma LParen HL RParen End
action_1542:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD C Comma LParen IX RParen End | IOI LD C1 Comma LParen IX RParen End
action_1543:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD C Comma LParen IX expr RParen End | IOI LD C1 Comma LParen IX expr RParen End
action_1544:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD C Comma LParen IY RParen End | IOI LD C1 Comma LParen IY RParen End
action_1545:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD C Comma LParen IY expr RParen End | IOI LD C1 Comma LParen IY expr RParen End
action_1546:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD D Comma LParen HL Minus RParen End | IOI ALTD LD D Comma LParen HLD RParen End | IOI LD D1 Comma LParen HL Minus RParen End | IOI LD D1 Comma LParen HLD RParen End
action_1547:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD D Comma LParen HL Plus RParen End | IOI ALTD LD D Comma LParen HLI RParen End | IOI LD D1 Comma LParen HL Plus RParen End | IOI LD D1 Comma LParen HLI RParen End
action_1548:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD D Comma LParen HL RParen End | IOI LD D1 Comma LParen HL RParen End
action_1549:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD D Comma LParen IX RParen End | IOI LD D1 Comma LParen IX RParen End
action_1550:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD D Comma LParen IX expr RParen End | IOI LD D1 Comma LParen IX expr RParen End
action_1551:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD D Comma LParen IY RParen End | IOI LD D1 Comma LParen IY RParen End
action_1552:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD D Comma LParen IY expr RParen End | IOI LD D1 Comma LParen IY expr RParen End
action_1553:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD DE Comma expr End | IOI LD DE1 Comma expr End
action_1554:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_nn(0xED5B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD E Comma LParen HL Minus RParen End | IOI ALTD LD E Comma LParen HLD RParen End | IOI LD E1 Comma LParen HL Minus RParen End | IOI LD E1 Comma LParen HLD RParen End
action_1555:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD E Comma LParen HL Plus RParen End | IOI ALTD LD E Comma LParen HLI RParen End | IOI LD E1 Comma LParen HL Plus RParen End | IOI LD E1 Comma LParen HLI RParen End
action_1556:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD E Comma LParen HL RParen End | IOI LD E1 Comma LParen HL RParen End
action_1557:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD E Comma LParen IX RParen End | IOI LD E1 Comma LParen IX RParen End
action_1558:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD E Comma LParen IX expr RParen End | IOI LD E1 Comma LParen IX expr RParen End
action_1559:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD E Comma LParen IY RParen End | IOI LD E1 Comma LParen IY RParen End
action_1560:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD E Comma LParen IY expr RParen End | IOI LD E1 Comma LParen IY expr RParen End
action_1561:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD H Comma LParen HL Minus RParen End | IOI ALTD LD H Comma LParen HLD RParen End | IOI LD H1 Comma LParen HL Minus RParen End | IOI LD H1 Comma LParen HLD RParen End
action_1562:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD H Comma LParen HL Plus RParen End | IOI ALTD LD H Comma LParen HLI RParen End | IOI LD H1 Comma LParen HL Plus RParen End | IOI LD H1 Comma LParen HLI RParen End
action_1563:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD H Comma LParen HL RParen End | IOI LD H1 Comma LParen HL RParen End
action_1564:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD H Comma LParen IX RParen End | IOI LD H1 Comma LParen IX RParen End
action_1565:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD H Comma LParen IX expr RParen End | IOI LD H1 Comma LParen IX expr RParen End
action_1566:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD H Comma LParen IY RParen End | IOI LD H1 Comma LParen IY RParen End
action_1567:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD H Comma LParen IY expr RParen End | IOI LD H1 Comma LParen IY expr RParen End
action_1568:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD HL Comma LParen HL RParen End | IOI LD HL1 Comma LParen HL RParen End
action_1569:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD HL Comma LParen HL expr RParen End | IOI LD HL1 Comma LParen HL expr RParen End
action_1570:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD HL Comma LParen IX RParen End | IOI LD HL1 Comma LParen IX RParen End
action_1571:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD HL Comma LParen IX expr RParen End | IOI LD HL1 Comma LParen IX expr RParen End
action_1572:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD HL Comma LParen IY RParen End | IOI LD HL1 Comma LParen IY RParen End
action_1573:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD HL Comma LParen IY expr RParen End | IOI LD HL1 Comma LParen IY expr RParen End
action_1574:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD HL Comma expr End | IOI LD HL1 Comma expr End
action_1575:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_nn(0x2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD L Comma LParen HL Minus RParen End | IOI ALTD LD L Comma LParen HLD RParen End | IOI LD L1 Comma LParen HL Minus RParen End | IOI LD L1 Comma LParen HLD RParen End
action_1576:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD L Comma LParen HL Plus RParen End | IOI ALTD LD L Comma LParen HLI RParen End | IOI LD L1 Comma LParen HL Plus RParen End | IOI LD L1 Comma LParen HLI RParen End
action_1577:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD L Comma LParen HL RParen End | IOI LD L1 Comma LParen HL RParen End
action_1578:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD L Comma LParen IX RParen End | IOI LD L1 Comma LParen IX RParen End
action_1579:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD L Comma LParen IX expr RParen End | IOI LD L1 Comma LParen IX expr RParen End
action_1580:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD L Comma LParen IY RParen End | IOI LD L1 Comma LParen IY RParen End
action_1581:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD LD L Comma LParen IY expr RParen End | IOI LD L1 Comma LParen IY expr RParen End
action_1582:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD OR A Comma LParen HL Minus RParen End | IOI ALTD OR LParen HL Minus RParen End | IOI OR A1 Comma LParen HL Minus RParen End
action_1583:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD OR A Comma LParen HL Plus RParen End | IOI ALTD OR LParen HL Plus RParen End | IOI OR A1 Comma LParen HL Plus RParen End
action_1584:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD OR A Comma LParen HL RParen End | IOI ALTD OR LParen HL RParen End | IOI OR A1 Comma LParen HL RParen End
action_1585:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD OR A Comma LParen IX RParen End | IOI ALTD OR LParen IX RParen End | IOI OR A1 Comma LParen IX RParen End
action_1586:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD OR A Comma LParen IX expr RParen End | IOI ALTD OR LParen IX expr RParen End | IOI OR A1 Comma LParen IX expr RParen End
action_1587:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD OR A Comma LParen IY RParen End | IOI ALTD OR LParen IY RParen End | IOI OR A1 Comma LParen IY RParen End
action_1588:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD OR A Comma LParen IY expr RParen End | IOI ALTD OR LParen IY expr RParen End | IOI OR A1 Comma LParen IY expr RParen End
action_1589:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RL LParen HL RParen End
action_1590:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RL LParen IX RParen End
action_1591:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RL LParen IX expr RParen End
action_1592:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RL LParen IY RParen End
action_1593:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RL LParen IY expr RParen End
action_1594:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RLC LParen HL RParen End
action_1595:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RLC LParen IX RParen End
action_1596:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RLC LParen IX expr RParen End
action_1597:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RLC LParen IY RParen End
action_1598:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RLC LParen IY expr RParen End
action_1599:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RR LParen HL RParen End
action_1600:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RR LParen IX RParen End
action_1601:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RR LParen IX expr RParen End
action_1602:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RR LParen IY RParen End
action_1603:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RR LParen IY expr RParen End
action_1604:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RRC LParen HL RParen End
action_1605:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RRC LParen IX RParen End
action_1606:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RRC LParen IX expr RParen End
action_1607:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RRC LParen IY RParen End
action_1608:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD RRC LParen IY expr RParen End
action_1609:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SBC A Comma LParen HL Minus RParen End | IOI ALTD SBC LParen HL Minus RParen End | IOI SBC A1 Comma LParen HL Minus RParen End
action_1610:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SBC A Comma LParen HL Plus RParen End | IOI ALTD SBC LParen HL Plus RParen End | IOI SBC A1 Comma LParen HL Plus RParen End
action_1611:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SBC A Comma LParen HL RParen End | IOI ALTD SBC LParen HL RParen End | IOI SBC A1 Comma LParen HL RParen End
action_1612:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SBC A Comma LParen IX RParen End | IOI ALTD SBC LParen IX RParen End | IOI SBC A1 Comma LParen IX RParen End
action_1613:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SBC A Comma LParen IX expr RParen End | IOI ALTD SBC LParen IX expr RParen End | IOI SBC A1 Comma LParen IX expr RParen End
action_1614:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SBC A Comma LParen IY RParen End | IOI ALTD SBC LParen IY RParen End | IOI SBC A1 Comma LParen IY RParen End
action_1615:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SBC A Comma LParen IY expr RParen End | IOI ALTD SBC LParen IY expr RParen End | IOI SBC A1 Comma LParen IY expr RParen End
action_1616:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SLA LParen HL RParen End
action_1617:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SLA LParen IX RParen End
action_1618:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SLA LParen IX expr RParen End
action_1619:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SLA LParen IY RParen End
action_1620:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SLA LParen IY expr RParen End
action_1621:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRA LParen HL RParen End
action_1622:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRA LParen IX RParen End
action_1623:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRA LParen IX expr RParen End
action_1624:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRA LParen IY RParen End
action_1625:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRA LParen IY expr RParen End
action_1626:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRL LParen HL RParen End
action_1627:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRL LParen IX RParen End
action_1628:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRL LParen IX expr RParen End
action_1629:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRL LParen IY RParen End
action_1630:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SRL LParen IY expr RParen End
action_1631:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SUB A Comma LParen HL Minus RParen End | IOI ALTD SUB LParen HL Minus RParen End | IOI SUB A1 Comma LParen HL Minus RParen End
action_1632:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SUB A Comma LParen HL Plus RParen End | IOI ALTD SUB LParen HL Plus RParen End | IOI SUB A1 Comma LParen HL Plus RParen End
action_1633:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SUB A Comma LParen HL RParen End | IOI ALTD SUB LParen HL RParen End | IOI SUB A1 Comma LParen HL RParen End
action_1634:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0x96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SUB A Comma LParen IX RParen End | IOI ALTD SUB LParen IX RParen End | IOI SUB A1 Comma LParen IX RParen End
action_1635:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SUB A Comma LParen IX expr RParen End | IOI ALTD SUB LParen IX expr RParen End | IOI SUB A1 Comma LParen IX expr RParen End
action_1636:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SUB A Comma LParen IY RParen End | IOI ALTD SUB LParen IY RParen End | IOI SUB A1 Comma LParen IY RParen End
action_1637:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD SUB A Comma LParen IY expr RParen End | IOI ALTD SUB LParen IY expr RParen End | IOI SUB A1 Comma LParen IY expr RParen End
action_1638:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD XOR A Comma LParen HL Minus RParen End | IOI ALTD XOR LParen HL Minus RParen End | IOI XOR A1 Comma LParen HL Minus RParen End
action_1639:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD XOR A Comma LParen HL Plus RParen End | IOI ALTD XOR LParen HL Plus RParen End | IOI XOR A1 Comma LParen HL Plus RParen End
action_1640:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD XOR A Comma LParen HL RParen End | IOI ALTD XOR LParen HL RParen End | IOI XOR A1 Comma LParen HL RParen End
action_1641:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD XOR A Comma LParen IX RParen End | IOI ALTD XOR LParen IX RParen End | IOI XOR A1 Comma LParen IX RParen End
action_1642:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xDDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD XOR A Comma LParen IX expr RParen End | IOI ALTD XOR LParen IX expr RParen End | IOI XOR A1 Comma LParen IX expr RParen End
action_1643:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xDDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD XOR A Comma LParen IY RParen End | IOI ALTD XOR LParen IY RParen End | IOI XOR A1 Comma LParen IY RParen End
action_1644:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt(0xFDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI ALTD XOR A Comma LParen IY expr RParen End | IOI ALTD XOR LParen IY expr RParen End | IOI XOR A1 Comma LParen IY expr RParen End
action_1645:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x76)*/;
/*DO_stmt_idx(0xFDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI AND A Comma LParen HL Minus RParen End | IOI AND LParen HL Minus RParen End
action_1646:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI AND A Comma LParen HL Plus RParen End | IOI AND LParen HL Plus RParen End
action_1647:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xA6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI AND A Comma LParen HL RParen End | IOI AND LParen HL RParen End
action_1648:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI AND A Comma LParen IX RParen End | IOI AND LParen IX RParen End
action_1649:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI AND A Comma LParen IX expr RParen End | IOI AND LParen IX expr RParen End
action_1650:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI AND A Comma LParen IY RParen End | IOI AND LParen IY RParen End
action_1651:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDA600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI AND A Comma LParen IY expr RParen End | IOI AND LParen IY expr RParen End
action_1652:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDA6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI BIT const_expr Comma LParen HL RParen End
action_1653:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI BIT const_expr Comma LParen IX RParen End
action_1654:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI BIT const_expr Comma LParen IX expr RParen End
action_1655:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI BIT const_expr Comma LParen IY RParen End
action_1656:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0046+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI BIT const_expr Comma LParen IY expr RParen End
action_1657:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB46+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI CMP A Comma LParen HL Minus RParen End | IOI CMP LParen HL Minus RParen End | IOI CP A Comma LParen HL Minus RParen End | IOI CP LParen HL Minus RParen End
action_1658:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI CMP A Comma LParen HL Plus RParen End | IOI CMP LParen HL Plus RParen End | IOI CP A Comma LParen HL Plus RParen End | IOI CP LParen HL Plus RParen End
action_1659:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xBE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI CMP A Comma LParen HL RParen End | IOI CMP LParen HL RParen End | IOI CP A Comma LParen HL RParen End | IOI CP LParen HL RParen End
action_1660:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI CMP A Comma LParen IX RParen End | IOI CMP LParen IX RParen End | IOI CP A Comma LParen IX RParen End | IOI CP LParen IX RParen End
action_1661:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI CMP A Comma LParen IX expr RParen End | IOI CMP LParen IX expr RParen End | IOI CP A Comma LParen IX expr RParen End | IOI CP LParen IX expr RParen End
action_1662:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI CMP A Comma LParen IY RParen End | IOI CMP LParen IY RParen End | IOI CP A Comma LParen IY RParen End | IOI CP LParen IY RParen End
action_1663:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDBE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI CMP A Comma LParen IY expr RParen End | IOI CMP LParen IY expr RParen End | IOI CP A Comma LParen IY expr RParen End | IOI CP LParen IY expr RParen End
action_1664:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDBE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI DEC LParen HL Minus RParen End
action_1665:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI DEC LParen HL Plus RParen End
action_1666:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x35)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI DEC LParen HL RParen End
action_1667:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI DEC LParen IX RParen End
action_1668:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI DEC LParen IX expr RParen End
action_1669:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI DEC LParen IY RParen End
action_1670:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD3500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI DEC LParen IY expr RParen End
action_1671:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI INC LParen HL Minus RParen End
action_1672:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI INC LParen HL Plus RParen End
action_1673:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x34)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI INC LParen HL RParen End
action_1674:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI INC LParen IX RParen End
action_1675:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI INC LParen IX expr RParen End
action_1676:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI INC LParen IY RParen End
action_1677:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD3400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI INC LParen IY expr RParen End
action_1678:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen BC Minus RParen End | IOI LDD A Comma LParen BC RParen End
action_1679:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen BC Plus RParen End | IOI LDI A Comma LParen BC RParen End
action_1680:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen BC RParen End
action_1681:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen DE Minus RParen End | IOI LDD A Comma LParen DE RParen End
action_1682:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen DE Plus RParen End | IOI LDI A Comma LParen DE RParen End
action_1683:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen DE RParen End
action_1684:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen HL Minus RParen End | IOI LD A Comma LParen HLD RParen End | IOI LDD A Comma LParen HL RParen End
action_1685:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen HL Plus RParen End | IOI LD A Comma LParen HLI RParen End | IOI LDI A Comma LParen HL RParen End
action_1686:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen HL RParen End
action_1687:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen IX RParen End
action_1688:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen IX expr RParen End
action_1689:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen IY RParen End
action_1690:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma LParen IY expr RParen End
action_1691:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD A Comma expr End
action_1692:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0x3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD B Comma LParen HL Minus RParen End | IOI LD B Comma LParen HLD RParen End | IOI LDD B Comma LParen HL RParen End
action_1693:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD B Comma LParen HL Plus RParen End | IOI LD B Comma LParen HLI RParen End | IOI LDI B Comma LParen HL RParen End
action_1694:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD B Comma LParen HL RParen End
action_1695:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD B Comma LParen IX RParen End
action_1696:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD B Comma LParen IX expr RParen End
action_1697:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD B Comma LParen IY RParen End
action_1698:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD B Comma LParen IY expr RParen End
action_1699:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD BC Comma expr End
action_1700:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xED4B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD C Comma LParen HL Minus RParen End | IOI LD C Comma LParen HLD RParen End | IOI LDD C Comma LParen HL RParen End
action_1701:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD C Comma LParen HL Plus RParen End | IOI LD C Comma LParen HLI RParen End | IOI LDI C Comma LParen HL RParen End
action_1702:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD C Comma LParen HL RParen End
action_1703:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD C Comma LParen IX RParen End
action_1704:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD C Comma LParen IX expr RParen End
action_1705:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD C Comma LParen IY RParen End
action_1706:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD C Comma LParen IY expr RParen End
action_1707:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD D Comma LParen HL Minus RParen End | IOI LD D Comma LParen HLD RParen End | IOI LDD D Comma LParen HL RParen End
action_1708:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD D Comma LParen HL Plus RParen End | IOI LD D Comma LParen HLI RParen End | IOI LDI D Comma LParen HL RParen End
action_1709:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD D Comma LParen HL RParen End
action_1710:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD D Comma LParen IX RParen End
action_1711:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD D Comma LParen IX expr RParen End
action_1712:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD D Comma LParen IY RParen End
action_1713:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD D Comma LParen IY expr RParen End
action_1714:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD DE Comma expr End
action_1715:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xED5B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD E Comma LParen HL Minus RParen End | IOI LD E Comma LParen HLD RParen End | IOI LDD E Comma LParen HL RParen End
action_1716:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD E Comma LParen HL Plus RParen End | IOI LD E Comma LParen HLI RParen End | IOI LDI E Comma LParen HL RParen End
action_1717:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD E Comma LParen HL RParen End
action_1718:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD E Comma LParen IX RParen End
action_1719:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD E Comma LParen IX expr RParen End
action_1720:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD E Comma LParen IY RParen End
action_1721:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD E Comma LParen IY expr RParen End
action_1722:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD H Comma LParen HL Minus RParen End | IOI LD H Comma LParen HLD RParen End | IOI LDD H Comma LParen HL RParen End
action_1723:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD H Comma LParen HL Plus RParen End | IOI LD H Comma LParen HLI RParen End | IOI LDI H Comma LParen HL RParen End
action_1724:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD H Comma LParen HL RParen End
action_1725:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD H Comma LParen IX RParen End
action_1726:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD H Comma LParen IX expr RParen End
action_1727:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD H Comma LParen IY RParen End
action_1728:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD H Comma LParen IY expr RParen End
action_1729:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD HL Comma LParen HL RParen End
action_1730:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD HL Comma LParen HL expr RParen End
action_1731:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD HL Comma LParen IX RParen End
action_1732:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD HL Comma LParen IX expr RParen End
action_1733:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD HL Comma LParen IY RParen End
action_1734:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD HL Comma LParen IY expr RParen End
action_1735:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD HL Comma expr End
action_1736:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0x2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD IX Comma expr End
action_1737:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xDD2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD IY Comma expr End
action_1738:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xFD2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD L Comma LParen HL Minus RParen End | IOI LD L Comma LParen HLD RParen End | IOI LDD L Comma LParen HL RParen End
action_1739:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD L Comma LParen HL Plus RParen End | IOI LD L Comma LParen HLI RParen End | IOI LDI L Comma LParen HL RParen End
action_1740:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD L Comma LParen HL RParen End
action_1741:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD L Comma LParen IX RParen End
action_1742:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD L Comma LParen IX expr RParen End
action_1743:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD L Comma LParen IY RParen End
action_1744:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD L Comma LParen IY expr RParen End
action_1745:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD SP Comma expr End
action_1746:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xED7B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen BC Minus RParen Comma A End | IOI LDD LParen BC RParen Comma A End
action_1747:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x02)*/;
/*DO_stmt(0x0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen BC Plus RParen Comma A End | IOI LDI LParen BC RParen Comma A End
action_1748:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x02)*/;
/*DO_stmt(0x03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen BC RParen Comma A End
action_1749:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x02)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen DE Minus RParen Comma A End | IOI LDD LParen DE RParen Comma A End
action_1750:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x12)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen DE Plus RParen Comma A End | IOI LDI LParen DE RParen Comma A End
action_1751:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x12)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen DE RParen Comma A End
action_1752:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x12)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Minus RParen Comma A End | IOI LD LParen HLD RParen Comma A End | IOI LDD LParen HL RParen Comma A End
action_1753:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x77)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Minus RParen Comma B End | IOI LD LParen HLD RParen Comma B End | IOI LDD LParen HL RParen Comma B End
action_1754:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x70)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Minus RParen Comma C End | IOI LD LParen HLD RParen Comma C End | IOI LDD LParen HL RParen Comma C End
action_1755:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x71)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Minus RParen Comma D End | IOI LD LParen HLD RParen Comma D End | IOI LDD LParen HL RParen Comma D End
action_1756:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x72)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Minus RParen Comma E End | IOI LD LParen HLD RParen Comma E End | IOI LDD LParen HL RParen Comma E End
action_1757:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x73)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Minus RParen Comma H End | IOI LD LParen HLD RParen Comma H End | IOI LDD LParen HL RParen Comma H End
action_1758:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x74)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Minus RParen Comma L End | IOI LD LParen HLD RParen Comma L End | IOI LDD LParen HL RParen Comma L End
action_1759:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x75)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Minus RParen Comma expr End | IOI LDD LParen HL RParen Comma expr End
action_1760:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_n(0x36)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Plus RParen Comma A End | IOI LD LParen HLI RParen Comma A End | IOI LDI LParen HL RParen Comma A End
action_1761:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x77)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Plus RParen Comma B End | IOI LD LParen HLI RParen Comma B End | IOI LDI LParen HL RParen Comma B End
action_1762:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x70)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Plus RParen Comma C End | IOI LD LParen HLI RParen Comma C End | IOI LDI LParen HL RParen Comma C End
action_1763:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x71)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Plus RParen Comma D End | IOI LD LParen HLI RParen Comma D End | IOI LDI LParen HL RParen Comma D End
action_1764:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x72)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Plus RParen Comma E End | IOI LD LParen HLI RParen Comma E End | IOI LDI LParen HL RParen Comma E End
action_1765:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x73)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Plus RParen Comma H End | IOI LD LParen HLI RParen Comma H End | IOI LDI LParen HL RParen Comma H End
action_1766:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x74)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Plus RParen Comma L End | IOI LD LParen HLI RParen Comma L End | IOI LDI LParen HL RParen Comma L End
action_1767:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x75)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL Plus RParen Comma expr End | IOI LDI LParen HL RParen Comma expr End
action_1768:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_n(0x36)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL RParen Comma A End
action_1769:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL RParen Comma B End
action_1770:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x70)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL RParen Comma C End
action_1771:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x71)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL RParen Comma D End
action_1772:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL RParen Comma E End
action_1773:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL RParen Comma H End
action_1774:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x74)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL RParen Comma HL End
action_1775:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDF400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL RParen Comma L End
action_1776:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x75)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL RParen Comma expr End
action_1777:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_n(0x36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen HL expr RParen Comma HL End
action_1778:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX RParen Comma A End
action_1779:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD7700)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX RParen Comma B End
action_1780:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD7000)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX RParen Comma C End
action_1781:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD7100)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX RParen Comma D End
action_1782:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD7200)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX RParen Comma E End
action_1783:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD7300)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX RParen Comma H End
action_1784:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD7400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX RParen Comma HL End
action_1785:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xF400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX RParen Comma L End
action_1786:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD7500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX RParen Comma expr End
action_1787:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_n(0xDD3600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX expr RParen Comma A End
action_1788:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX expr RParen Comma B End
action_1789:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD70)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX expr RParen Comma C End
action_1790:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD71)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX expr RParen Comma D End
action_1791:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX expr RParen Comma E End
action_1792:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX expr RParen Comma H End
action_1793:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD74)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX expr RParen Comma HL End
action_1794:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX expr RParen Comma L End
action_1795:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD75)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IX expr RParen Comma expr End
action_1796:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx_n(0xDD36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY RParen Comma A End
action_1797:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD7700)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY RParen Comma B End
action_1798:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD7000)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY RParen Comma C End
action_1799:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD7100)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY RParen Comma D End
action_1800:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD7200)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY RParen Comma E End
action_1801:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD7300)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY RParen Comma H End
action_1802:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD7400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY RParen Comma HL End
action_1803:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDF400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY RParen Comma L End
action_1804:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD7500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY RParen Comma expr End
action_1805:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_n(0xFD3600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY expr RParen Comma A End
action_1806:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY expr RParen Comma B End
action_1807:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD70)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY expr RParen Comma C End
action_1808:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD71)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY expr RParen Comma D End
action_1809:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY expr RParen Comma E End
action_1810:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY expr RParen Comma H End
action_1811:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD74)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY expr RParen Comma HL End
action_1812:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY expr RParen Comma L End
action_1813:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD75)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD LParen IY expr RParen Comma expr End
action_1814:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx_n(0xFD36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD expr Comma A End
action_1815:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0x32)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD expr Comma BC End
action_1816:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xED43)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD expr Comma DE End
action_1817:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xED53)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD expr Comma HL End
action_1818:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0x22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD expr Comma IX End
action_1819:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xDD22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD expr Comma IY End
action_1820:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xFD22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LD expr Comma SP End
action_1821:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xD3)*/;
/*DO_stmt_nn(0xED73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LDD End
action_1822:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xEDA8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LDDR End
action_1823:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xEDB8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LDDSR End
action_1824:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xED98)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LDI End
action_1825:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xEDA0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LDIR End
action_1826:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xEDB0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LDISR End
action_1827:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xED90)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LSDDR End
action_1828:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xEDD8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LSDR End
action_1829:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xEDF8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LSIDR End
action_1830:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xEDD0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI LSIR End
action_1831:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xEDF0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI OR A Comma LParen HL Minus RParen End | IOI OR LParen HL Minus RParen End
action_1832:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI OR A Comma LParen HL Plus RParen End | IOI OR LParen HL Plus RParen End
action_1833:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI OR A Comma LParen HL RParen End | IOI OR LParen HL RParen End
action_1834:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI OR A Comma LParen IX RParen End | IOI OR LParen IX RParen End
action_1835:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI OR A Comma LParen IX expr RParen End | IOI OR LParen IX expr RParen End
action_1836:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI OR A Comma LParen IY RParen End | IOI OR LParen IY RParen End
action_1837:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI OR A Comma LParen IY expr RParen End | IOI OR LParen IY expr RParen End
action_1838:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RES const_expr Comma LParen HL RParen End
action_1839:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB86+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RES const_expr Comma LParen IX RParen End
action_1840:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0086+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RES const_expr Comma LParen IX expr RParen End
action_1841:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB86+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RES const_expr Comma LParen IY RParen End
action_1842:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0086+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RES const_expr Comma LParen IY expr RParen End
action_1843:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB86+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RL LParen HL RParen End
action_1844:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RL LParen IX RParen End
action_1845:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RL LParen IX expr RParen End
action_1846:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RL LParen IY RParen End
action_1847:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RL LParen IY expr RParen End
action_1848:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RLC LParen HL RParen End
action_1849:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RLC LParen IX RParen End
action_1850:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RLC LParen IX expr RParen End
action_1851:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RLC LParen IY RParen End
action_1852:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RLC LParen IY expr RParen End
action_1853:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RR LParen HL RParen End
action_1854:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RR LParen IX RParen End
action_1855:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RR LParen IX expr RParen End
action_1856:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RR LParen IY RParen End
action_1857:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RR LParen IY expr RParen End
action_1858:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RRC LParen HL RParen End
action_1859:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RRC LParen IX RParen End
action_1860:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RRC LParen IX expr RParen End
action_1861:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RRC LParen IY RParen End
action_1862:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI RRC LParen IY expr RParen End
action_1863:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SBC A Comma LParen HL Minus RParen End | IOI SBC LParen HL Minus RParen End
action_1864:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SBC A Comma LParen HL Plus RParen End | IOI SBC LParen HL Plus RParen End
action_1865:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SBC A Comma LParen HL RParen End | IOI SBC LParen HL RParen End
action_1866:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SBC A Comma LParen IX RParen End | IOI SBC LParen IX RParen End
action_1867:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SBC A Comma LParen IX expr RParen End | IOI SBC LParen IX expr RParen End
action_1868:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SBC A Comma LParen IY RParen End | IOI SBC LParen IY RParen End
action_1869:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SBC A Comma LParen IY expr RParen End | IOI SBC LParen IY expr RParen End
action_1870:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SET const_expr Comma LParen HL RParen End
action_1871:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SET const_expr Comma LParen IX RParen End
action_1872:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SET const_expr Comma LParen IX expr RParen End
action_1873:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SET const_expr Comma LParen IY RParen End
action_1874:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SET const_expr Comma LParen IY expr RParen End
action_1875:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xD3)*/;
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SLA LParen HL RParen End
action_1876:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SLA LParen IX RParen End
action_1877:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SLA LParen IX expr RParen End
action_1878:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SLA LParen IY RParen End
action_1879:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SLA LParen IY expr RParen End
action_1880:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRA LParen HL RParen End
action_1881:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRA LParen IX RParen End
action_1882:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRA LParen IX expr RParen End
action_1883:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRA LParen IY RParen End
action_1884:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRA LParen IY expr RParen End
action_1885:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRL LParen HL RParen End
action_1886:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRL LParen IX RParen End
action_1887:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRL LParen IX expr RParen End
action_1888:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRL LParen IY RParen End
action_1889:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SRL LParen IY expr RParen End
action_1890:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SUB A Comma LParen HL Minus RParen End | IOI SUB LParen HL Minus RParen End
action_1891:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SUB A Comma LParen HL Plus RParen End | IOI SUB LParen HL Plus RParen End
action_1892:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x96)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SUB A Comma LParen HL RParen End | IOI SUB LParen HL RParen End
action_1893:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0x96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SUB A Comma LParen IX RParen End | IOI SUB LParen IX RParen End
action_1894:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SUB A Comma LParen IX expr RParen End | IOI SUB LParen IX expr RParen End
action_1895:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SUB A Comma LParen IY RParen End | IOI SUB LParen IY RParen End
action_1896:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI SUB A Comma LParen IY expr RParen End | IOI SUB LParen IY expr RParen End
action_1897:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI XOR A Comma LParen HL Minus RParen End | IOI XOR LParen HL Minus RParen End
action_1898:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI XOR A Comma LParen HL Plus RParen End | IOI XOR LParen HL Plus RParen End
action_1899:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI XOR A Comma LParen HL RParen End | IOI XOR LParen HL RParen End
action_1900:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI XOR A Comma LParen IX RParen End | IOI XOR LParen IX RParen End
action_1901:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xDDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI XOR A Comma LParen IX expr RParen End | IOI XOR LParen IX expr RParen End
action_1902:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xDDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI XOR A Comma LParen IY RParen End | IOI XOR LParen IY RParen End
action_1903:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt(0xFDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IOI XOR A Comma LParen IY expr RParen End | IOI XOR LParen IY expr RParen End
action_1904:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD3)*/;
/*DO_stmt_idx(0xFDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IPRES End
action_1905:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED5D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: IPSET const_expr End
action_1906:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xED00+((expr_value==0?0x46:expr_value==1?0x56:expr_value==2?0x4E:0x5E)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JC expr End | JP C Comma expr End | J_C expr End
action_1907:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xDA)*/;
return true;

// action for: JK expr End | JP K Comma expr End | JP X5 Comma expr End | JX5 expr End
action_1908:
switch (option_cpu()) {
case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xFD)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JLO expr End | JP LO Comma expr End | J_LO expr End
action_1909:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xEA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JLZ expr End | JP LZ Comma expr End | J_LZ expr End
action_1910:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xE2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JM expr End | JP M Comma expr End | J_M expr End
action_1911:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xFA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JMP expr End | JP expr End
action_1912:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xC3)*/;
return true;

// action for: JNC expr End | JP NC Comma expr End | J_NC expr End
action_1913:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xD2)*/;
return true;

// action for: JNK expr End | JNX5 expr End | JP NK Comma expr End | JP NX5 Comma expr End
action_1914:
switch (option_cpu()) {
case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xDD)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JNV expr End | JP NV Comma expr End | JP PO Comma expr End | JPO expr End | J_NV expr End | J_PO expr End
action_1915:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xE2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JNZ expr End | JP NZ Comma expr End | J_NZ expr End
action_1916:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xC2)*/;
return true;

// action for: JP P Comma expr End | J_P expr End
action_1917:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xF2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JP PE Comma expr End | JP V Comma expr End | JPE expr End | JV expr End | J_PE expr End | J_V expr End
action_1918:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xEA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JP Z Comma expr End | JZ expr End | J_Z expr End
action_1919:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xCA)*/;
return true;

// action for: JP LParen BC RParen End
action_1920:
/*DO_stmt(0xC5)*/;
/*DO_stmt(0xC9)*/;
return true;

// action for: JP LParen C RParen End
action_1921:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED98)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JP LParen DE RParen End
action_1922:
/*DO_stmt(0xD5)*/;
/*DO_stmt(0xC9)*/;
return true;

// action for: JP LParen HL RParen End | PCHL End
action_1923:
/*DO_stmt(0xE9)*/;
return true;

// action for: JP LParen IX RParen End
action_1924:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDE9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JP LParen IY RParen End
action_1925:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDE9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JR C Comma expr End
action_1926:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_jr(0x38)*/;
break;
case CPU_8080: case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xDA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JR NC Comma expr End
action_1927:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_jr(0x30)*/;
break;
case CPU_8080: case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xD2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JR NZ Comma expr End
action_1928:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_jr(0x20)*/;
break;
case CPU_8080: case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xC2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JR Z Comma expr End
action_1929:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_jr(0x28)*/;
break;
case CPU_8080: case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xCA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: JR expr End
action_1930:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_jr(0x18)*/;
break;
case CPU_8080: case CPU_8085: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xC3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma A End | MOV A Comma A End
action_1931:
/*DO_stmt(0x7F)*/;
return true;

// action for: LD A Comma B End | MOV A Comma B End
action_1932:
/*DO_stmt(0x78)*/;
return true;

// action for: LD A Comma C End | MOV A Comma C End
action_1933:
/*DO_stmt(0x79)*/;
return true;

// action for: LD A Comma D End | MOV A Comma D End
action_1934:
/*DO_stmt(0x7A)*/;
return true;

// action for: LD A Comma E End | MOV A Comma E End
action_1935:
/*DO_stmt(0x7B)*/;
return true;

// action for: LD A Comma EIR End
action_1936:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED57)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma H End | MOV A Comma H End
action_1937:
/*DO_stmt(0x7C)*/;
return true;

// action for: LD A Comma I End
action_1938:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED57)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma IIR End
action_1939:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED5F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma IXH End
action_1940:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma IXL End
action_1941:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma IYH End
action_1942:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma IYL End
action_1943:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma L End | MOV A Comma L End
action_1944:
/*DO_stmt(0x7D)*/;
return true;

// action for: LD A Comma R End
action_1945:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED5F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma XPC End
action_1946:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma LParen BC Minus RParen End | LDD A Comma LParen BC RParen End
action_1947:
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x0B)*/;
return true;

// action for: LD A Comma LParen BC Plus RParen End | LDI A Comma LParen BC RParen End
action_1948:
/*DO_stmt(0x0A)*/;
/*DO_stmt(0x03)*/;
return true;

// action for: LD A Comma LParen BC RParen End | LDAX B End | LDAX BC End
action_1949:
/*DO_stmt(0x0A)*/;
return true;

// action for: LD A Comma LParen C RParen End | LDH A Comma LParen C RParen End
action_1950:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xF2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma LParen DE Minus RParen End | LDD A Comma LParen DE RParen End
action_1951:
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x1B)*/;
return true;

// action for: LD A Comma LParen DE Plus RParen End | LDI A Comma LParen DE RParen End
action_1952:
/*DO_stmt(0x1A)*/;
/*DO_stmt(0x13)*/;
return true;

// action for: LD A Comma LParen DE RParen End | LDAX D End | LDAX DE End
action_1953:
/*DO_stmt(0x1A)*/;
return true;

// action for: LD A Comma LParen HL Minus RParen End | LD A Comma LParen HLD RParen End | LDD A Comma LParen HL RParen End
action_1954:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0x3A)*/;
break;
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma LParen HL Plus RParen End | LD A Comma LParen HLI RParen End | LDI A Comma LParen HL RParen End
action_1955:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0x2A)*/;
break;
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0x7E)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma LParen HL RParen End | MOV A Comma M End
action_1956:
/*DO_stmt(0x7E)*/;
return true;

// action for: LD A Comma LParen IX RParen End
action_1957:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma LParen IX expr RParen End
action_1958:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma LParen IY RParen End
action_1959:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma LParen IY expr RParen End
action_1960:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD A Comma expr End
action_1961:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
#if 0
if (expr_in_parens) { /*DO_stmt_nn(0x3A)*/; } else { /*DO_stmt_n(0x3E)*/; }
#endif

break;
case CPU_GBZ80: 
#if 0
if (expr_in_parens) { /*DO_stmt_nn(0xFA)*/; } else { /*DO_stmt_n(0x3E)*/; }
#endif

break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma A End | MOV B Comma A End
action_1962:
/*DO_stmt(0x47)*/;
return true;

// action for: LD B Comma B End | MOV B Comma B End
action_1963:
/*DO_stmt(0x40)*/;
return true;

// action for: LD B Comma C End | MOV B Comma C End
action_1964:
/*DO_stmt(0x41)*/;
return true;

// action for: LD B Comma D End | MOV B Comma D End
action_1965:
/*DO_stmt(0x42)*/;
return true;

// action for: LD B Comma E End | MOV B Comma E End
action_1966:
/*DO_stmt(0x43)*/;
return true;

// action for: LD B Comma H End | MOV B Comma H End
action_1967:
/*DO_stmt(0x44)*/;
return true;

// action for: LD B Comma IXH End
action_1968:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD44)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma IXL End
action_1969:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD45)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma IYH End
action_1970:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD44)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma IYL End
action_1971:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD45)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma L End | MOV B Comma L End
action_1972:
/*DO_stmt(0x45)*/;
return true;

// action for: LD B Comma LParen DE Minus RParen End | LDD B Comma LParen DE RParen End
action_1973:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma LParen DE Plus RParen End | LDI B Comma LParen DE RParen End
action_1974:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma LParen DE RParen End
action_1975:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x46)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma LParen HL Minus RParen End | LD B Comma LParen HLD RParen End | LDD B Comma LParen HL RParen End
action_1976:
/*DO_stmt(0x46)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD B Comma LParen HL Plus RParen End | LD B Comma LParen HLI RParen End | LDI B Comma LParen HL RParen End
action_1977:
/*DO_stmt(0x46)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD B Comma LParen HL RParen End | MOV B Comma M End
action_1978:
/*DO_stmt(0x46)*/;
return true;

// action for: LD B Comma LParen IX RParen End
action_1979:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma LParen IX expr RParen End
action_1980:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma LParen IY RParen End
action_1981:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD4600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma LParen IY expr RParen End
action_1982:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD46)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD B Comma expr End | MVI B Comma expr End
action_1983:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x06)*/;
return true;

// action for: LD BC Comma DE End
action_1984:
/*DO_stmt(0x42)*/;
/*DO_stmt(0x4B)*/;
return true;

// action for: LD BC Comma HL End
action_1985:
/*DO_stmt(0x44)*/;
/*DO_stmt(0x4D)*/;
return true;

// action for: LD BC Comma IX End
action_1986:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD44)*/;
/*DO_stmt(0xDD4D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD BC Comma IY End
action_1987:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD44)*/;
/*DO_stmt(0xFD4D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD BC Comma expr End
action_1988:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
#if 0
if (expr_in_parens) { /*DO_stmt_nn(0xED4B)*/; } else { /*DO_stmt_nn(0x01)*/; }
#endif

break;
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x01)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma A End | MOV C Comma A End
action_1989:
/*DO_stmt(0x4F)*/;
return true;

// action for: LD C Comma B End | MOV C Comma B End
action_1990:
/*DO_stmt(0x48)*/;
return true;

// action for: LD C Comma C End | MOV C Comma C End
action_1991:
/*DO_stmt(0x49)*/;
return true;

// action for: LD C Comma D End | MOV C Comma D End
action_1992:
/*DO_stmt(0x4A)*/;
return true;

// action for: LD C Comma E End | MOV C Comma E End
action_1993:
/*DO_stmt(0x4B)*/;
return true;

// action for: LD C Comma H End | MOV C Comma H End
action_1994:
/*DO_stmt(0x4C)*/;
return true;

// action for: LD C Comma IXH End
action_1995:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD4C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma IXL End
action_1996:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD4D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma IYH End
action_1997:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD4C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma IYL End
action_1998:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD4D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma L End | MOV C Comma L End
action_1999:
/*DO_stmt(0x4D)*/;
return true;

// action for: LD C Comma LParen DE Minus RParen End | LDD C Comma LParen DE RParen End
action_2000:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma LParen DE Plus RParen End | LDI C Comma LParen DE RParen End
action_2001:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma LParen DE RParen End
action_2002:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x4E)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma LParen HL Minus RParen End | LD C Comma LParen HLD RParen End | LDD C Comma LParen HL RParen End
action_2003:
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD C Comma LParen HL Plus RParen End | LD C Comma LParen HLI RParen End | LDI C Comma LParen HL RParen End
action_2004:
/*DO_stmt(0x4E)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD C Comma LParen HL RParen End | MOV C Comma M End
action_2005:
/*DO_stmt(0x4E)*/;
return true;

// action for: LD C Comma LParen IX RParen End
action_2006:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma LParen IX expr RParen End
action_2007:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma LParen IY RParen End
action_2008:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD4E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma LParen IY expr RParen End
action_2009:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD4E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD C Comma expr End | MVI C Comma expr End
action_2010:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x0E)*/;
return true;

// action for: LD D Comma A End | MOV D Comma A End
action_2011:
/*DO_stmt(0x57)*/;
return true;

// action for: LD D Comma B End | MOV D Comma B End
action_2012:
/*DO_stmt(0x50)*/;
return true;

// action for: LD D Comma C End | MOV D Comma C End
action_2013:
/*DO_stmt(0x51)*/;
return true;

// action for: LD D Comma D End | MOV D Comma D End
action_2014:
/*DO_stmt(0x52)*/;
return true;

// action for: LD D Comma E End | MOV D Comma E End
action_2015:
/*DO_stmt(0x53)*/;
return true;

// action for: LD D Comma H End | MOV D Comma H End
action_2016:
/*DO_stmt(0x54)*/;
return true;

// action for: LD D Comma IXH End
action_2017:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD54)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma IXL End
action_2018:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD55)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma IYH End
action_2019:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD54)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma IYL End
action_2020:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD55)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma L End | MOV D Comma L End
action_2021:
/*DO_stmt(0x55)*/;
return true;

// action for: LD D Comma LParen DE Minus RParen End | LDD D Comma LParen DE RParen End
action_2022:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma LParen DE Plus RParen End | LDI D Comma LParen DE RParen End
action_2023:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma LParen DE RParen End
action_2024:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x66)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma LParen HL Minus RParen End | LD D Comma LParen HLD RParen End | LDD D Comma LParen HL RParen End
action_2025:
/*DO_stmt(0x56)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD D Comma LParen HL Plus RParen End | LD D Comma LParen HLI RParen End | LDI D Comma LParen HL RParen End
action_2026:
/*DO_stmt(0x56)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD D Comma LParen HL RParen End | MOV D Comma M End
action_2027:
/*DO_stmt(0x56)*/;
return true;

// action for: LD D Comma LParen IX RParen End
action_2028:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma LParen IX expr RParen End
action_2029:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma LParen IY RParen End
action_2030:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD5600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma LParen IY expr RParen End
action_2031:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD56)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD D Comma expr End | MVI D Comma expr End
action_2032:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x16)*/;
return true;

// action for: LD DE Comma BC End
action_2033:
/*DO_stmt(0x50)*/;
/*DO_stmt(0x59)*/;
return true;

// action for: LD DE Comma HL End
action_2034:
/*DO_stmt(0x54)*/;
/*DO_stmt(0x5D)*/;
return true;

// action for: LD DE Comma HL expr End
action_2035:
switch (option_cpu()) {
case CPU_8085: 
/*DO_stmt_n(0x28)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD DE Comma IX End
action_2036:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD54)*/;
/*DO_stmt(0xDD5D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD DE Comma IY End
action_2037:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD54)*/;
/*DO_stmt(0xFD5D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD DE Comma SP End
action_2038:
switch (option_cpu()) {
case CPU_8085: 
/*DO_stmt(0x3800)*/;
break;
case CPU_GBZ80: 
/*DO_stmt(0xE5)*/;
/*DO_stmt(0xD5)*/;
/*DO_stmt(0xE1)*/;
/*DO_stmt(0xD1)*/;
/*DO_stmt(0x210000)*/;
/*DO_stmt(0x39)*/;
/*DO_stmt(0xE5)*/;
/*DO_stmt(0xD5)*/;
/*DO_stmt(0xE1)*/;
/*DO_stmt(0xD1)*/;
break;
case CPU_8080: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x210000)*/;
/*DO_stmt(0x39)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD DE Comma SP expr End
action_2039:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xE5)*/;
/*DO_stmt(0xD5)*/;
/*DO_stmt(0xE1)*/;
/*DO_stmt(0xD1)*/;
/*DO_stmt_n_0(0x21)*/;
/*DO_stmt(0x39)*/;
/*DO_stmt(0xE5)*/;
/*DO_stmt(0xD5)*/;
/*DO_stmt(0xE1)*/;
/*DO_stmt(0xD1)*/;
break;
case CPU_8080: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt_n_0(0x21)*/;
/*DO_stmt(0x39)*/;
/*DO_stmt(0xEB)*/;
break;
case CPU_8085: 
/*DO_stmt_n(0x38)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD DE Comma expr End
action_2040:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
#if 0
if (expr_in_parens) { /*DO_stmt(0xEB)*/;
/*DO_stmt_nn(0x2A)*/;
/*DO_stmt(0xEB)*/; } else { /*DO_stmt_nn(0x11)*/; }
#endif

break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
#if 0
if (expr_in_parens) { /*DO_stmt_nn(0xED5B)*/; } else { /*DO_stmt_nn(0x11)*/; }
#endif

break;
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x11)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma A End | MOV E Comma A End
action_2041:
/*DO_stmt(0x5F)*/;
return true;

// action for: LD E Comma B End | MOV E Comma B End
action_2042:
/*DO_stmt(0x58)*/;
return true;

// action for: LD E Comma C End | MOV E Comma C End
action_2043:
/*DO_stmt(0x59)*/;
return true;

// action for: LD E Comma D End | MOV E Comma D End
action_2044:
/*DO_stmt(0x5A)*/;
return true;

// action for: LD E Comma E End | MOV E Comma E End
action_2045:
/*DO_stmt(0x5B)*/;
return true;

// action for: LD E Comma H End | MOV E Comma H End
action_2046:
/*DO_stmt(0x5C)*/;
return true;

// action for: LD E Comma IXH End
action_2047:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD5C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma IXL End
action_2048:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD5D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma IYH End
action_2049:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD5C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma IYL End
action_2050:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD5D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma L End | MOV E Comma L End
action_2051:
/*DO_stmt(0x5D)*/;
return true;

// action for: LD E Comma LParen DE Minus RParen End | LDD E Comma LParen DE RParen End
action_2052:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma LParen DE Plus RParen End | LDI E Comma LParen DE RParen End
action_2053:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma LParen DE RParen End
action_2054:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x6E)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma LParen HL Minus RParen End | LD E Comma LParen HLD RParen End | LDD E Comma LParen HL RParen End
action_2055:
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD E Comma LParen HL Plus RParen End | LD E Comma LParen HLI RParen End | LDI E Comma LParen HL RParen End
action_2056:
/*DO_stmt(0x5E)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD E Comma LParen HL RParen End | MOV E Comma M End
action_2057:
/*DO_stmt(0x5E)*/;
return true;

// action for: LD E Comma LParen IX RParen End
action_2058:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma LParen IX expr RParen End
action_2059:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma LParen IY RParen End
action_2060:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD5E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma LParen IY expr RParen End
action_2061:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD5E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD E Comma expr End | MVI E Comma expr End
action_2062:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x1E)*/;
return true;

// action for: LD EIR Comma A End
action_2063:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED47)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD H Comma A End | MOV H Comma A End
action_2064:
/*DO_stmt(0x67)*/;
return true;

// action for: LD H Comma B End | MOV H Comma B End
action_2065:
/*DO_stmt(0x60)*/;
return true;

// action for: LD H Comma C End | MOV H Comma C End
action_2066:
/*DO_stmt(0x61)*/;
return true;

// action for: LD H Comma D End | MOV H Comma D End
action_2067:
/*DO_stmt(0x62)*/;
return true;

// action for: LD H Comma E End | MOV H Comma E End
action_2068:
/*DO_stmt(0x63)*/;
return true;

// action for: LD H Comma H End | MOV H Comma H End
action_2069:
/*DO_stmt(0x64)*/;
return true;

// action for: LD H Comma L End | MOV H Comma L End
action_2070:
/*DO_stmt(0x65)*/;
return true;

// action for: LD H Comma LParen DE Minus RParen End | LDD H Comma LParen DE RParen End
action_2071:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD H Comma LParen DE Plus RParen End | LDI H Comma LParen DE RParen End
action_2072:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD H Comma LParen DE RParen End
action_2073:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x56)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD H Comma LParen HL Minus RParen End | LD H Comma LParen HLD RParen End | LDD H Comma LParen HL RParen End
action_2074:
/*DO_stmt(0x66)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD H Comma LParen HL Plus RParen End | LD H Comma LParen HLI RParen End | LDI H Comma LParen HL RParen End
action_2075:
/*DO_stmt(0x66)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD H Comma LParen HL RParen End | MOV H Comma M End
action_2076:
/*DO_stmt(0x66)*/;
return true;

// action for: LD H Comma LParen IX RParen End
action_2077:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD H Comma LParen IX expr RParen End
action_2078:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD H Comma LParen IY RParen End
action_2079:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD6600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD H Comma LParen IY expr RParen End
action_2080:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD H Comma expr End | MVI H Comma expr End
action_2081:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x26)*/;
return true;

// action for: LD HL Comma BC End
action_2082:
/*DO_stmt(0x60)*/;
/*DO_stmt(0x69)*/;
return true;

// action for: LD HL Comma DE End
action_2083:
/*DO_stmt(0x62)*/;
/*DO_stmt(0x6B)*/;
return true;

// action for: LD HL Comma IX End
action_2084:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDD7C)*/;
break;
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDE5)*/;
/*DO_stmt(0xE1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma IY End
action_2085:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFD7C)*/;
break;
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDE5)*/;
/*DO_stmt(0xE1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma SP End
action_2086:
switch (option_cpu()) {
case CPU_8080: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0x210000)*/;
/*DO_stmt(0x39)*/;
break;
case CPU_8085: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x3800)*/;
/*DO_stmt(0xEB)*/;
break;
case CPU_GBZ80: 
/*DO_stmt(0xF800)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma SP expr End
action_2087:
switch (option_cpu()) {
case CPU_8085: 
/*DO_stmt(0xEB)*/;
/*DO_stmt_n(0x38)*/;
/*DO_stmt(0xEB)*/;
break;
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_d(0xF8)*/;
break;
case CPU_8080: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_s_0(0x21)*/;
/*DO_stmt(0x39)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma LParen DE RParen End | LHLDE End | LHLX End
action_2088:
switch (option_cpu()) {
case CPU_8085: 
/*DO_stmt(0xED)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma LParen HL RParen End
action_2089:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma LParen HL expr RParen End
action_2090:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_idx(0xDDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma LParen IX RParen End
action_2091:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma LParen IX expr RParen End
action_2092:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_idx(0xE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma LParen IY RParen End
action_2093:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFDE400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma LParen IY expr RParen End
action_2094:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_idx(0xFDE4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma LParen SP RParen End
action_2095:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xC400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma LParen SP expr RParen End
action_2096:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_n(0xC4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD HL Comma expr End
action_2097:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
#if 0
if (expr_in_parens) { /*DO_stmt_nn(0x2A)*/; } else { /*DO_stmt_nn(0x21)*/; }
#endif

break;
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x21)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD I Comma A End
action_2098:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED47)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IIR Comma A End
action_2099:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED4F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IX Comma BC End
action_2100:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD60)*/;
/*DO_stmt(0xDD69)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IX Comma DE End
action_2101:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD62)*/;
/*DO_stmt(0xDD6B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IX Comma HL End
action_2102:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDD7D)*/;
break;
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xE5)*/;
/*DO_stmt(0xDDE1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IX Comma IY End
action_2103:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDE5)*/;
/*DO_stmt(0xDDE1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IX Comma LParen SP RParen End
action_2104:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDDC400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IX Comma LParen SP expr RParen End
action_2105:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_n(0xDDC4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IX Comma expr End
action_2106:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
#if 0
if (expr_in_parens) { /*DO_stmt_nn(0xDD2A)*/; } else { /*DO_stmt_nn(0xDD21)*/; }
#endif

break;
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xDD21)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXH Comma A End
action_2107:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD67)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXH Comma B End
action_2108:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD60)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXH Comma C End
action_2109:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD61)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXH Comma D End
action_2110:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD62)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXH Comma E End
action_2111:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD63)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXH Comma IXH End
action_2112:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD64)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXH Comma IXL End
action_2113:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD65)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXH Comma expr End
action_2114:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xDD26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXL Comma A End
action_2115:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD6F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXL Comma B End
action_2116:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD68)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXL Comma C End
action_2117:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD69)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXL Comma D End
action_2118:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD6A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXL Comma E End
action_2119:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD6B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXL Comma IXH End
action_2120:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD6C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXL Comma IXL End
action_2121:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD6D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IXL Comma expr End
action_2122:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xDD2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IY Comma BC End
action_2123:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD60)*/;
/*DO_stmt(0xFD69)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IY Comma DE End
action_2124:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD62)*/;
/*DO_stmt(0xFD6B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IY Comma HL End
action_2125:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xE5)*/;
/*DO_stmt(0xFDE1)*/;
break;
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFD7D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IY Comma IX End
action_2126:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDE5)*/;
/*DO_stmt(0xFDE1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IY Comma LParen SP RParen End
action_2127:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFDC400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IY Comma LParen SP expr RParen End
action_2128:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_n(0xFDC4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IY Comma expr End
action_2129:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
#if 0
if (expr_in_parens) { /*DO_stmt_nn(0xFD2A)*/; } else { /*DO_stmt_nn(0xFD21)*/; }
#endif

break;
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xFD21)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYH Comma A End
action_2130:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD67)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYH Comma B End
action_2131:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD60)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYH Comma C End
action_2132:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD61)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYH Comma D End
action_2133:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD62)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYH Comma E End
action_2134:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD63)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYH Comma IYH End
action_2135:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD64)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYH Comma IYL End
action_2136:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD65)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYH Comma expr End
action_2137:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xFD26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYL Comma A End
action_2138:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD6F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYL Comma B End
action_2139:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD68)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYL Comma C End
action_2140:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD69)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYL Comma D End
action_2141:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD6A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYL Comma E End
action_2142:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD6B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYL Comma IYH End
action_2143:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD6C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYL Comma IYL End
action_2144:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD6D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD IYL Comma expr End
action_2145:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xFD2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD L Comma A End | MOV L Comma A End
action_2146:
/*DO_stmt(0x6F)*/;
return true;

// action for: LD L Comma B End | MOV L Comma B End
action_2147:
/*DO_stmt(0x68)*/;
return true;

// action for: LD L Comma C End | MOV L Comma C End
action_2148:
/*DO_stmt(0x69)*/;
return true;

// action for: LD L Comma D End | MOV L Comma D End
action_2149:
/*DO_stmt(0x6A)*/;
return true;

// action for: LD L Comma E End | MOV L Comma E End
action_2150:
/*DO_stmt(0x6B)*/;
return true;

// action for: LD L Comma H End | MOV L Comma H End
action_2151:
/*DO_stmt(0x6C)*/;
return true;

// action for: LD L Comma L End | MOV L Comma L End
action_2152:
/*DO_stmt(0x6D)*/;
return true;

// action for: LD L Comma LParen DE Minus RParen End | LDD L Comma LParen DE RParen End
action_2153:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD L Comma LParen DE Plus RParen End | LDI L Comma LParen DE RParen End
action_2154:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD L Comma LParen DE RParen End
action_2155:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x5E)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD L Comma LParen HL Minus RParen End | LD L Comma LParen HLD RParen End | LDD L Comma LParen HL RParen End
action_2156:
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD L Comma LParen HL Plus RParen End | LD L Comma LParen HLI RParen End | LDI L Comma LParen HL RParen End
action_2157:
/*DO_stmt(0x6E)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD L Comma LParen HL RParen End | MOV L Comma M End
action_2158:
/*DO_stmt(0x6E)*/;
return true;

// action for: LD L Comma LParen IX RParen End
action_2159:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD L Comma LParen IX expr RParen End
action_2160:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD L Comma LParen IY RParen End
action_2161:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD6E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD L Comma LParen IY expr RParen End
action_2162:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD L Comma expr End | MVI L Comma expr End
action_2163:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x2E)*/;
return true;

// action for: LD R Comma A End
action_2164:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED4F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD SP Comma HL End | SPHL End
action_2165:
/*DO_stmt(0xF9)*/;
return true;

// action for: LD SP Comma IX End
action_2166:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDF9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD SP Comma IY End
action_2167:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDF9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD SP Comma expr End
action_2168:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
#if 0
if (expr_in_parens) { /*DO_stmt_nn(0xED7B)*/; } else { /*DO_stmt_nn(0x31)*/; }
#endif

break;
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x31)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD XPC Comma A End
action_2169:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED67)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen BC Minus RParen Comma A End | LDD LParen BC RParen Comma A End
action_2170:
/*DO_stmt(0x02)*/;
/*DO_stmt(0x0B)*/;
return true;

// action for: LD LParen BC Plus RParen Comma A End | LDI LParen BC RParen Comma A End
action_2171:
/*DO_stmt(0x02)*/;
/*DO_stmt(0x03)*/;
return true;

// action for: LD LParen BC RParen Comma A End | STAX B End | STAX BC End
action_2172:
/*DO_stmt(0x02)*/;
return true;

// action for: LD LParen C RParen Comma A End | LDH LParen C RParen Comma A End
action_2173:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xE2)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Minus RParen Comma A End | LDD LParen DE RParen Comma A End
action_2174:
/*DO_stmt(0x12)*/;
/*DO_stmt(0x1B)*/;
return true;

// action for: LD LParen DE Minus RParen Comma B End | LDD LParen DE RParen Comma B End
action_2175:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x70)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Minus RParen Comma C End | LDD LParen DE RParen Comma C End
action_2176:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x71)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Minus RParen Comma D End | LDD LParen DE RParen Comma D End
action_2177:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x74)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Minus RParen Comma E End | LDD LParen DE RParen Comma E End
action_2178:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x75)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Minus RParen Comma H End | LDD LParen DE RParen Comma H End
action_2179:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x72)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Minus RParen Comma L End | LDD LParen DE RParen Comma L End
action_2180:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x73)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Minus RParen Comma expr End | LDD LParen DE RParen Comma expr End
action_2181:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xEB)*/;
/*DO_stmt_n(0x36)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Plus RParen Comma A End | LDI LParen DE RParen Comma A End
action_2182:
/*DO_stmt(0x12)*/;
/*DO_stmt(0x13)*/;
return true;

// action for: LD LParen DE Plus RParen Comma B End | LDI LParen DE RParen Comma B End
action_2183:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x70)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Plus RParen Comma C End | LDI LParen DE RParen Comma C End
action_2184:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x71)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Plus RParen Comma D End | LDI LParen DE RParen Comma D End
action_2185:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x74)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Plus RParen Comma E End | LDI LParen DE RParen Comma E End
action_2186:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x75)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Plus RParen Comma H End | LDI LParen DE RParen Comma H End
action_2187:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x72)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Plus RParen Comma L End | LDI LParen DE RParen Comma L End
action_2188:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x73)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE Plus RParen Comma expr End | LDI LParen DE RParen Comma expr End
action_2189:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xEB)*/;
/*DO_stmt_n(0x36)*/;
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE RParen Comma A End | STAX D End | STAX DE End
action_2190:
/*DO_stmt(0x12)*/;
return true;

// action for: LD LParen DE RParen Comma B End
action_2191:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x70)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE RParen Comma C End
action_2192:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x71)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE RParen Comma D End
action_2193:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x74)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE RParen Comma E End
action_2194:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x75)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE RParen Comma H End
action_2195:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x72)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE RParen Comma HL End | SHLDE End | SHLX End
action_2196:
switch (option_cpu()) {
case CPU_8085: 
/*DO_stmt(0xD9)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE RParen Comma L End
action_2197:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEB)*/;
/*DO_stmt(0x73)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen DE RParen Comma expr End
action_2198:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt(0xEB)*/;
/*DO_stmt_n(0x36)*/;
/*DO_stmt(0xEB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen HL Minus RParen Comma A End | LD LParen HLD RParen Comma A End | LDD LParen HL RParen Comma A End
action_2199:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0x32)*/;
break;
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0x77)*/;
/*DO_stmt(0x2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen HL Minus RParen Comma B End | LD LParen HLD RParen Comma B End | LDD LParen HL RParen Comma B End
action_2200:
/*DO_stmt(0x70)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD LParen HL Minus RParen Comma C End | LD LParen HLD RParen Comma C End | LDD LParen HL RParen Comma C End
action_2201:
/*DO_stmt(0x71)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD LParen HL Minus RParen Comma D End | LD LParen HLD RParen Comma D End | LDD LParen HL RParen Comma D End
action_2202:
/*DO_stmt(0x72)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD LParen HL Minus RParen Comma E End | LD LParen HLD RParen Comma E End | LDD LParen HL RParen Comma E End
action_2203:
/*DO_stmt(0x73)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD LParen HL Minus RParen Comma H End | LD LParen HLD RParen Comma H End | LDD LParen HL RParen Comma H End
action_2204:
/*DO_stmt(0x74)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD LParen HL Minus RParen Comma L End | LD LParen HLD RParen Comma L End | LDD LParen HL RParen Comma L End
action_2205:
/*DO_stmt(0x75)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD LParen HL Minus RParen Comma expr End | LDD LParen HL RParen Comma expr End
action_2206:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x36)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD LParen HL Plus RParen Comma A End | LD LParen HLI RParen Comma A End | LDI LParen HL RParen Comma A End
action_2207:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0x22)*/;
break;
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0x77)*/;
/*DO_stmt(0x23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen HL Plus RParen Comma B End | LD LParen HLI RParen Comma B End | LDI LParen HL RParen Comma B End
action_2208:
/*DO_stmt(0x70)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD LParen HL Plus RParen Comma BC End | LDI LParen HL RParen Comma BC End
action_2209:
/*DO_stmt(0x71)*/;
/*DO_stmt(0x23)*/;
/*DO_stmt(0x70)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD LParen HL Plus RParen Comma C End | LD LParen HLI RParen Comma C End | LDI LParen HL RParen Comma C End
action_2210:
/*DO_stmt(0x71)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD LParen HL Plus RParen Comma D End | LD LParen HLI RParen Comma D End | LDI LParen HL RParen Comma D End
action_2211:
/*DO_stmt(0x72)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD LParen HL Plus RParen Comma DE End | LDI LParen HL RParen Comma DE End
action_2212:
/*DO_stmt(0x73)*/;
/*DO_stmt(0x23)*/;
/*DO_stmt(0x72)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD LParen HL Plus RParen Comma E End | LD LParen HLI RParen Comma E End | LDI LParen HL RParen Comma E End
action_2213:
/*DO_stmt(0x73)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD LParen HL Plus RParen Comma H End | LD LParen HLI RParen Comma H End | LDI LParen HL RParen Comma H End
action_2214:
/*DO_stmt(0x74)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD LParen HL Plus RParen Comma L End | LD LParen HLI RParen Comma L End | LDI LParen HL RParen Comma L End
action_2215:
/*DO_stmt(0x75)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD LParen HL Plus RParen Comma expr End | LDI LParen HL RParen Comma expr End
action_2216:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x36)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: LD LParen HL RParen Comma A End | MOV M Comma A End
action_2217:
/*DO_stmt(0x77)*/;
return true;

// action for: LD LParen HL RParen Comma B End | MOV M Comma B End
action_2218:
/*DO_stmt(0x70)*/;
return true;

// action for: LD LParen HL RParen Comma BC End
action_2219:
/*DO_stmt(0x71)*/;
/*DO_stmt(0x23)*/;
/*DO_stmt(0x70)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD LParen HL RParen Comma C End | MOV M Comma C End
action_2220:
/*DO_stmt(0x71)*/;
return true;

// action for: LD LParen HL RParen Comma D End | MOV M Comma D End
action_2221:
/*DO_stmt(0x72)*/;
return true;

// action for: LD LParen HL RParen Comma DE End
action_2222:
/*DO_stmt(0x73)*/;
/*DO_stmt(0x23)*/;
/*DO_stmt(0x72)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: LD LParen HL RParen Comma E End | MOV M Comma E End
action_2223:
/*DO_stmt(0x73)*/;
return true;

// action for: LD LParen HL RParen Comma H End | MOV M Comma H End
action_2224:
/*DO_stmt(0x74)*/;
return true;

// action for: LD LParen HL RParen Comma HL End
action_2225:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDDF400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen HL RParen Comma L End | MOV M Comma L End
action_2226:
/*DO_stmt(0x75)*/;
return true;

// action for: LD LParen HL RParen Comma expr End | MVI M Comma expr End
action_2227:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x36)*/;
return true;

// action for: LD LParen HL expr RParen Comma HL End
action_2228:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_idx(0xDDF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX RParen Comma A End
action_2229:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7700)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX RParen Comma B End
action_2230:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7000)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX RParen Comma C End
action_2231:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7100)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX RParen Comma D End
action_2232:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7200)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX RParen Comma E End
action_2233:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7300)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX RParen Comma H End
action_2234:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX RParen Comma HL End
action_2235:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xF400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX RParen Comma L End
action_2236:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD7500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX RParen Comma expr End
action_2237:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xDD3600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX expr RParen Comma A End
action_2238:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX expr RParen Comma B End
action_2239:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD70)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX expr RParen Comma C End
action_2240:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD71)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX expr RParen Comma D End
action_2241:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX expr RParen Comma E End
action_2242:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX expr RParen Comma H End
action_2243:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD74)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX expr RParen Comma HL End
action_2244:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_idx(0xF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX expr RParen Comma L End
action_2245:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD75)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IX expr RParen Comma expr End
action_2246:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_idx_n(0xDD36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY RParen Comma A End
action_2247:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7700)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY RParen Comma B End
action_2248:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7000)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY RParen Comma C End
action_2249:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7100)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY RParen Comma D End
action_2250:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7200)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY RParen Comma E End
action_2251:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7300)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY RParen Comma H End
action_2252:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY RParen Comma HL End
action_2253:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFDF400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY RParen Comma L End
action_2254:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD7500)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY RParen Comma expr End
action_2255:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xFD3600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY expr RParen Comma A End
action_2256:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD77)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY expr RParen Comma B End
action_2257:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD70)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY expr RParen Comma C End
action_2258:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD71)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY expr RParen Comma D End
action_2259:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY expr RParen Comma E End
action_2260:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY expr RParen Comma H End
action_2261:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD74)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY expr RParen Comma HL End
action_2262:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_idx(0xFDF4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY expr RParen Comma L End
action_2263:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD75)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen IY expr RParen Comma expr End
action_2264:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_idx_n(0xFD36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen SP RParen Comma HL End
action_2265:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xD400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen SP RParen Comma IX End
action_2266:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDDD400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen SP RParen Comma IY End
action_2267:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFDD400)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen SP expr RParen Comma HL End
action_2268:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_n(0xD4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen SP expr RParen Comma IX End
action_2269:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_n(0xDDD4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD LParen SP expr RParen Comma IY End
action_2270:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt_n(0xFDD4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD expr Comma A End
action_2271:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0x32)*/;
break;
case CPU_GBZ80: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xEA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD expr Comma BC End
action_2272:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xED43)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD expr Comma DE End
action_2273:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt(0xEB)*/;
/*DO_stmt_nn(0x22)*/;
/*DO_stmt(0xEB)*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xED53)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD expr Comma HL End
action_2274:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0x22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD expr Comma IX End
action_2275:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xDD22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD expr Comma IY End
action_2276:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xFD22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LD expr Comma SP End
action_2277:
switch (option_cpu()) {
case CPU_GBZ80: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0x08)*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xED73)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDA expr End
action_2278:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x3A)*/;
break;
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xFA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDD End
action_2279:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__ldd")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDA8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDDR End
action_2280:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__lddr")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDB8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDDRX End | LDRX End
action_2281:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xEDBC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDDSR End
action_2282:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xED98)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDDX End
action_2283:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xEDAC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDH A Comma expr End
action_2284:
switch (option_cpu()) {
case CPU_GBZ80: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_h(0xF0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDH expr Comma A End
action_2285:
switch (option_cpu()) {
case CPU_GBZ80: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_h(0xE0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDHL SP Comma expr End
action_2286:
switch (option_cpu()) {
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_d(0xF8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDI End
action_2287:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__ldi")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDA0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDIR End
action_2288:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__ldir")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDB0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDIRX End | LIRX End
action_2289:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xEDB4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDISR End
action_2290:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xED90)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDIX End
action_2291:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xEDA4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP HL Comma LParen HL RParen End
action_2292:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED6C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP HL Comma LParen IX RParen End
action_2293:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDD6C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP HL Comma LParen IY RParen End
action_2294:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFD6C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP HL Comma expr End
action_2295:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xED6D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP IX Comma expr End
action_2296:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xDD6D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP IY Comma expr End
action_2297:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xFD6D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP LParen HL RParen Comma HL End
action_2298:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED64)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP LParen IX RParen Comma HL End
action_2299:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDD64)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP LParen IY RParen Comma HL End
action_2300:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFD64)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP expr Comma HL End
action_2301:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xED65)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP expr Comma IX End
action_2302:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xDD65)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDP expr Comma IY End
action_2303:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_nn(0xFD65)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDPIRX End | LPRX End
action_2304:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xEDB7)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LDWS End
action_2305:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xEDA5)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LHLD expr End
action_2306:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LSDDR End
action_2307:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xEDD8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LSDR End
action_2308:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xEDF8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LSIDR End
action_2309:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xEDD0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LSIR End
action_2310:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xEDF0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: LXI B Comma expr End | LXI BC Comma expr End
action_2311:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x01)*/;
return true;

// action for: LXI D Comma expr End | LXI DE Comma expr End
action_2312:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x11)*/;
return true;

// action for: LXI H Comma expr End | LXI HL Comma expr End
action_2313:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x21)*/;
return true;

// action for: LXI SP Comma expr End
action_2314:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x31)*/;
return true;

// action for: MIRR A End | MIRROR A End
action_2315:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED24)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MLT BC End
action_2316:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED4C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MLT DE End
action_2317:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED30)*/;
break;
case CPU_Z180: 
/*DO_stmt(0xED5C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MLT HL End
action_2318:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED6C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MLT SP End
action_2319:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED7C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU const_expr Comma A End
action_2320:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_STMT_LABEL();
if (expr_error) { error_expected_const_expr(); } else {
if (expr_value < 0 || expr_value > 7) error_int_range(expr_value);
DO_stmt(0xED9250 + expr_value);}*/
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU const_expr Comma expr End
action_2321:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_STMT_LABEL();
if (expr_error) { error_expected_const_expr(); } else {
if (expr_value < 0 || expr_value > 7) error_int_range(expr_value);
DO_stmt_n(0xED9150 + expr_value);}*/
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU0 A End
action_2322:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED9250)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU0 expr End
action_2323:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED9150)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU1 A End
action_2324:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED9251)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU1 expr End
action_2325:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED9151)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU2 A End
action_2326:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED9252)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU2 expr End
action_2327:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED9152)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU3 A End
action_2328:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED9253)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU3 expr End
action_2329:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED9153)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU4 A End
action_2330:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED9254)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU4 expr End
action_2331:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED9154)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU5 A End
action_2332:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED9255)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU5 expr End
action_2333:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED9155)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU6 A End
action_2334:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED9256)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU6 expr End
action_2335:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED9156)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU7 A End
action_2336:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED9257)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MMU7 expr End
action_2337:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED9157)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MUL D Comma E End | MUL DE End
action_2338:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED30)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MUL End
action_2339:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xF7)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: MVI A Comma expr End
action_2340:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0x3E)*/;
return true;

// action for: NEG A End | NEG End
action_2341:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_stmt(0x2F3C)*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED44)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: NEXTREG expr Comma A End | NREG expr Comma A End
action_2342:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED92)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: NEXTREG expr Comma expr End | NREG expr Comma expr End
action_2343:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n_n(0xED91)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: NOP End
action_2344:
/*DO_stmt(0x00)*/;
return true;

// action for: OR A Comma A End | OR A End | ORA A End
action_2345:
/*DO_stmt(0xB7)*/;
return true;

// action for: OR A Comma B End | OR B End | ORA B End
action_2346:
/*DO_stmt(0xB0)*/;
return true;

// action for: OR A Comma C End | OR C End | ORA C End
action_2347:
/*DO_stmt(0xB1)*/;
return true;

// action for: OR A Comma D End | OR D End | ORA D End
action_2348:
/*DO_stmt(0xB2)*/;
return true;

// action for: OR A Comma E End | OR E End | ORA E End
action_2349:
/*DO_stmt(0xB3)*/;
return true;

// action for: OR A Comma H End | OR H End | ORA H End
action_2350:
/*DO_stmt(0xB4)*/;
return true;

// action for: OR A Comma IXH End | OR IXH End
action_2351:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDB4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR A Comma IXL End | OR IXL End
action_2352:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDB5)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR A Comma IYH End | OR IYH End
action_2353:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDB4)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR A Comma IYL End | OR IYL End
action_2354:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDB5)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR A Comma L End | OR L End | ORA L End
action_2355:
/*DO_stmt(0xB5)*/;
return true;

// action for: OR A Comma LParen HL Minus RParen End | OR LParen HL Minus RParen End
action_2356:
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: OR A Comma LParen HL Plus RParen End | OR LParen HL Plus RParen End
action_2357:
/*DO_stmt(0xB6)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: OR A Comma LParen HL RParen End | OR LParen HL RParen End | ORA M End
action_2358:
/*DO_stmt(0xB6)*/;
return true;

// action for: OR A Comma LParen IX RParen End | OR LParen IX RParen End
action_2359:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR A Comma LParen IX expr RParen End | OR LParen IX expr RParen End
action_2360:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR A Comma LParen IY RParen End | OR LParen IY RParen End
action_2361:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDB600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR A Comma LParen IY expr RParen End | OR LParen IY expr RParen End
action_2362:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDB6)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR A Comma expr End | OR expr End | ORI expr End
action_2363:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xF6)*/;
return true;

// action for: OR HL Comma DE End
action_2364:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xEC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR IX Comma DE End
action_2365:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDDEC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OR IY Comma DE End
action_2366:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFDEC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OTDM End
action_2367:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED8B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OTDMR End
action_2368:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED9B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OTDR End
action_2369:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDBB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OTIB End | OUTINB End
action_2370:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED90)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OTIM End
action_2371:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED83)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OTIMR End
action_2372:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED93)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OTIR End
action_2373:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDB3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT LParen C RParen Comma A End
action_2374:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED79)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT LParen C RParen Comma B End
action_2375:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED41)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT LParen C RParen Comma C End
action_2376:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED49)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT LParen C RParen Comma D End
action_2377:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED51)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT LParen C RParen Comma E End
action_2378:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED59)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT LParen C RParen Comma F End
action_2379:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED71)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT LParen C RParen Comma H End
action_2380:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED61)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT LParen C RParen Comma L End
action_2381:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED69)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT LParen C RParen Comma const_expr End
action_2382:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xED00+((0x41+expr_value+6*8)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT expr Comma A End
action_2383:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xD3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT expr End
action_2384:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xD3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT0 expr Comma A End
action_2385:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED39)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT0 expr Comma B End
action_2386:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED01)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT0 expr Comma C End
action_2387:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED09)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT0 expr Comma D End
action_2388:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED11)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT0 expr Comma E End
action_2389:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT0 expr Comma H End
action_2390:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED21)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUT0 expr Comma L End
action_2391:
switch (option_cpu()) {
case CPU_Z180: 
/*if (!expr_in_parens) return false;*/
/*DO_stmt_n(0xED29)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUTD End
action_2392:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDAB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OUTI End
action_2393:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xEDA3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: OVRST8 End | RSTV End
action_2394:
switch (option_cpu()) {
case CPU_8085: 
/*DO_stmt(0xCB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: PIXELAD End | PXAD End
action_2395:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED94)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: PIXELDN End | PXDN End
action_2396:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED93)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: POP AF End | POP PSW End
action_2397:
/*DO_stmt(0xF1)*/;
return true;

// action for: POP B End | POP BC End
action_2398:
/*DO_stmt(0xC1)*/;
return true;

// action for: POP D End | POP DE End
action_2399:
/*DO_stmt(0xD1)*/;
return true;

// action for: POP H End | POP HL End
action_2400:
/*DO_stmt(0xE1)*/;
return true;

// action for: POP IP End
action_2401:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED7E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: POP IX End
action_2402:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDE1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: POP IY End
action_2403:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDE1)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: POP SU End
action_2404:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xED6E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: PUSH AF End | PUSH PSW End
action_2405:
/*DO_stmt(0xF5)*/;
return true;

// action for: PUSH B End | PUSH BC End
action_2406:
/*DO_stmt(0xC5)*/;
return true;

// action for: PUSH D End | PUSH DE End
action_2407:
/*DO_stmt(0xD5)*/;
return true;

// action for: PUSH H End | PUSH HL End
action_2408:
/*DO_stmt(0xE5)*/;
return true;

// action for: PUSH IP End
action_2409:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xED76)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: PUSH IX End
action_2410:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDE5)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: PUSH IY End
action_2411:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDE5)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: PUSH SU End
action_2412:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xED66)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: PUSH expr End
action_2413:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt_NN(0xED8A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RAL End | RLA End
action_2414:
/*DO_stmt(0x17)*/;
return true;

// action for: RAR End | RRA End
action_2415:
/*DO_stmt(0x1F)*/;
return true;

// action for: RC End | RET C End | R_C End
action_2416:
/*DO_stmt(0xD8)*/;
return true;

// action for: RDEL End | RL DE End | RLDE End
action_2417:
switch (option_cpu()) {
case CPU_8080: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__rl_de")*/;
break;
case CPU_8085: 
/*DO_stmt(0x18)*/;
break;
case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB13)*/;
/*DO_stmt(0xCB12)*/;
break;
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xF3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RDMODE End
action_2418:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xED7F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma A End
action_2419:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB87+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma B End
action_2420:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB80+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma C End
action_2421:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB81+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma D End
action_2422:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB82+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma E End
action_2423:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB83+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma H End
action_2424:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB84+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma L End
action_2425:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB85+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen HL RParen End
action_2426:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCB86+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX RParen Comma A End
action_2427:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0087+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX RParen Comma B End
action_2428:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0080+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX RParen Comma C End
action_2429:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0081+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX RParen Comma D End
action_2430:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0082+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX RParen Comma E End
action_2431:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0083+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX RParen Comma H End
action_2432:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0084+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX RParen Comma L End
action_2433:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0085+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX RParen End
action_2434:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB0086+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX expr RParen Comma A End
action_2435:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB87+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX expr RParen Comma B End
action_2436:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB80+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX expr RParen Comma C End
action_2437:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB81+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX expr RParen Comma D End
action_2438:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB82+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX expr RParen Comma E End
action_2439:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB83+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX expr RParen Comma H End
action_2440:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB84+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX expr RParen Comma L End
action_2441:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB85+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IX expr RParen End
action_2442:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCB86+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY RParen Comma A End
action_2443:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0087+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY RParen Comma B End
action_2444:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0080+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY RParen Comma C End
action_2445:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0081+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY RParen Comma D End
action_2446:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0082+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY RParen Comma E End
action_2447:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0083+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY RParen Comma H End
action_2448:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0084+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY RParen Comma L End
action_2449:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0085+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY RParen End
action_2450:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB0086+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY expr RParen Comma A End
action_2451:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB87+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY expr RParen Comma B End
action_2452:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB80+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY expr RParen Comma C End
action_2453:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB81+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY expr RParen Comma D End
action_2454:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB82+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY expr RParen Comma E End
action_2455:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB83+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY expr RParen Comma H End
action_2456:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB84+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY expr RParen Comma L End
action_2457:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB85+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RES const_expr Comma LParen IY expr RParen End
action_2458:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCB86+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RET LO End | RLO End | R_LO End
action_2459:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xE8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RET LZ End | RLZ End | R_LZ End
action_2460:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xE0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RET M End | RM End | R_M End
action_2461:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xF8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RET NC End | RNC End | R_NC End
action_2462:
/*DO_stmt(0xD0)*/;
return true;

// action for: RET NV End | RET PO End | RNV End | RPO End | R_NV End | R_PO End
action_2463:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xE0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RET NZ End | RNZ End | R_NZ End
action_2464:
/*DO_stmt(0xC0)*/;
return true;

// action for: RET P End | RP End | R_P End
action_2465:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xF0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RET PE End | RET V End | RPE End | RV End | R_PE End | R_V End
action_2466:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xE8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RET Z End | RZ End | R_Z End
action_2467:
/*DO_stmt(0xC8)*/;
return true;

// action for: RET End
action_2468:
/*DO_stmt(0xC9)*/;
return true;

// action for: RETI End
action_2469:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xD9)*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED4D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RETN End
action_2470:
switch (option_cpu()) {
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED45)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RIM End
action_2471:
switch (option_cpu()) {
case CPU_8085: 
/*DO_stmt(0x20)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL A End
action_2472:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB17)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL B End
action_2473:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB10)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL BC End
action_2474:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__rl_bc")*/;
break;
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB11)*/;
/*DO_stmt(0xCB10)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL C End
action_2475:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB11)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL D End
action_2476:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB12)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL E End
action_2477:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL H End
action_2478:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB14)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL HL End
action_2479:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__rl_hl")*/;
break;
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB15)*/;
/*DO_stmt(0xCB14)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL L End
action_2480:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB15)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen HL RParen End
action_2481:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX RParen Comma A End
action_2482:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0017)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX RParen Comma B End
action_2483:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0010)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX RParen Comma C End
action_2484:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0011)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX RParen Comma D End
action_2485:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0012)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX RParen Comma E End
action_2486:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0013)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX RParen Comma H End
action_2487:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0014)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX RParen Comma L End
action_2488:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0015)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX RParen End
action_2489:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX expr RParen Comma A End
action_2490:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB17)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX expr RParen Comma B End
action_2491:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB10)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX expr RParen Comma C End
action_2492:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB11)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX expr RParen Comma D End
action_2493:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB12)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX expr RParen Comma E End
action_2494:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX expr RParen Comma H End
action_2495:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB14)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX expr RParen Comma L End
action_2496:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB15)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IX expr RParen End
action_2497:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY RParen Comma A End
action_2498:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0017)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY RParen Comma B End
action_2499:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0010)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY RParen Comma C End
action_2500:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0011)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY RParen Comma D End
action_2501:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0012)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY RParen Comma E End
action_2502:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0013)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY RParen Comma H End
action_2503:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0014)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY RParen Comma L End
action_2504:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0015)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY RParen End
action_2505:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0016)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY expr RParen Comma A End
action_2506:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB17)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY expr RParen Comma B End
action_2507:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB10)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY expr RParen Comma C End
action_2508:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB11)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY expr RParen Comma D End
action_2509:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB12)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY expr RParen Comma E End
action_2510:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB13)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY expr RParen Comma H End
action_2511:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB14)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY expr RParen Comma L End
action_2512:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB15)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RL LParen IY expr RParen End
action_2513:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB16)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC A End
action_2514:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB07)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC B End
action_2515:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC C End
action_2516:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB01)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC D End
action_2517:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB02)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC E End
action_2518:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC H End
action_2519:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB04)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC L End
action_2520:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB05)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC End | RLCA End
action_2521:
/*DO_stmt(0x07)*/;
return true;

// action for: RLC LParen HL RParen End
action_2522:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX RParen Comma A End
action_2523:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0007)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX RParen Comma B End
action_2524:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0000)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX RParen Comma C End
action_2525:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0001)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX RParen Comma D End
action_2526:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0002)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX RParen Comma E End
action_2527:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0003)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX RParen Comma H End
action_2528:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0004)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX RParen Comma L End
action_2529:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0005)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX RParen End
action_2530:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX expr RParen Comma A End
action_2531:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB07)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX expr RParen Comma B End
action_2532:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX expr RParen Comma C End
action_2533:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB01)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX expr RParen Comma D End
action_2534:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB02)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX expr RParen Comma E End
action_2535:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX expr RParen Comma H End
action_2536:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB04)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX expr RParen Comma L End
action_2537:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB05)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IX expr RParen End
action_2538:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY RParen Comma A End
action_2539:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0007)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY RParen Comma B End
action_2540:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0000)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY RParen Comma C End
action_2541:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0001)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY RParen Comma D End
action_2542:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0002)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY RParen Comma E End
action_2543:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0003)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY RParen Comma H End
action_2544:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0004)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY RParen Comma L End
action_2545:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0005)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY RParen End
action_2546:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0006)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY expr RParen Comma A End
action_2547:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB07)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY expr RParen Comma B End
action_2548:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY expr RParen Comma C End
action_2549:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB01)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY expr RParen Comma D End
action_2550:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB02)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY expr RParen Comma E End
action_2551:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB03)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY expr RParen Comma H End
action_2552:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB04)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY expr RParen Comma L End
action_2553:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB05)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLC LParen IY expr RParen End
action_2554:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB06)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RLD End
action_2555:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__rld")*/;
break;
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED6F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR A End
action_2556:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB1F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR B End
action_2557:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB18)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR BC End
action_2558:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__rr_bc")*/;
break;
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB18)*/;
/*DO_stmt(0xCB19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR C End
action_2559:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR D End
action_2560:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR DE End
action_2561:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__rr_de")*/;
break;
case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB1A)*/;
/*DO_stmt(0xCB1B)*/;
break;
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFB)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR E End
action_2562:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR H End
action_2563:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB1C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR HL End
action_2564:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__rr_hl")*/;
break;
case CPU_GBZ80: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB1C)*/;
/*DO_stmt(0xCB1D)*/;
break;
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR IX End
action_2565:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xDDFC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR IY End
action_2566:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: 
/*DO_stmt(0xFDFC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR L End
action_2567:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB1D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen HL RParen End
action_2568:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX RParen Comma A End
action_2569:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB001F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX RParen Comma B End
action_2570:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0018)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX RParen Comma C End
action_2571:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0019)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX RParen Comma D End
action_2572:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB001A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX RParen Comma E End
action_2573:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB001B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX RParen Comma H End
action_2574:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB001C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX RParen Comma L End
action_2575:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB001D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX RParen End
action_2576:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX expr RParen Comma A End
action_2577:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB1F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX expr RParen Comma B End
action_2578:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB18)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX expr RParen Comma C End
action_2579:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX expr RParen Comma D End
action_2580:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX expr RParen Comma E End
action_2581:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX expr RParen Comma H End
action_2582:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB1C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX expr RParen Comma L End
action_2583:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB1D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IX expr RParen End
action_2584:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY RParen Comma A End
action_2585:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB001F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY RParen Comma B End
action_2586:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0018)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY RParen Comma C End
action_2587:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0019)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY RParen Comma D End
action_2588:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB001A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY RParen Comma E End
action_2589:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB001B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY RParen Comma H End
action_2590:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB001C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY RParen Comma L End
action_2591:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB001D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY RParen End
action_2592:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB001E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY expr RParen Comma A End
action_2593:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB1F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY expr RParen Comma B End
action_2594:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB18)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY expr RParen Comma C End
action_2595:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY expr RParen Comma D End
action_2596:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB1A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY expr RParen Comma E End
action_2597:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY expr RParen Comma H End
action_2598:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB1C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY expr RParen Comma L End
action_2599:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB1D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RR LParen IY expr RParen End
action_2600:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB1E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC A End
action_2601:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB0F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC B End
action_2602:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB08)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC C End
action_2603:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB09)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC D End
action_2604:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC E End
action_2605:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC H End
action_2606:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB0C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC L End
action_2607:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB0D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC End | RRCA End
action_2608:
/*DO_stmt(0x0F)*/;
return true;

// action for: RRC LParen HL RParen End
action_2609:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX RParen Comma A End
action_2610:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB000F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX RParen Comma B End
action_2611:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0008)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX RParen Comma C End
action_2612:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0009)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX RParen Comma D End
action_2613:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB000A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX RParen Comma E End
action_2614:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB000B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX RParen Comma H End
action_2615:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB000C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX RParen Comma L End
action_2616:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB000D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX RParen End
action_2617:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX expr RParen Comma A End
action_2618:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB0F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX expr RParen Comma B End
action_2619:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB08)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX expr RParen Comma C End
action_2620:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB09)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX expr RParen Comma D End
action_2621:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX expr RParen Comma E End
action_2622:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX expr RParen Comma H End
action_2623:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB0C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX expr RParen Comma L End
action_2624:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB0D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IX expr RParen End
action_2625:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY RParen Comma A End
action_2626:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB000F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY RParen Comma B End
action_2627:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0008)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY RParen Comma C End
action_2628:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0009)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY RParen Comma D End
action_2629:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB000A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY RParen Comma E End
action_2630:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB000B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY RParen Comma H End
action_2631:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB000C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY RParen Comma L End
action_2632:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB000D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY RParen End
action_2633:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB000E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY expr RParen Comma A End
action_2634:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB0F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY expr RParen Comma B End
action_2635:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB08)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY expr RParen Comma C End
action_2636:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB09)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY expr RParen Comma D End
action_2637:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB0A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY expr RParen Comma E End
action_2638:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB0B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY expr RParen Comma H End
action_2639:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB0C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY expr RParen Comma L End
action_2640:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB0D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRC LParen IY expr RParen End
action_2641:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB0E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RRD End
action_2642:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__rrd")*/;
break;
case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED67)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: RST const_expr End
action_2643:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_STMT_LABEL();
if (expr_error) { error_expected_const_expr(); } else {
if (expr_value > 0 && expr_value < 8) expr_value *= 8;
switch (expr_value) {
case 0x00: case 0x08: case 0x30:
  if (option_cpu() & CPU_RABBIT)
    DO_stmt(0xCD0000 + (expr_value << 8));
  else
    DO_stmt(0xC7 + expr_value);
  break;
case 0x10: case 0x18: case 0x20: case 0x28: case 0x38:
  DO_stmt(0xC7 + expr_value); break;
default: error_int_range(expr_value);
}}*/
return true;

// action for: SBB A End | SBC A Comma A End | SBC A End
action_2644:
/*DO_stmt(0x9F)*/;
return true;

// action for: SBB B End | SBC A Comma B End | SBC B End
action_2645:
/*DO_stmt(0x98)*/;
return true;

// action for: SBB C End | SBC A Comma C End | SBC C End
action_2646:
/*DO_stmt(0x99)*/;
return true;

// action for: SBB D End | SBC A Comma D End | SBC D End
action_2647:
/*DO_stmt(0x9A)*/;
return true;

// action for: SBB E End | SBC A Comma E End | SBC E End
action_2648:
/*DO_stmt(0x9B)*/;
return true;

// action for: SBB H End | SBC A Comma H End | SBC H End
action_2649:
/*DO_stmt(0x9C)*/;
return true;

// action for: SBB L End | SBC A Comma L End | SBC L End
action_2650:
/*DO_stmt(0x9D)*/;
return true;

// action for: SBB M End | SBC A Comma LParen HL RParen End | SBC LParen HL RParen End
action_2651:
/*DO_stmt(0x9E)*/;
return true;

// action for: SBC A Comma IXH End | SBC IXH End
action_2652:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD9C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC A Comma IXL End | SBC IXL End
action_2653:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD9D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC A Comma IYH End | SBC IYH End
action_2654:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD9C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC A Comma IYL End | SBC IYL End
action_2655:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD9D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC A Comma LParen HL Minus RParen End | SBC LParen HL Minus RParen End
action_2656:
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: SBC A Comma LParen HL Plus RParen End | SBC LParen HL Plus RParen End
action_2657:
/*DO_stmt(0x9E)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: SBC A Comma LParen IX RParen End | SBC LParen IX RParen End
action_2658:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC A Comma LParen IX expr RParen End | SBC LParen IX expr RParen End
action_2659:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC A Comma LParen IY RParen End | SBC LParen IY RParen End
action_2660:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD9E00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC A Comma LParen IY expr RParen End | SBC LParen IY expr RParen End
action_2661:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD9E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC A Comma expr End | SBC expr End | SBI expr End
action_2662:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xDE)*/;
return true;

// action for: SBC HL Comma BC End
action_2663:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sbc_hl_bc")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED42)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC HL Comma DE End
action_2664:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sbc_hl_de")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED52)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC HL Comma HL End
action_2665:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sbc_hl_hl")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED62)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SBC HL Comma SP End
action_2666:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_GBZ80: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sbc_hl_sp")*/;
break;
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xED72)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SCF End | STC End
action_2667:
/*DO_stmt(0x37)*/;
return true;

// action for: SET const_expr Comma A End
action_2668:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC7+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma B End
action_2669:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC0+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma C End
action_2670:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC1+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma D End
action_2671:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC2+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma E End
action_2672:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC3+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma H End
action_2673:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC4+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma L End
action_2674:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC5+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen HL RParen End
action_2675:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xCBC6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX RParen Comma A End
action_2676:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C7+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX RParen Comma B End
action_2677:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C0+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX RParen Comma C End
action_2678:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C1+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX RParen Comma D End
action_2679:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C2+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX RParen Comma E End
action_2680:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C3+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX RParen Comma H End
action_2681:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C4+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX RParen Comma L End
action_2682:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C5+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX RParen End
action_2683:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xDDCB00C6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX expr RParen Comma A End
action_2684:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC7+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX expr RParen Comma B End
action_2685:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC0+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX expr RParen Comma C End
action_2686:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC1+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX expr RParen Comma D End
action_2687:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC2+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX expr RParen Comma E End
action_2688:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC3+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX expr RParen Comma H End
action_2689:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC4+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX expr RParen Comma L End
action_2690:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC5+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IX expr RParen End
action_2691:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xDDCBC6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY RParen Comma A End
action_2692:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C7+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY RParen Comma B End
action_2693:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C0+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY RParen Comma C End
action_2694:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C1+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY RParen Comma D End
action_2695:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C2+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY RParen Comma E End
action_2696:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C3+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY RParen Comma H End
action_2697:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C4+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY RParen Comma L End
action_2698:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C5+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY RParen End
action_2699:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt(0xFDCB00C6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY expr RParen Comma A End
action_2700:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC7+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY expr RParen Comma B End
action_2701:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC0+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY expr RParen Comma C End
action_2702:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC1+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY expr RParen Comma D End
action_2703:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC2+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY expr RParen Comma E End
action_2704:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC3+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY expr RParen Comma H End
action_2705:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC4+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY expr RParen Comma L End
action_2706:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC5+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SET const_expr Comma LParen IY expr RParen End
action_2707:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*if (expr_error) { error_expected_const_expr(); } else {
switch (expr_value) {
case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: break;
default: error_int_range(expr_value);
}}*/
/*DO_stmt_idx(0xFDCBC6+((8*expr_value)))*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SETAE End | STAE End
action_2708:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED95)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SETUSR End
action_2709:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xED6F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SHLD expr End
action_2710:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SIM End
action_2711:
switch (option_cpu()) {
case CPU_8085: 
/*DO_stmt(0x30)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA A End
action_2712:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB27)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA B End
action_2713:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB20)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA C End
action_2714:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB21)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA D End
action_2715:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA E End
action_2716:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA H End
action_2717:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB24)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA L End
action_2718:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB25)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen HL RParen End
action_2719:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX RParen Comma A End
action_2720:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0027)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX RParen Comma B End
action_2721:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0020)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX RParen Comma C End
action_2722:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0021)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX RParen Comma D End
action_2723:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0022)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX RParen Comma E End
action_2724:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0023)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX RParen Comma H End
action_2725:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0024)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX RParen Comma L End
action_2726:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0025)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX RParen End
action_2727:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX expr RParen Comma A End
action_2728:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB27)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX expr RParen Comma B End
action_2729:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB20)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX expr RParen Comma C End
action_2730:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB21)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX expr RParen Comma D End
action_2731:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX expr RParen Comma E End
action_2732:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX expr RParen Comma H End
action_2733:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB24)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX expr RParen Comma L End
action_2734:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB25)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IX expr RParen End
action_2735:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY RParen Comma A End
action_2736:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0027)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY RParen Comma B End
action_2737:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0020)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY RParen Comma C End
action_2738:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0021)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY RParen Comma D End
action_2739:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0022)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY RParen Comma E End
action_2740:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0023)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY RParen Comma H End
action_2741:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0024)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY RParen Comma L End
action_2742:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0025)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY RParen End
action_2743:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0026)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY expr RParen Comma A End
action_2744:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB27)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY expr RParen Comma B End
action_2745:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB20)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY expr RParen Comma C End
action_2746:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB21)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY expr RParen Comma D End
action_2747:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB22)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY expr RParen Comma E End
action_2748:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY expr RParen Comma H End
action_2749:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB24)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY expr RParen Comma L End
action_2750:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB25)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLA LParen IY expr RParen End
action_2751:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB26)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI A End | SLL A End | SLS A End
action_2752:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB37)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI B End | SLL B End | SLS B End
action_2753:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB30)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI C End | SLL C End | SLS C End
action_2754:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB31)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI D End | SLL D End | SLS D End
action_2755:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB32)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI E End | SLL E End | SLS E End
action_2756:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB33)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI H End | SLL H End | SLS H End
action_2757:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI L End | SLL L End | SLS L End
action_2758:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen HL RParen End | SLL LParen HL RParen End | SLS LParen HL RParen End
action_2759:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX RParen Comma A End | SLL LParen IX RParen Comma A End | SLS LParen IX RParen Comma A End
action_2760:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0037)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX RParen Comma B End | SLL LParen IX RParen Comma B End | SLS LParen IX RParen Comma B End
action_2761:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0030)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX RParen Comma C End | SLL LParen IX RParen Comma C End | SLS LParen IX RParen Comma C End
action_2762:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0031)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX RParen Comma D End | SLL LParen IX RParen Comma D End | SLS LParen IX RParen Comma D End
action_2763:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0032)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX RParen Comma E End | SLL LParen IX RParen Comma E End | SLS LParen IX RParen Comma E End
action_2764:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0033)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX RParen Comma H End | SLL LParen IX RParen Comma H End | SLS LParen IX RParen Comma H End
action_2765:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0034)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX RParen Comma L End | SLL LParen IX RParen Comma L End | SLS LParen IX RParen Comma L End
action_2766:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0035)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX RParen End | SLL LParen IX RParen End | SLS LParen IX RParen End
action_2767:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0036)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX expr RParen Comma A End | SLL LParen IX expr RParen Comma A End | SLS LParen IX expr RParen Comma A End
action_2768:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB37)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX expr RParen Comma B End | SLL LParen IX expr RParen Comma B End | SLS LParen IX expr RParen Comma B End
action_2769:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB30)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX expr RParen Comma C End | SLL LParen IX expr RParen Comma C End | SLS LParen IX expr RParen Comma C End
action_2770:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB31)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX expr RParen Comma D End | SLL LParen IX expr RParen Comma D End | SLS LParen IX expr RParen Comma D End
action_2771:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB32)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX expr RParen Comma E End | SLL LParen IX expr RParen Comma E End | SLS LParen IX expr RParen Comma E End
action_2772:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB33)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX expr RParen Comma H End | SLL LParen IX expr RParen Comma H End | SLS LParen IX expr RParen Comma H End
action_2773:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX expr RParen Comma L End | SLL LParen IX expr RParen Comma L End | SLS LParen IX expr RParen Comma L End
action_2774:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IX expr RParen End | SLL LParen IX expr RParen End | SLS LParen IX expr RParen End
action_2775:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY RParen Comma A End | SLL LParen IY RParen Comma A End | SLS LParen IY RParen Comma A End
action_2776:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0037)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY RParen Comma B End | SLL LParen IY RParen Comma B End | SLS LParen IY RParen Comma B End
action_2777:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0030)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY RParen Comma C End | SLL LParen IY RParen Comma C End | SLS LParen IY RParen Comma C End
action_2778:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0031)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY RParen Comma D End | SLL LParen IY RParen Comma D End | SLS LParen IY RParen Comma D End
action_2779:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0032)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY RParen Comma E End | SLL LParen IY RParen Comma E End | SLS LParen IY RParen Comma E End
action_2780:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0033)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY RParen Comma H End | SLL LParen IY RParen Comma H End | SLS LParen IY RParen Comma H End
action_2781:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0034)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY RParen Comma L End | SLL LParen IY RParen Comma L End | SLS LParen IY RParen Comma L End
action_2782:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0035)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY RParen End | SLL LParen IY RParen End | SLS LParen IY RParen End
action_2783:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0036)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY expr RParen Comma A End | SLL LParen IY expr RParen Comma A End | SLS LParen IY expr RParen Comma A End
action_2784:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB37)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY expr RParen Comma B End | SLL LParen IY expr RParen Comma B End | SLS LParen IY expr RParen Comma B End
action_2785:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB30)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY expr RParen Comma C End | SLL LParen IY expr RParen Comma C End | SLS LParen IY expr RParen Comma C End
action_2786:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB31)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY expr RParen Comma D End | SLL LParen IY expr RParen Comma D End | SLS LParen IY expr RParen Comma D End
action_2787:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB32)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY expr RParen Comma E End | SLL LParen IY expr RParen Comma E End | SLS LParen IY expr RParen Comma E End
action_2788:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB33)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY expr RParen Comma H End | SLL LParen IY expr RParen Comma H End | SLS LParen IY expr RParen Comma H End
action_2789:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY expr RParen Comma L End | SLL LParen IY expr RParen Comma L End | SLS LParen IY expr RParen Comma L End
action_2790:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLI LParen IY expr RParen End | SLL LParen IY expr RParen End | SLS LParen IY expr RParen End
action_2791:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SLP End
action_2792:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED76)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA A End
action_2793:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB2F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA B End
action_2794:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB28)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA BC End
action_2795:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sra_bc")*/;
break;
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB28)*/;
/*DO_stmt(0xCB19)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA C End
action_2796:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB29)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA D End
action_2797:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA DE End
action_2798:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: 
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sra_de")*/;
break;
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB2A)*/;
/*DO_stmt(0xCB1B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA E End
action_2799:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA H End
action_2800:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB2C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA L End
action_2801:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB2D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen HL RParen End
action_2802:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX RParen Comma A End
action_2803:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB002F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX RParen Comma B End
action_2804:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0028)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX RParen Comma C End
action_2805:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0029)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX RParen Comma D End
action_2806:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB002A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX RParen Comma E End
action_2807:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB002B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX RParen Comma H End
action_2808:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB002C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX RParen Comma L End
action_2809:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB002D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX RParen End
action_2810:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX expr RParen Comma A End
action_2811:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB2F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX expr RParen Comma B End
action_2812:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB28)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX expr RParen Comma C End
action_2813:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB29)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX expr RParen Comma D End
action_2814:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX expr RParen Comma E End
action_2815:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX expr RParen Comma H End
action_2816:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB2C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX expr RParen Comma L End
action_2817:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB2D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IX expr RParen End
action_2818:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY RParen Comma A End
action_2819:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB002F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY RParen Comma B End
action_2820:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0028)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY RParen Comma C End
action_2821:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0029)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY RParen Comma D End
action_2822:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB002A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY RParen Comma E End
action_2823:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB002B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY RParen Comma H End
action_2824:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB002C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY RParen Comma L End
action_2825:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB002D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY RParen End
action_2826:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB002E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY expr RParen Comma A End
action_2827:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB2F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY expr RParen Comma B End
action_2828:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB28)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY expr RParen Comma C End
action_2829:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB29)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY expr RParen Comma D End
action_2830:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB2A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY expr RParen Comma E End
action_2831:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB2B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY expr RParen Comma H End
action_2832:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB2C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY expr RParen Comma L End
action_2833:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB2D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRA LParen IY expr RParen End
action_2834:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB2E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL A End
action_2835:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB3F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL B End
action_2836:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB38)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL C End
action_2837:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB39)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL D End
action_2838:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL E End
action_2839:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB3B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL H End
action_2840:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB3C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL L End
action_2841:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB3D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen HL RParen End
action_2842:
switch (option_cpu()) {
case CPU_GBZ80: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX RParen Comma A End
action_2843:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB003F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX RParen Comma B End
action_2844:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0038)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX RParen Comma C End
action_2845:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB0039)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX RParen Comma D End
action_2846:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB003A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX RParen Comma E End
action_2847:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB003B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX RParen Comma H End
action_2848:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB003C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX RParen Comma L End
action_2849:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB003D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX RParen End
action_2850:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX expr RParen Comma A End
action_2851:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB3F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX expr RParen Comma B End
action_2852:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB38)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX expr RParen Comma C End
action_2853:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB39)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX expr RParen Comma D End
action_2854:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX expr RParen Comma E End
action_2855:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB3B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX expr RParen Comma H End
action_2856:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB3C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX expr RParen Comma L End
action_2857:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB3D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IX expr RParen End
action_2858:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY RParen Comma A End
action_2859:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB003F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY RParen Comma B End
action_2860:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0038)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY RParen Comma C End
action_2861:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB0039)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY RParen Comma D End
action_2862:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB003A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY RParen Comma E End
action_2863:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB003B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY RParen Comma H End
action_2864:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB003C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY RParen Comma L End
action_2865:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB003D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY RParen End
action_2866:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDCB003E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY expr RParen Comma A End
action_2867:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB3F)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY expr RParen Comma B End
action_2868:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB38)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY expr RParen Comma C End
action_2869:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB39)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY expr RParen Comma D End
action_2870:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB3A)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY expr RParen Comma E End
action_2871:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB3B)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY expr RParen Comma H End
action_2872:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB3C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY expr RParen Comma L End
action_2873:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB3D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SRL LParen IY expr RParen End
action_2874:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDCB3E)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: STA expr End
action_2875:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0x32)*/;
break;
case CPU_GBZ80: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_nn(0xEA)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: STOP End
action_2876:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0x1000)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SUB A Comma A End | SUB A End
action_2877:
/*DO_stmt(0x97)*/;
return true;

// action for: SUB A Comma B End | SUB B End
action_2878:
/*DO_stmt(0x90)*/;
return true;

// action for: SUB A Comma C End | SUB C End
action_2879:
/*DO_stmt(0x91)*/;
return true;

// action for: SUB A Comma D End | SUB D End
action_2880:
/*DO_stmt(0x92)*/;
return true;

// action for: SUB A Comma E End | SUB E End
action_2881:
/*DO_stmt(0x93)*/;
return true;

// action for: SUB A Comma H End | SUB H End
action_2882:
/*DO_stmt(0x94)*/;
return true;

// action for: SUB A Comma IXH End | SUB IXH End
action_2883:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD94)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SUB A Comma IXL End | SUB IXL End
action_2884:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD95)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SUB A Comma IYH End | SUB IYH End
action_2885:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD94)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SUB A Comma IYL End | SUB IYL End
action_2886:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD95)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SUB A Comma L End | SUB L End
action_2887:
/*DO_stmt(0x95)*/;
return true;

// action for: SUB A Comma LParen HL Minus RParen End | SUB LParen HL Minus RParen End
action_2888:
/*DO_stmt(0x96)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: SUB A Comma LParen HL Plus RParen End | SUB LParen HL Plus RParen End
action_2889:
/*DO_stmt(0x96)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: SUB A Comma LParen HL RParen End | SUB M End | SUB LParen HL RParen End
action_2890:
/*DO_stmt(0x96)*/;
return true;

// action for: SUB A Comma LParen IX RParen End | SUB LParen IX RParen End
action_2891:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SUB A Comma LParen IX expr RParen End | SUB LParen IX expr RParen End
action_2892:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SUB A Comma LParen IY RParen End | SUB LParen IY RParen End
action_2893:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFD9600)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SUB A Comma LParen IY expr RParen End | SUB LParen IY expr RParen End
action_2894:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFD96)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SUB A Comma expr End | SUB expr End | SUI expr End
action_2895:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xD6)*/;
return true;

// action for: SUB HL Comma DE End
action_2896:
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sub_hl_de")*/;
return true;

// action for: SUB HL Comma HL End
action_2897:
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sub_hl_hl")*/;
return true;

// action for: SUB HL Comma SP End
action_2898:
/*DO_STMT_LABEL();
add_call_emul_func("__z80asm__sub_hl_sp")*/;
return true;

// action for: SURES End
action_2899:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xED7D)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SWAP A End
action_2900:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xCB37)*/;
break;
case CPU_Z80N: 
/*DO_stmt(0xED23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SWAP B End
action_2901:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xCB30)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SWAP C End
action_2902:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xCB31)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SWAP D End
action_2903:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xCB32)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SWAP E End
action_2904:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xCB33)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SWAP H End
action_2905:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xCB34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SWAP L End
action_2906:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xCB35)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SWAP End | SWAPNIB End
action_2907:
switch (option_cpu()) {
case CPU_Z80N: 
/*DO_stmt(0xED23)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SWAP LParen HL RParen End
action_2908:
switch (option_cpu()) {
case CPU_GBZ80: 
/*DO_stmt(0xCB36)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: SYSCALL End
action_2909:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xED75)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TEST A Comma A End | TEST A End | TST A Comma A End | TST A End
action_2910:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED3C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TEST A Comma B End | TEST B End | TST A Comma B End | TST B End
action_2911:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED04)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TEST A Comma C End | TEST C End | TST A Comma C End | TST C End
action_2912:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED0C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TEST A Comma D End | TEST D End | TST A Comma D End | TST D End
action_2913:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED14)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TEST A Comma E End | TEST E End | TST A Comma E End | TST E End
action_2914:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED1C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TEST A Comma H End | TEST H End | TST A Comma H End | TST H End
action_2915:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED24)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TEST A Comma L End | TEST L End | TST A Comma L End | TST L End
action_2916:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED2C)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TEST A Comma LParen HL RParen End | TEST LParen HL RParen End | TST A Comma LParen HL RParen End | TST LParen HL RParen End
action_2917:
switch (option_cpu()) {
case CPU_Z180: 
/*DO_stmt(0xED34)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TEST A Comma expr End | TEST expr End | TST A Comma expr End | TST expr End
action_2918:
switch (option_cpu()) {
case CPU_Z80N: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED27)*/;
break;
case CPU_Z180: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED64)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: TSTIO expr End
action_2919:
switch (option_cpu()) {
case CPU_Z180: 
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xED74)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: UMA End
action_2920:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xEDC0)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: UMS End
action_2921:
switch (option_cpu()) {
case CPU_R3K: 
/*DO_stmt(0xEDC8)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: XOR A Comma A End | XOR A End | XRA A End
action_2922:
/*DO_stmt(0xAF)*/;
return true;

// action for: XOR A Comma B End | XOR B End | XRA B End
action_2923:
/*DO_stmt(0xA8)*/;
return true;

// action for: XOR A Comma C End | XOR C End | XRA C End
action_2924:
/*DO_stmt(0xA9)*/;
return true;

// action for: XOR A Comma D End | XOR D End | XRA D End
action_2925:
/*DO_stmt(0xAA)*/;
return true;

// action for: XOR A Comma E End | XOR E End | XRA E End
action_2926:
/*DO_stmt(0xAB)*/;
return true;

// action for: XOR A Comma H End | XOR H End | XRA H End
action_2927:
/*DO_stmt(0xAC)*/;
return true;

// action for: XOR A Comma IXH End | XOR IXH End
action_2928:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDAC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: XOR A Comma IXL End | XOR IXL End
action_2929:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDAD)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: XOR A Comma IYH End | XOR IYH End
action_2930:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDAC)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: XOR A Comma IYL End | XOR IYL End
action_2931:
switch (option_cpu()) {
case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDAD)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: XOR A Comma L End | XOR L End | XRA L End
action_2932:
/*DO_stmt(0xAD)*/;
return true;

// action for: XOR A Comma LParen HL Minus RParen End | XOR LParen HL Minus RParen End
action_2933:
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x2B)*/;
return true;

// action for: XOR A Comma LParen HL Plus RParen End | XOR LParen HL Plus RParen End
action_2934:
/*DO_stmt(0xAE)*/;
/*DO_stmt(0x23)*/;
return true;

// action for: XOR A Comma LParen HL RParen End | XOR LParen HL RParen End | XRA M End
action_2935:
/*DO_stmt(0xAE)*/;
return true;

// action for: XOR A Comma LParen IX RParen End | XOR LParen IX RParen End
action_2936:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xDDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: XOR A Comma LParen IX expr RParen End | XOR LParen IX expr RParen End
action_2937:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xDDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: XOR A Comma LParen IY RParen End | XOR LParen IY RParen End
action_2938:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xFDAE00)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: XOR A Comma LParen IY expr RParen End | XOR LParen IY expr RParen End
action_2939:
switch (option_cpu()) {
case CPU_R2KA: case CPU_R3K: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt_idx(0xFDAE)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

// action for: XOR A Comma expr End | XOR expr End | XRI expr End
action_2940:
/*if (expr_in_parens) warn_expr_in_parens();*/
/*DO_stmt_n(0xEE)*/;
return true;

// action for: XTHL End
action_2941:
switch (option_cpu()) {
case CPU_8080: case CPU_8085: case CPU_Z180: case CPU_Z80: case CPU_Z80N: 
/*DO_stmt(0xE3)*/;
break;
default: /*error_illegal_ident()*/; }
return true;

}
