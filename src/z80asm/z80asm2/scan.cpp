/* Generated by re2c 3.1 */
//-----------------------------------------------------------------------------
// z80asm - scanner
// Copyright (C) Paulo Custodio, 2011-2024
// License: The Artistic License 2.0, http://www.perlfoundation.org/artistic_license_2_0
//-----------------------------------------------------------------------------

#include "common.h"
#include "errors.h"
#include "scan.h"
#include "utils.h"
#include "xassert.h"
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <unordered_map>
using namespace std;

//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------

static int a2i(const char* start, const char* end, int base) {
    return (int)(strtol(string(start, end).c_str(), NULL, base));
}

static double a2f(const char* start, const char* end) {
    return atof(string(start, end).c_str());
}

static string str_swap_xy(string str) {
    for (auto& c : str) {
        switch (c) {
        case 'x': c = 'y'; break;
        case 'X': c = 'Y'; break;
        case 'y': c = 'x'; break;
        case 'Y': c = 'X'; break;
        default:;
        }
    }
    return str;
}

//-----------------------------------------------------------------------------

Keyword keyword_lookup(const string& text) {
    static unordered_map<string, Keyword> keywords = {
#define KW(id, text)    { text, id },
#include "scan.def"
    };

    auto it = keywords.find(str_tolower(text));
    if (it == keywords.end())
        return KW_NONE;
    else
        return it->second;
}

//-----------------------------------------------------------------------------

Token::Token(TkCode code, bool blank_before, int ivalue)
    : code_(code), ivalue_(ivalue), blank_before_(blank_before) {
}

Token::Token(TkCode code, bool blank_before, double fvalue)
    : code_(code), fvalue_(fvalue), blank_before_(blank_before) {
}

Token::Token(TkCode code, bool blank_before, const string& svalue)
    : code_(code), keyword_(keyword_lookup(svalue)), svalue_(svalue)
    , blank_before_(blank_before) {
}

TkCode Token::code() const { return code_; }
Keyword Token::keyword() const { return keyword_; }
int Token::ivalue() const { return ivalue_; }
double Token::fvalue() const { return fvalue_; }
string Token::svalue() const { return svalue_; }
bool Token::blank_before() const { return blank_before_; }

string Token::to_string() const {
    static const char* tokens[] = {
#define TK(id, text)     text,
#include "scan.def"
    };

    switch (code_) {
    case TK_IDENT:
        return svalue_;
    case TK_INTEGER:
        return std::to_string(ivalue_);
    case TK_FLOATING:
        return std::to_string(fvalue_);
    case TK_STRING:
        return c_string(svalue_);
    default:
        return tokens[(int)code_];
    }
}

string Token::to_string(const vector<Token>& tokens) {
    string out;
    for (auto& token : tokens) {
        string str = token.to_string();
        out = concat(out, str);
    }
    return out;
}

string Token::concat(const string& s1, const string& s2) {
    if (s1.empty() || s2.empty())
        return s1 + s2;
    else if (str_ends_with(s1, "##"))   // cpp-style concatenation
        return s1.substr(0, s1.length() - 2) + s2;
    else if (isspace(s1.back()) || isspace(s2.front()))
        return s1 + s2;
    else if (is_ident(s1.back()) && is_ident(s2.front()))
        return s1 + " " + s2;
    else if (s1.back() == '$' && isxdigit(s2.front()))
        return s1 + " " + s2;
    else if ((s1.back() == '%' || s1.back() == '@') &&
        (isdigit(s2.front()) || s2.front() == '"'))
        return s1 + " " + s2;
    else if ((s1.back() == '&' && s2.front() == '&') ||
        (s1.back() == '|' && s2.front() == '|') ||
        (s1.back() == '^' && s2.front() == '^') ||
        (s1.back() == '*' && s2.front() == '*') ||
        (s1.back() == '<' && (s2.front() == '=' || s2.front() == '<' || s2.front() == '>')) ||
        (s1.back() == '>' && (s2.front() == '=' || s2.front() == '>')) ||
        (s1.back() == '=' && s2.front() == '=') ||
        (s1.back() == '!' && s2.front() == '=') ||
        (s1.back() == '#' && s2.front() == '#'))
        return s1 + " " + s2;
    else
        return s1 + s2;
}

string Token::c_string(const string& text) {
    string out = "\"";
    for (auto c : text) {
        switch (c) {
        case '\a': out += "\\a"; break;
        case '\b': out += "\\b"; break;
        case '\f': out += "\\f"; break;
        case '\n': out += "\\n"; break;
        case '\r': out += "\\r"; break;
        case '\t': out += "\\t"; break;
        case '\v': out += "\\v"; break;
        case '\\': out += "\\\\"; break;
        case '"': out += "\\\""; break;
        default:
            if (c >= 0x20 && c < 0x7f)
                out.push_back(c);
            else if ((c & 0xff) < 8)
                out += "\\" + std::to_string(c & 0xff);		// \o
            else {
                std::ostringstream ss;
                ss << "\\x"
                    << std::setfill('0') << std::setw(2)
                    << std::hex << (c & 0xff);
                out += ss.str();
            }
        }
    }
    out += "\"";
    return out;
}

//-----------------------------------------------------------------------------

Lexer::Lexer(const string& text) {
    set_text(text);
}

void Lexer::clear() {
    tokens_.clear();
    pos_ = 0;
}

bool Lexer::set_text(const string& text) {
    clear();
    string str;
    int quote = 0;
    bool raw_strings = g_raw_strings;
    bool got_error = false;
    bool blank_before = false;
    const char* p = text.c_str();
    const char* p0 = p;
    const char* pstr = p;
    const char* marker = p;

main_loop:
    while (true) {
        p0 = p;

#define PUSH_TOKEN1(type)       do { tokens_.emplace_back(type, blank_before); \
                                     blank_before = false; } while (0)
#define PUSH_TOKEN2(type, arg)  do { tokens_.emplace_back(type, blank_before, arg); \
                                     blank_before = false; } while (0)
        
		{
			char yych;
			unsigned int yyaccept = 0;
			yych = *p;
			switch (yych) {
				case 0x00: goto yy1;
				case '\t':
				case '\n':
				case '\v':
				case '\f':
				case '\r':
				case ' ': goto yy4;
				case '!': goto yy6;
				case '"': goto yy8;
				case '#': goto yy9;
				case '$': goto yy11;
				case '%': goto yy13;
				case '&': goto yy15;
				case '\'': goto yy17;
				case '(': goto yy18;
				case ')': goto yy19;
				case '*': goto yy20;
				case '+': goto yy22;
				case ',': goto yy23;
				case '-': goto yy24;
				case '.': goto yy25;
				case '/': goto yy27;
				case '0': goto yy28;
				case '1': goto yy30;
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy32;
				case ':': goto yy33;
				case ';': goto yy34;
				case '<': goto yy35;
				case '=': goto yy37;
				case '>': goto yy39;
				case '?': goto yy41;
				case '@': goto yy42;
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy43;
				case '[': goto yy45;
				case '\\': goto yy46;
				case ']': goto yy47;
				case '^': goto yy48;
				case '{': goto yy50;
				case '|': goto yy51;
				case '}': goto yy53;
				case '~': goto yy54;
				default: goto yy2;
			}
yy1:
			++p;
			{ p--; goto end; }
yy2:
			++p;
yy3:
			{ g_asm.error(ErrInvalidChar, p0); got_error = true; goto end; }
yy4:
			yych = *++p;
			switch (yych) {
				case '\t':
				case '\n':
				case '\v':
				case '\f':
				case '\r':
				case ' ': goto yy4;
				default: goto yy5;
			}
yy5:
			{ blank_before = true; continue; }
yy6:
			yych = *++p;
			switch (yych) {
				case '=': goto yy55;
				default: goto yy7;
			}
yy7:
			{ PUSH_TOKEN1(TK_LOGNOT); continue; }
yy8:
			++p;
			{ quote = 2; pstr = p0; goto string_loop; }
yy9:
			yych = *++p;
			switch (yych) {
				case '#': goto yy56;
				default: goto yy10;
			}
yy10:
			{ PUSH_TOKEN1(TK_HASH); continue; }
yy11:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy57;
				default: goto yy12;
			}
yy12:
			{ PUSH_TOKEN1(TK_ASMPC); continue; }
yy13:
			yyaccept = 0;
			yych = *(marker = ++p);
			switch (yych) {
				case '"': goto yy59;
				case '0':
				case '1': goto yy61;
				default: goto yy14;
			}
yy14:
			{ PUSH_TOKEN1(TK_MOD); continue; }
yy15:
			yych = *++p;
			switch (yych) {
				case '&': goto yy63;
				default: goto yy16;
			}
yy16:
			{ PUSH_TOKEN1(TK_BINAND); continue; }
yy17:
			++p;
			{ quote = 1; pstr = p0; goto string_loop; }
yy18:
			++p;
			{ PUSH_TOKEN1(TK_LPAREN); continue; }
yy19:
			++p;
			{ PUSH_TOKEN1(TK_RPAREN); continue; }
yy20:
			yych = *++p;
			switch (yych) {
				case '*': goto yy64;
				default: goto yy21;
			}
yy21:
			{ PUSH_TOKEN1(TK_MULT); continue; }
yy22:
			++p;
			{ PUSH_TOKEN1(TK_PLUS); continue; }
yy23:
			++p;
			{ PUSH_TOKEN1(TK_COMMA); continue; }
yy24:
			++p;
			{ PUSH_TOKEN1(TK_MINUS); continue; }
yy25:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy65;
				default: goto yy26;
			}
yy26:
			{ PUSH_TOKEN1(TK_DOT); continue; }
yy27:
			++p;
			{ PUSH_TOKEN1(TK_DIV); continue; }
yy28:
			yyaccept = 1;
			yych = *(marker = ++p);
			switch (yych) {
				case 'B':
				case 'b': goto yy68;
				case 'X':
				case 'x': goto yy72;
				default: goto yy31;
			}
yy29:
			{ PUSH_TOKEN2(TK_INTEGER, a2i(p0, p, 10)); continue; }
yy30:
			yyaccept = 1;
			yych = *(marker = ++p);
yy31:
			switch (yych) {
				case '.': goto yy65;
				case '0':
				case '1': goto yy30;
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy32;
				case 'A':
				case 'C':
				case 'E':
				case 'F':
				case 'a':
				case 'c':
				case 'e':
				case 'f': goto yy67;
				case 'B':
				case 'b': goto yy73;
				case 'D':
				case 'd': goto yy70;
				case 'H':
				case 'h': goto yy71;
				default: goto yy29;
			}
yy32:
			yyaccept = 1;
			yych = *(marker = ++p);
			switch (yych) {
				case '.': goto yy65;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy32;
				case 'A':
				case 'B':
				case 'C':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'e':
				case 'f': goto yy67;
				case 'D':
				case 'd': goto yy70;
				case 'H':
				case 'h': goto yy71;
				default: goto yy29;
			}
yy33:
			++p;
			{ PUSH_TOKEN1(TK_COLON); continue; }
yy34:
			++p;
			{ goto end; }
yy35:
			yych = *++p;
			switch (yych) {
				case '<': goto yy74;
				case '=': goto yy75;
				case '>': goto yy55;
				default: goto yy36;
			}
yy36:
			{ PUSH_TOKEN1(TK_LT); continue; }
yy37:
			yych = *++p;
			switch (yych) {
				case '=': goto yy76;
				default: goto yy38;
			}
yy38:
			{ PUSH_TOKEN1(TK_EQ); continue; }
yy39:
			yych = *++p;
			switch (yych) {
				case '=': goto yy77;
				case '>': goto yy78;
				default: goto yy40;
			}
yy40:
			{ PUSH_TOKEN1(TK_GT); continue; }
yy41:
			++p;
			{ PUSH_TOKEN1(TK_QUEST); continue; }
yy42:
			yyaccept = 2;
			yych = *(marker = ++p);
			switch (yych) {
				case '"': goto yy59;
				case '0':
				case '1': goto yy61;
				default: goto yy3;
			}
yy43:
			yych = *++p;
			switch (yych) {
				case '$':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy43;
				case '\'': goto yy79;
				default: goto yy44;
			}
yy44:
			{ str = string(p0, p);

                              // to upper
                              if (g_upper_case) str = str_toupper(str);

                              // handle af' et all
                              Keyword keyword = keyword_lookup(str);
                              if (str.back() == '\'' && keyword == KW_NONE) { // drop quote
                                  str.pop_back();
                                  p--;
                                  keyword = keyword_lookup(str);
                              }

                              // check for -IXIY
                              if (g_swap_ixiy != IXIY_NO_SWAP) {
                                  switch (keyword) {
                                  case KW_IX: case KW_IXH: case KW_IXL:
                                  case KW_IY: case KW_IYH: case KW_IYL:
                                      str = str_swap_xy(str);
                                      keyword = keyword_lookup(str);
                                      break;
                                  default:;
                                  }
                              }

                              // check for .ASSUME
                              if (keyword == KW_ASSUME && !tokens_.empty() && tokens_.back().code() == TK_DOT)
                                  tokens_.pop_back();       // remove '.'

                              // need raw strings after INCLUDE, BINARY, INCBIN, LINE, C_LINE
                              switch (keyword) {
                              case KW_INCLUDE: case KW_BINARY: case KW_INCBIN:
                              case KW_LINE:    case KW_C_LINE:
                                  raw_strings = true;
                                  break;
                              default:;
                              }

                              // check for ASMPC
                              if (keyword == KW_ASMPC)
                                  PUSH_TOKEN1(TK_ASMPC);
                              else
                                  PUSH_TOKEN2(TK_IDENT, str);

                              continue;
                            }
yy45:
			++p;
			{ PUSH_TOKEN1(TK_LSQUARE); continue; }
yy46:
			++p;
			{ PUSH_TOKEN1(TK_BACKSLASH); continue; }
yy47:
			++p;
			{ PUSH_TOKEN1(TK_RSQUARE); continue; }
yy48:
			yych = *++p;
			switch (yych) {
				case '^': goto yy80;
				default: goto yy49;
			}
yy49:
			{ PUSH_TOKEN1(TK_BINXOR); continue; }
yy50:
			++p;
			{ PUSH_TOKEN1(TK_LBRACE); continue; }
yy51:
			yych = *++p;
			switch (yych) {
				case '|': goto yy81;
				default: goto yy52;
			}
yy52:
			{ PUSH_TOKEN1(TK_BINOR); continue; }
yy53:
			++p;
			{ PUSH_TOKEN1(TK_RBRACE); continue; }
yy54:
			++p;
			{ PUSH_TOKEN1(TK_BINNOT); continue; }
yy55:
			++p;
			{ PUSH_TOKEN1(TK_NE); continue; }
yy56:
			++p;
			{ PUSH_TOKEN1(TK_DBLHASH); continue; }
yy57:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy57;
				default: goto yy58;
			}
yy58:
			{ PUSH_TOKEN2(TK_INTEGER, a2i(p0+1, p, 16)); continue; }
yy59:
			yych = *++p;
			switch (yych) {
				case '"': goto yy82;
				case '#':
				case '-': goto yy59;
				default: goto yy60;
			}
yy60:
			p = marker;
			switch (yyaccept) {
				case 0: goto yy14;
				case 1: goto yy29;
				case 2: goto yy3;
				case 3: goto yy66;
				case 4: goto yy69;
				default: goto yy86;
			}
yy61:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1': goto yy61;
				default: goto yy62;
			}
yy62:
			{ PUSH_TOKEN2(TK_INTEGER, a2i(p0+1, p, 2)); continue; }
yy63:
			++p;
			{ PUSH_TOKEN1(TK_LOGAND); continue; }
yy64:
			++p;
			{ PUSH_TOKEN1(TK_POWER); continue; }
yy65:
			yyaccept = 3;
			yych = *(marker = ++p);
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy65;
				case 'E':
				case 'e': goto yy83;
				default: goto yy66;
			}
yy66:
			{ PUSH_TOKEN2(TK_FLOATING, a2f(p0, p)); continue; }
yy67:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy67;
				case 'H':
				case 'h': goto yy71;
				default: goto yy60;
			}
yy68:
			yyaccept = 4;
			yych = *(marker = ++p);
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'H':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'h': goto yy85;
				default: goto yy69;
			}
yy69:
			{ PUSH_TOKEN2(TK_INTEGER, a2i(p0, p, 2)); continue; }
yy70:
			yyaccept = 1;
			yych = *(marker = ++p);
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy67;
				case 'H':
				case 'h': goto yy71;
				default: goto yy29;
			}
yy71:
			++p;
			{ PUSH_TOKEN2(TK_INTEGER, a2i(p0, p, 16)); continue; }
yy72:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy87;
				default: goto yy60;
			}
yy73:
			yyaccept = 4;
			yych = *(marker = ++p);
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy67;
				case 'H':
				case 'h': goto yy71;
				default: goto yy69;
			}
yy74:
			++p;
			{ PUSH_TOKEN1(TK_LSHIFT); continue; }
yy75:
			++p;
			{ PUSH_TOKEN1(TK_LE); continue; }
yy76:
			++p;
			goto yy38;
yy77:
			++p;
			{ PUSH_TOKEN1(TK_GE); continue; }
yy78:
			++p;
			{ PUSH_TOKEN1(TK_RSHIFT); continue; }
yy79:
			++p;
			goto yy44;
yy80:
			++p;
			{ PUSH_TOKEN1(TK_LOGXOR); continue; }
yy81:
			++p;
			{ PUSH_TOKEN1(TK_LOGOR); continue; }
yy82:
			++p;
			{
                              int n = 0;
                              for (const char* i = p0+2; i < p-1; i++) {
                                  n *= 2;
                                  if (*i == '#') n++;
                              }
                              PUSH_TOKEN2(TK_INTEGER, n);
                              continue;
                            }
yy83:
			yych = *++p;
			switch (yych) {
				case '+':
				case '-': goto yy89;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy90;
				default: goto yy60;
			}
yy84:
			yyaccept = 5;
			yych = *(marker = ++p);
yy85:
			switch (yych) {
				case '0':
				case '1': goto yy84;
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy67;
				case 'H':
				case 'h': goto yy71;
				default: goto yy86;
			}
yy86:
			{ PUSH_TOKEN2(TK_INTEGER, a2i(p0+2, p, 2)); continue; }
yy87:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy87;
				default: goto yy88;
			}
yy88:
			{ PUSH_TOKEN2(TK_INTEGER, a2i(p0+2, p, 16)); continue; }
yy89:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy90;
				default: goto yy60;
			}
yy90:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy90;
				default: goto yy66;
			}
		}

    }

string_loop:
    str.clear();
    while (true) {
        p0 = p;

#define PUSH_CHAR(c)        do { if (raw_strings) { str.push_back(*p0); p = p0+1; } \
                                 else { str.push_back( (c) & 0xff ); } } while (0)

        
		{
			char yych;
			yych = *p;
			switch (yych) {
				case 0x00: goto yy92;
				case '"': goto yy95;
				case '\'': goto yy96;
				case '\\': goto yy97;
				default: goto yy93;
			}
yy92:
			++p;
			{ p--; g_asm.error(ErrMissingQuote, pstr); got_error = true; goto end; }
yy93:
			++p;
yy94:
			{ str.push_back(*p0); continue; }
yy95:
			++p;
			{ if (quote == 2) {
                                  PUSH_TOKEN2(TK_STRING, str);
                                  goto main_loop;
                              }
                              else {
                                  str.push_back(*p0);
                                  continue;
                              }
                            }
yy96:
			++p;
			{ if (quote == 1) {
                                  if (str.length() != 1) {
                                      g_asm.error(ErrInvalidCharConst, pstr); got_error = true; goto end;
                                  }
                                  else {
                                      PUSH_TOKEN2(TK_INTEGER, str[0]);
                                      goto main_loop;
                                  }
                              }
                              else {
                                  str.push_back(*p0);
                                  continue;
                              }
                            }
yy97:
			yych = *++p;
			switch (yych) {
				case '\n': goto yy94;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7': goto yy100;
				case 'a': goto yy102;
				case 'b': goto yy103;
				case 'e': goto yy104;
				case 'f': goto yy105;
				case 'n': goto yy106;
				case 'r': goto yy107;
				case 't': goto yy108;
				case 'v': goto yy109;
				case 'x': goto yy110;
				default: goto yy98;
			}
yy98:
			++p;
yy99:
			{ PUSH_CHAR(p0[1]); continue; }
yy100:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7': goto yy111;
				default: goto yy101;
			}
yy101:
			{ PUSH_CHAR(a2i(p0+1, p, 8)); continue; }
yy102:
			++p;
			{ PUSH_CHAR('\a'); continue; }
yy103:
			++p;
			{ PUSH_CHAR('\b'); continue; }
yy104:
			++p;
			{ PUSH_CHAR('\x1b'); continue; }
yy105:
			++p;
			{ PUSH_CHAR('\f'); continue; }
yy106:
			++p;
			{ PUSH_CHAR('\n'); continue; }
yy107:
			++p;
			{ PUSH_CHAR('\r'); continue; }
yy108:
			++p;
			{ PUSH_CHAR('\t'); continue; }
yy109:
			++p;
			{ PUSH_CHAR('\v'); continue; }
yy110:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy112;
				default: goto yy99;
			}
yy111:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7': goto yy114;
				default: goto yy101;
			}
yy112:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy115;
				default: goto yy113;
			}
yy113:
			{ PUSH_CHAR(a2i(p0+2, p, 16)); continue; }
yy114:
			++p;
			goto yy101;
yy115:
			++p;
			goto yy113;
		}

    }

end:
    if (got_error)
        clear();
    return !got_error;
}

string Lexer::text() const {
    return Token::to_string(tokens_);
}

string Lexer::peek_text(int idx) const {
    vector<Token> pending_tokens;
    for (int i = pos_ + idx; i < (int)tokens_.size(); i++)
        if (i >= 0)
            pending_tokens.push_back(tokens_[i]);
    return Token::to_string(pending_tokens);
}

const Token& Lexer::peek(int idx) {
    static const Token end{ TK_END, false };
    int i = pos_ + idx;
    if (i >= 0 && i < (int)tokens_.size())
        return tokens_[i];
    else
        return end;
}

void Lexer::next(int n) {
    pos_ += n;
}

bool Lexer::at_end() const {
    return pos_ >= (int)tokens_.size();
}

void Lexer::flush() {
    pos_ = (int)tokens_.size();
}

Symbol* Token::symbol() const {
    xassert(symbol_);
    return symbol_;
}

void Token::set_code(TkCode code) {
    code_ = code;
}

void Token::set_ivalue(int ivalue) {
    ivalue_ = ivalue;
}

void Token::set_fvalue(double fvalue) {
    fvalue_ = fvalue;
}

void Token::set_svalue(const string& svalue) {
    svalue_ = svalue;
    keyword_ = keyword_lookup(svalue_);
}

void Token::set_symbol(Symbol* symbol) {
    symbol_ = symbol;
}
