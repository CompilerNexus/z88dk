/* Generated by re2c 3.1 */
//-----------------------------------------------------------------------------
// z80asm
// Copyright (C) Paulo Custodio, 2011-2024
// License: The Artistic License 2.0, http://www.perlfoundation.org/artistic_license_2_0
//-----------------------------------------------------------------------------

#include "scan_re.h"
#include "z80asm.h"
using namespace std;

//-----------------------------------------------------------------------------



		#define YYMAXFILL 4


//-----------------------------------------------------------------------------

#if 0
static int a2i(const char* start, const char* end, int base) {
    return static_cast<int>(strtol(string(start, end).c_str(), NULL, base));
}
#endif

#if 0
static double a2f(const char* start, const char* end) {
    return atof(string(start, end).c_str());
}
#endif

#if 0
static string str_swap_x_y(string str) {
    for (auto& c : str) {
        switch (c) {
        case 'x': c = 'y'; break;
        case 'X': c = 'Y'; break;
        case 'y': c = 'x'; break;
        case 'Y': c = 'X'; break;
        default:;
        }
    }
    return str;
}
#endif

//-----------------------------------------------------------------------------
// Tokens
//-----------------------------------------------------------------------------

#if 0
Tokens::Tokens(const string& text) {
    string str;
    int quote = 0;
    bool raw_strings = g_args.opt_raw_strings;
    is_ok = true;
    bool blank_before = false;
    const char* p = text.c_str(), * p0 = p, * marker = p;

main_loop:
    while (true) {
        p0 = p;

#define PUSH_TOKEN1(ttype)          do { m_tokens.emplace_back(ttype, blank_before); \
                                         blank_before = false; } while (0)
#define PUSH_TOKEN2(ttype, arg)     do { m_tokens.emplace_back(ttype, blank_before, arg); \
                                         blank_before = false; } while (0)
#define PUSH_TOKEN3(ttype, arg1, arg2) \
                                    do { m_tokens.emplace_back(ttype, blank_before, arg1, arg2); \
                                         blank_before = false; } while (0)
#define ERROR(...)                  do { g_errors.error(__VA_ARGS__); \
                                         is_ok = false; } while (0)
        
		{
			char yych;
			unsigned int yyaccept = 0;
			yych = *p;
			switch (yych) {
				case 0x00: goto yy1;
				case '\t':
				case '\n':
				case '\v':
				case '\f':
				case '\r':
				case ' ': goto yy4;
				case '!': goto yy6;
				case '"': goto yy8;
				case '#': goto yy9;
				case '$': goto yy11;
				case '%': goto yy13;
				case '&': goto yy15;
				case '\'': goto yy17;
				case '(': goto yy18;
				case ')': goto yy19;
				case '*': goto yy20;
				case '+': goto yy22;
				case ',': goto yy23;
				case '-': goto yy24;
				case '.': goto yy25;
				case '/': goto yy27;
				case '0': goto yy28;
				case '1': goto yy30;
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy32;
				case ':': goto yy33;
				case ';': goto yy34;
				case '<': goto yy35;
				case '=': goto yy37;
				case '>': goto yy39;
				case '?': goto yy41;
				case '@': goto yy42;
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy43;
				case '[': goto yy45;
				case '\\': goto yy46;
				case ']': goto yy47;
				case '^': goto yy48;
				case '{': goto yy50;
				case '|': goto yy51;
				case '}': goto yy53;
				case '~': goto yy54;
				default: goto yy2;
			}
yy1:
			++p;
			{ p--; goto end; }
yy2:
			++p;
yy3:
			{ p--; string error_char(1, *p);
                              ERROR(Errors::Code::invalid_character,
                                        (*p > 32 && *p < 127) ? error_char :
                                        int_to_hex(*p & 0xff, 2));
                              goto end; }
yy4:
			yych = *++p;
			switch (yych) {
				case '\t':
				case '\n':
				case '\v':
				case '\f':
				case '\r':
				case ' ': goto yy4;
				default: goto yy5;
			}
yy5:
			{ blank_before = true; continue; }
yy6:
			yych = *++p;
			switch (yych) {
				case '=': goto yy55;
				default: goto yy7;
			}
yy7:
			{ PUSH_TOKEN1(TType::LogNot); continue; }
yy8:
			++p;
			{ quote = 2; goto string_loop; }
yy9:
			yych = *++p;
			switch (yych) {
				case '#': goto yy56;
				default: goto yy10;
			}
yy10:
			{ PUSH_TOKEN1(TType::Hash); continue; }
yy11:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy57;
				default: goto yy12;
			}
yy12:
			{ PUSH_TOKEN1(TType::Dollar); continue; }
yy13:
			yyaccept = 0;
			yych = *(marker = ++p);
			switch (yych) {
				case '"': goto yy59;
				case '0':
				case '1': goto yy61;
				default: goto yy14;
			}
yy14:
			{ PUSH_TOKEN1(TType::Mod); continue; }
yy15:
			yych = *++p;
			switch (yych) {
				case '&': goto yy63;
				default: goto yy16;
			}
yy16:
			{ PUSH_TOKEN1(TType::BinAnd); continue; }
yy17:
			++p;
			{ quote = 1; goto string_loop; }
yy18:
			++p;
			{ PUSH_TOKEN1(TType::LParen); continue; }
yy19:
			++p;
			{ PUSH_TOKEN1(TType::RParen); continue; }
yy20:
			yych = *++p;
			switch (yych) {
				case '*': goto yy64;
				default: goto yy21;
			}
yy21:
			{ PUSH_TOKEN1(TType::Mult); continue; }
yy22:
			++p;
			{ PUSH_TOKEN1(TType::Plus); continue; }
yy23:
			++p;
			{ PUSH_TOKEN1(TType::Comma); continue; }
yy24:
			++p;
			{ PUSH_TOKEN1(TType::Minus); continue; }
yy25:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy65;
				default: goto yy26;
			}
yy26:
			{ PUSH_TOKEN1(TType::Dot); continue; }
yy27:
			++p;
			{ PUSH_TOKEN1(TType::Div); continue; }
yy28:
			yyaccept = 1;
			yych = *(marker = ++p);
			switch (yych) {
				case 'B':
				case 'b': goto yy68;
				case 'X':
				case 'x': goto yy72;
				default: goto yy31;
			}
yy29:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0, p, 10)); continue; }
yy30:
			yyaccept = 1;
			yych = *(marker = ++p);
yy31:
			switch (yych) {
				case '.': goto yy65;
				case '0':
				case '1': goto yy30;
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy32;
				case 'A':
				case 'C':
				case 'E':
				case 'F':
				case 'a':
				case 'c':
				case 'e':
				case 'f': goto yy67;
				case 'B':
				case 'b': goto yy73;
				case 'D':
				case 'd': goto yy70;
				case 'H':
				case 'h': goto yy71;
				default: goto yy29;
			}
yy32:
			yyaccept = 1;
			yych = *(marker = ++p);
			switch (yych) {
				case '.': goto yy65;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy32;
				case 'A':
				case 'B':
				case 'C':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'e':
				case 'f': goto yy67;
				case 'D':
				case 'd': goto yy70;
				case 'H':
				case 'h': goto yy71;
				default: goto yy29;
			}
yy33:
			++p;
			{ PUSH_TOKEN1(TType::Colon); continue; }
yy34:
			++p;
			{ goto end; }
yy35:
			yych = *++p;
			switch (yych) {
				case '<': goto yy74;
				case '=': goto yy75;
				case '>': goto yy55;
				default: goto yy36;
			}
yy36:
			{ PUSH_TOKEN1(TType::Lt); continue; }
yy37:
			yych = *++p;
			switch (yych) {
				case '=': goto yy76;
				default: goto yy38;
			}
yy38:
			{ PUSH_TOKEN1(TType::Eq); continue; }
yy39:
			yych = *++p;
			switch (yych) {
				case '=': goto yy77;
				case '>': goto yy78;
				default: goto yy40;
			}
yy40:
			{ PUSH_TOKEN1(TType::Gt); continue; }
yy41:
			++p;
			{ PUSH_TOKEN1(TType::Quest); continue; }
yy42:
			yyaccept = 2;
			yych = *(marker = ++p);
			switch (yych) {
				case '"': goto yy59;
				case '0':
				case '1': goto yy61;
				default: goto yy3;
			}
yy43:
			yych = *++p;
			switch (yych) {
				case '$':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy43;
				case '\'': goto yy79;
				default: goto yy44;
			}
yy44:
			{ str = string(p0, p);

                              // to upper
                              if (g_args.opt_ucase)
                                  str = str_toupper(str);

                              // handle af' et all
                              Keyword keyword = keyword_lookup(str);
                              if (str.back() == '\'' && keyword == Keyword::None) { // drop quote
                                  str.pop_back();
                                  p--;
                                  keyword = keyword_lookup(str);
                              }

                              // check for -IXIY
                              if (g_args.opt_swap_ixiy != SwapIXIY::no_swap) {
                                  switch (keyword) {
                                  case Keyword::IX: case Keyword::IXH: case Keyword::IXL:
                                  case Keyword::IY: case Keyword::IYH: case Keyword::IYL:
                                      str = str_swap_x_y(str);
                                      keyword = keyword_lookup(str);
                                      break;
                                  default:;
                                  }
                              }

                              // check for .ASSUME
                              if (keyword == Keyword::ASSUME && !m_tokens.empty() &&
                                  m_tokens.back().ttype  == TType::Dot)
                                  m_tokens.pop_back();       // remove '.'

                              // need raw strings after INCLUDE, BINARY, INCBIN, LINE, C_LINE
                              switch (keyword) {
                              case Keyword::INCLUDE: case Keyword::BINARY: case Keyword::INCBIN:
                              case Keyword::LINE:    case Keyword::C_LINE:
                                raw_strings = true;
                                break;
                              default:;
                              }

                              // check for ASMPC
                              if (keyword == Keyword::ASMPC)
                                PUSH_TOKEN1(TType::Dollar);
                              else
                                PUSH_TOKEN3(TType::Ident, str, keyword);
                              continue;
                            }
yy45:
			++p;
			{ PUSH_TOKEN1(TType::LSquare); continue; }
yy46:
			++p;
			{ PUSH_TOKEN1(TType::Backslash); continue; }
yy47:
			++p;
			{ PUSH_TOKEN1(TType::RSquare); continue; }
yy48:
			yych = *++p;
			switch (yych) {
				case '^': goto yy80;
				default: goto yy49;
			}
yy49:
			{ PUSH_TOKEN1(TType::BinXor); continue; }
yy50:
			++p;
			{ PUSH_TOKEN1(TType::LBrace); continue; }
yy51:
			yych = *++p;
			switch (yych) {
				case '|': goto yy81;
				default: goto yy52;
			}
yy52:
			{ PUSH_TOKEN1(TType::BinOr); continue; }
yy53:
			++p;
			{ PUSH_TOKEN1(TType::RBrace); continue; }
yy54:
			++p;
			{ PUSH_TOKEN1(TType::BinNot); continue; }
yy55:
			++p;
			{ PUSH_TOKEN1(TType::Ne); continue; }
yy56:
			++p;
			{ PUSH_TOKEN1(TType::DblHash); continue; }
yy57:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy57;
				default: goto yy58;
			}
yy58:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0+1, p, 16)); continue; }
yy59:
			yych = *++p;
			switch (yych) {
				case '"': goto yy82;
				case '#':
				case '-': goto yy59;
				default: goto yy60;
			}
yy60:
			p = marker;
			switch (yyaccept) {
				case 0: goto yy14;
				case 1: goto yy29;
				case 2: goto yy3;
				case 3: goto yy66;
				case 4: goto yy69;
				default: goto yy86;
			}
yy61:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1': goto yy61;
				default: goto yy62;
			}
yy62:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0+1, p, 2)); continue; }
yy63:
			++p;
			{ PUSH_TOKEN1(TType::LogAnd); continue; }
yy64:
			++p;
			{ PUSH_TOKEN1(TType::Power); continue; }
yy65:
			yyaccept = 3;
			yych = *(marker = ++p);
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy65;
				case 'E':
				case 'e': goto yy83;
				default: goto yy66;
			}
yy66:
			{ PUSH_TOKEN2(TType::Floating, a2f(p0, p)); continue; }
yy67:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy67;
				case 'H':
				case 'h': goto yy71;
				default: goto yy60;
			}
yy68:
			yyaccept = 4;
			yych = *(marker = ++p);
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'H':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'h': goto yy85;
				default: goto yy69;
			}
yy69:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0, p, 2)); continue; }
yy70:
			yyaccept = 1;
			yych = *(marker = ++p);
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy67;
				case 'H':
				case 'h': goto yy71;
				default: goto yy29;
			}
yy71:
			++p;
			{ PUSH_TOKEN2(TType::Integer, a2i(p0, p, 16)); continue; }
yy72:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy87;
				default: goto yy60;
			}
yy73:
			yyaccept = 4;
			yych = *(marker = ++p);
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy67;
				case 'H':
				case 'h': goto yy71;
				default: goto yy69;
			}
yy74:
			++p;
			{ PUSH_TOKEN1(TType::LShift); continue; }
yy75:
			++p;
			{ PUSH_TOKEN1(TType::Le); continue; }
yy76:
			++p;
			goto yy38;
yy77:
			++p;
			{ PUSH_TOKEN1(TType::Ge); continue; }
yy78:
			++p;
			{ PUSH_TOKEN1(TType::RShift); continue; }
yy79:
			++p;
			goto yy44;
yy80:
			++p;
			{ PUSH_TOKEN1(TType::LogXor); continue; }
yy81:
			++p;
			{ PUSH_TOKEN1(TType::LogOr); continue; }
yy82:
			++p;
			{
                              int n = 0;
                              for (const char* i = p0+2; i < p-1; i++) {
                                  n *= 2;
                                  if (*i == '#') n++;
                              }
                              PUSH_TOKEN2(TType::Integer, n);
                              continue;
                            }
yy83:
			yych = *++p;
			switch (yych) {
				case '+':
				case '-': goto yy89;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy90;
				default: goto yy60;
			}
yy84:
			yyaccept = 5;
			yych = *(marker = ++p);
yy85:
			switch (yych) {
				case '0':
				case '1': goto yy84;
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy67;
				case 'H':
				case 'h': goto yy71;
				default: goto yy86;
			}
yy86:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0+2, p, 2)); continue; }
yy87:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy87;
				default: goto yy88;
			}
yy88:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0+2, p, 16)); continue; }
yy89:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy90;
				default: goto yy60;
			}
yy90:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy90;
				default: goto yy66;
			}
		}

    }

string_loop:
    str.clear();
    while (true) {
        p0 = p;
        
		{
			char yych;
			yych = *p;
			switch (yych) {
				case 0x00: goto yy92;
				case '"': goto yy95;
				case '\'': goto yy96;
				case '\\': goto yy97;
				default: goto yy93;
			}
yy92:
			++p;
			{ p--; ERROR(Errors::Code::missing_quote); goto end; }
yy93:
			++p;
yy94:
			{ str.push_back(*p0); continue; }
yy95:
			++p;
			{ if (quote == 2) {
                                PUSH_TOKEN2(TType::String, str);
                                goto main_loop;
                              }
                              else {
                                str.push_back(*p0);
                                continue;
                              }
                            }
yy96:
			++p;
			{ if (quote == 1) {
                                if (str.length() != 1) {
                                  ERROR(Errors::Code::invalid_character_constant);
                                  goto main_loop;
                                }
                                else {
                                  PUSH_TOKEN2(TType::Integer, str[0]);
                                  goto main_loop;
                                }
                              }
                              else {
                                str.push_back(*p0);
                                continue;
                              }
                            }
yy97:
			yych = *++p;
			switch (yych) {
				case '\n': goto yy94;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7': goto yy100;
				case 'a': goto yy102;
				case 'b': goto yy103;
				case 'e': goto yy104;
				case 'f': goto yy105;
				case 'n': goto yy106;
				case 'r': goto yy107;
				case 't': goto yy108;
				case 'v': goto yy109;
				case 'x': goto yy110;
				default: goto yy98;
			}
yy98:
			++p;
yy99:
			{ if (raw_strings) {
                                str.push_back(*p0); p--;
                              }
                              else {
                                str.push_back(p0[1]);
                              }
                              continue;
                            }
yy100:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7': goto yy111;
				default: goto yy101;
			}
yy101:
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back(a2i(p0+1, p, 8)); } continue; }
yy102:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\a'); } continue; }
yy103:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\b'); } continue; }
yy104:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\x1b'); } continue; }
yy105:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\f'); } continue; }
yy106:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\n'); } continue; }
yy107:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\r'); } continue; }
yy108:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\t'); } continue; }
yy109:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\v'); } continue; }
yy110:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy112;
				default: goto yy99;
			}
yy111:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7': goto yy114;
				default: goto yy101;
			}
yy112:
			yych = *++p;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f': goto yy115;
				default: goto yy113;
			}
yy113:
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back(a2i(p0+2, p, 16)); } continue; }
yy114:
			++p;
			goto yy101;
yy115:
			++p;
			goto yy113;
		}

    }

end:
    if (!is_ok)
        m_tokens.clear();
}

Tokens::Tokens(const vector<Token>& tokens)
    : m_tokens(tokens) {
}

Token& Tokens::operator[](int offset) {
    static Token end{ TType::End, false };
    size_t index = pos + offset;
    if (index >= m_tokens.size())
        return end;
    else
        return m_tokens[index];
}

void Tokens::clear() {
    pos = 0;
    is_ok = true;
    m_tokens.clear();
}

void Tokens::push_back(const string& text) {
    Tokens other = Tokens(text);
    m_tokens.insert(m_tokens.end(), other.cbegin(), other.cend());
}

void Tokens::push_back(const Tokens& other) {
    m_tokens.insert(m_tokens.end(), other.cbegin(), other.cend());
}

string Tokens::to_string() const {
    string out;
    for (auto& token : m_tokens) {
        if (token.blank_before)
            out += " ";
        out = concat(out, token.to_string());
    }
    return out;
}

Tokens Tokens::peek_tokens(int offset) {
    size_t start = pos + offset;
    if (static_cast<size_t>(start) >= m_tokens.size())
        return Tokens();
    else {
        vector<Token> tokens;
        tokens.insert(tokens.end(), m_tokens.begin() + start, m_tokens.end());
        return Tokens(tokens);
    }
}

string to_string(const Tokens& tokens) {
    return tokens.to_string();
}

#endif
